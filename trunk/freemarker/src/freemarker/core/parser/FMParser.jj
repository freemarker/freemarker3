/*
 * Copyright (c) 2003-2008 The Visigoth Software Society. All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution, if
 *    any, must include the following acknowledgement:
 *       "This product includes software developed by the
 *        Visigoth Software Society (http://www.visigoths.org/)."
 *    Alternately, this acknowledgement may appear in the software itself,
 *    if and wherever such third-party acknowledgements normally appear.
 *
 * 4. Neither the name "FreeMarker", "Visigoth", nor any of the names of the 
 *    project contributors may be used to endorse or promote products derived
 *    from this software without prior written permission. For written
 *    permission, please contact visigoths@visigoths.org.
 *
 * 5. Products derived from this software may not be called "FreeMarker" or "Visigoth"
 *    nor may "FreeMarker" or "Visigoth" appear in their names
 *    without prior written permission of the Visigoth Software Society.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE VISIGOTH SOFTWARE SOCIETY OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Visigoth Software Society. For more
 * information on the Visigoth Software Society, please see
 * http://www.visigoths.org/
 */

options
{
   STATIC=false;
   UNICODE_INPUT=true;
   COMMON_TOKEN_ACTION=true;   
//   DEBUG_TOKEN_MANAGER=true;
//   DEBUG_PARSER=true;
}

PARSER_BEGIN(FMParser)

package freemarker.core.parser;

import freemarker.core.ast.*;
import freemarker.template.*;
import freemarker.template.utility.StringUtil;
import java.io.*;
import java.util.*;
import java.security.CodeSource;

/**
 * This class is generated by JavaCC from a grammar file.
 */
public class FMParser {

// Necessary for adding macros and setting location info.
  Template template;
  private String templateName;

  private boolean stripText;
// variables that keep track of whether we are in a loop or a switch.
  private int contentNesting; // for stripText
  private int trimBlockNesting;
  
  /**
   * Create an FM expression parser using a string.
   */
  static public FMParser createExpressionParser(String s) {
      SimpleCharStream scs = new SimpleCharStream(new StringReader(s), 1, 1, s.length());
      FMParserTokenManager token_source = new FMParserTokenManager(scs);
      token_source.SwitchTo(FMParserConstants.EXPRESSION);
      return new FMParser(token_source);
  }
  
  /**
   * Constructs a new parser object.
   * @param template The template associated with this parser.
   * @param reader The character stream to use as input
   */
  public FMParser(Template template, Reader reader) {
      this(reader);
      this.template = template;
      this.templateName = template != null ? template.getName() : "";
      token_source.templateName = templateName;
      token_source.input_stream.setTabSize(1);
  }
  
  public FMParser(Template template, Reader reader, int syntaxSetting) {
  	  this(template, reader);
  	  if (syntaxSetting != Configuration.AUTO_DETECT_TAG_SYNTAX) {
  	  	   token_source.setAltDirectiveSyntax(syntaxSetting==Configuration.SQUARE_BRACKET_TAG_SYNTAX);
  	  }
  }
  
  public FMParser(Template template, String input, int syntaxSetting) {
  	  this(template, new StringReader(input), syntaxSetting); 
  }
  
  public void setTemplate(Template t) {
      this.template = t;
  }
  
  private String getErrorStart(Token t) {
      return "Error in template: " + template.getName()
            + "\non line " + t.beginLine + ", column " + t.beginColumn;
  }
  
  public boolean isSyntaxSet() {
  	  return token_source.directiveSyntaxEstablished;
  }
  
  public boolean isAltDirectiveSyntax() {
  	  return token_source.altDirectiveSyntax;
  }
  
  /**
   * Used in error recovery, scans forward for a 
   * token of a given kind, and optionally consumes it.
   * @return the token right before the one of the kind
   *         that we were scanning ahead for
   */
  
  private Token recoverToToken(int kind, boolean consume) {
  	  Token t = this.token, prevToken;
  	  do {
  	  	prevToken = t;
  	  	t = getNextToken();
  	  } while (t.kind != kind && t.kind != EOF);
  	  if (!consume) {
  	  	this.token = prevToken;
  	  }
	  return prevToken;
  }
  
  
}

PARSER_END(FMParser)

/**
 * The lexer portion defines 5 lexical states:
 * DEFAULT, NO_PARSE, EXPRESSION, EXPRESSION_COMMENT, 
 * NO_SPACE_EXPRESSION
 * The lexer is in the DEFAULT state when it is 
 * just consuming regular text, but are scanning for
 * FreeMarker constructs. NO_PARSE is the simplest state.
 * We are consuming text, but ignoring FreeMarker constructs,
 * so ${x} or [#if..] are just treated as plain text.
 * EXPRESSION is the state you are in
 * when the parser wants a FreeMarker expression.
 * So, for example, you enter the EXPRESSION state
 * right after a ${ and leave it after the matching }.
 * Or, you enter the EXPRESSION state right after
 * an "<#if" and then, when you hit the matching ">"
 * that ends the if directive, you go back to DEFAULT lexical state.
 * Note that whitespace is ignored in the
 * EXPRESSION statep but is passed through to the parser as PCDATA 
 * in the DEFAULT state. EXPRESSION_COMMENT is a lexical state
 * we are in if for comments within an FTL expression.
 * NO_SPACE_EXPRESSION is a slight variant on the EXPRESSION state. 
 * It basically exists as a kludge to deal with a nasty
 * little corner in FTL syntax. In NO_SPACE_EXPRESSION,
 * spaces are not ignored, so a whitespace token effectively ends
 * the parsing of an expression. THus, for example, [@x (y+1)/]
 * is parsed as the macro x with the single argument (y+1) rather than
 * the macro x(y+1) with no args.
 */

TOKEN_MGR_DECLS :
{

/**
  The noparseType is set when we enter
  a block of text that the parser more or less ignores.
  These are <noparse> and <comment>. This variable
  tells us what the closing tag should be, and when
  we hit that, we resume parsing. Note that with this
  scheme, <comment> and <noparse> tags cannot nest
  recursively, but it is not clear how important that is.
*/
    private int noparseType;

/**
    Keeps track of how deeply nested
    we have the hash literals.
    This is necessary since we need to be
    able to distinguish the } used to close
    a hash literal and the one used to
    close a ${
 */
 private int hashLiteralNesting;
 private int parenthesisNesting;
 private int bracketNesting;
 boolean onlyTextOutput, 
         directiveSyntaxEstablished, 
         altDirectiveSyntax,
         inInvocation,
         justAfterDot;
 String templateName;
 
 public void setOnlyTextOutput(boolean b) {
     this.onlyTextOutput = b;
 }
 
 void setAltDirectiveSyntax(boolean b) {
    altDirectiveSyntax = b;
    directiveSyntaxEstablished = true;
 }
 
 
 private void CommonTokenAction(Token token) {
 	if (token.kind == EOF) return;
 	String tokText = token.image;
 	char firstChar = tokText.charAt(0);
 	if (justAfterDot) {
 		if (StringUtil.isFTLIdentifier(tokText) || tokText.equals("*") || tokText.equals("**")) {
 			token.kind = ID;
 			return;
 		} 
 	}
 	if (firstChar == '[' || firstChar=='<') {
 		String chopFirst = tokText.substring(1);
 		if (chopFirst.startsWith("#") || chopFirst.startsWith("/#")
 		    || chopFirst.startsWith("@") || chopFirst.startsWith("/@")) {
 			if (this.onlyTextOutput) {
 				token.kind = PRINTABLE_CHARS;
 				return;
 			}
	 		boolean squareBracket = firstChar == '[';
 			if (!directiveSyntaxEstablished) {
 				setAltDirectiveSyntax(squareBracket);
 			} 
 			else if (altDirectiveSyntax != squareBracket) {
 				token.kind = PRINTABLE_CHARS;
 				return;
 			}
 			if (token.kind == UNKNOWN_DIRECTIVE) {
    	      int index = tokText.indexOf('#');
        	  String s = tokText.substring(index);
              String msg = "Unknown directive: " 
                        + s
                        + " on line: " + token.beginLine
                        + ", column: " + token.beginColumn +1
                        + ", in template: " + templateName;
          	  throw new TokenMgrError(msg, TokenMgrError.LEXICAL_ERROR);
 			}
 		}
 	}
  	switch(token.kind) {
  		case FTL_HEADER : 
          SwitchTo(EXPRESSION);
          break;
        case GREATER_THAN_EQUALS : 
  		case GREATER_THAN:
			if (parenthesisNesting == 0 && !altDirectiveSyntax) {
				if (token.kind == GREATER_THAN_EQUALS) {
					input_stream.backup(1); // So that the = doesn't get eaten.
				} 
				token.kind = DIRECTIVE_END;
				SwitchTo(DEFAULT);
			}
			break;
		case OPEN_PAREN :
			parenthesisNesting++;
			SwitchTo(EXPRESSION);
			break;
		case CLOSE_PAREN : 
			parenthesisNesting--;
			break;
  		case OPEN_BRACKET:
  			bracketNesting++;
  			break;
  		case CLOSE_BRACKET : 
            if (bracketNesting >0) {
        	   --bracketNesting;
            } else {
            	token.kind=DIRECTIVE_END;
        		SwitchTo(DEFAULT);
            }   
            break; 
        case OPEN_BRACE :
        	++hashLiteralNesting;
        	break;
        case CLOSE_BRACE :
        	if (hashLiteralNesting >0) {
        		--hashLiteralNesting;
        	} else {
        		SwitchTo(DEFAULT);
        	}
        	break;
  		case UNIFIED_CALL:
  			SwitchTo(NO_SPACE_EXPRESSION);
  			break;
		case NOPARSE: 
			noparseType = NOPARSE;
			SwitchTo(NO_PARSE); 
			break; 		
 		case TERSE_COMMENT: 
 			noparseType = TERSE_COMMENT;
 			SwitchTo(NO_PARSE); 
 			break;
 		case COMMENT: 
 			noparseType = COMMENT;
 			SwitchTo(NO_PARSE); 
 			break;
 		case NOPARSE_END:
 			if (noparseType != NOPARSE) {
 				token.kind = PRINTABLE_CHARS;
 				break;
 			} // deliberate fall-through to next case...
 		case COMMENT_END:
 			if (token.kind == COMMENT_END && noparseType != COMMENT) {
	 			token.kind = PRINTABLE_CHARS;
 			} else {
 				char lastChar = tokText.charAt(tokText.length() -1);
 				char startTagChar = lastChar == ']' ? '[' : '<';
 				String extraChars = tokText.substring(0, tokText.lastIndexOf(startTagChar));
 				if (extraChars.length() >0) {
 					token.image = extraChars;
 					input_stream.backup(tokText.length() - extraChars.length());
 					token.kind = PRINTABLE_CHARS;
 				} else {
		 			SwitchTo(DEFAULT);
 				}
 			}
 			break;
 		case TERSE_COMMENT_END:
 			if (noparseType != TERSE_COMMENT) {
 				token.kind = PRINTABLE_CHARS;
 			}
 			else if (tokText.length() == 3) {
 				SwitchTo(DEFAULT);
 			}
 			else {
		 		token.image = tokText.substring(0, tokText.length() -3);
		 		input_stream.backup(3);
	 		 	token.kind = PRINTABLE_CHARS;
 			}
 			break;
  		case FUNCTION: case MACRO: case NESTED: case TRANSFORM: case STOP: case RETURN: case CALL:
  		case IF: case ELSE_IF: 
  		case VISIT: case RECURSE: 
 		case VAR: case SET: case ASSIGN: case LOCALASSIGN: case GLOBALASSIGN:
 		case LIST: case FOREACH:
 		case SWITCH: case CASE:
 		case INCLUDE: case IMPORT: case EMBED:  
  		case ESCAPE: case SETTING: 
 			SwitchTo(EXPRESSION);
 	}
 }
 }

TOKEN:
{
    <#BLANK : [" ", "\t", "\n", "\r"]>
    |
    <#START_TAG : "<#" | "[#">
    |
    <#CLOSE_TAG1 : (<BLANK>)* (">" | "]")>
    |
    <#CLOSE_TAG2 : (<BLANK>)* ("/")? (">" | "]")>
    |
    <CLOSE_DIRECTIVE_BLOCK : ("[/#" (~["]"])* "]") | ("</#" (~[">"])* ">")> 
    |
    <ATTEMPT : <START_TAG> "attempt" <CLOSE_TAG1>> 
    |
    <RECOVER : <START_TAG> "recover" <CLOSE_TAG1>>
    |
    <BLOCKTRIM : <START_TAG> "trim" <CLOSE_TAG1>>
    |
    <BLOCKTRIML : <START_TAG> "ltrim" <CLOSE_TAG2>>
    |
    <BLOCKTRIMR : <START_TAG> "rtrim" <CLOSE_TAG1>>
    |
    <BLOCKNOTRIM : <START_TAG> "notrim" <CLOSE_TAG1>>
    |
    <IF : <START_TAG> "if" <BLANK>> 
    |
    <ELSE_IF : <START_TAG> "elseif" <BLANK>>
    |
    <LIST : <START_TAG> "list" <BLANK>> 
    |
    <FOREACH : <START_TAG> "foreach" <BLANK>> 
    |
    <SWITCH : <START_TAG> "switch" <BLANK>>
    |
    <CASE : <START_TAG> "case" <BLANK>> 
    |
    <ASSIGN : <START_TAG> "assign" <BLANK>>
    |
    <GLOBALASSIGN : <START_TAG> "global" <BLANK>> 
    |
    <LOCALASSIGN : <START_TAG> "local" <BLANK>> 
    |
    <SET : <START_TAG> "set" <BLANK>>
    |
    <INCLUDE : <START_TAG> "include" <BLANK>> 
    |
    <IMPORT : <START_TAG> "import" <BLANK>> 
    |
    <FUNCTION : <START_TAG> "function" <BLANK>> 
    |
    <MACRO : <START_TAG> "macro" <BLANK>> 
    |
    <TRANSFORM : <START_TAG> "transform" <BLANK>> 
    |
    <VISIT : <START_TAG> "visit" <BLANK>> 
    |
    <STOP : <START_TAG> "stop" <BLANK>> 
    |
    <RETURN : <START_TAG> "return" <BLANK>> 
    |
    <CALL : <START_TAG> "call" <BLANK>> 
    |
    <SETTING : <START_TAG> "setting" <BLANK>> 
    |
    <EMBED : <START_TAG> "embed" <BLANK>> 
    |
    <VAR : <START_TAG> "var"  <BLANK>>
    |
    <COMPRESS : <START_TAG> "compress" <CLOSE_TAG1>> 
    |
    <COMMENT : <START_TAG> "comment" <CLOSE_TAG1>> 
    |
    <TERSE_COMMENT : ("<" | "[") "#--" >
    |
    <NOPARSE : <START_TAG> "noparse" <CLOSE_TAG1>> 
    |
    <ELSE : <START_TAG> "else" <CLOSE_TAG2>> 
    |
    <BREAK : <START_TAG> "break" <CLOSE_TAG2>> 
    |
    <SIMPLE_RETURN : <START_TAG> "return" <CLOSE_TAG2>>
    |
    <HALT : <START_TAG> "stop" <CLOSE_TAG2>> 
    |
    <FLUSH : <START_TAG> "flush" <CLOSE_TAG2>> 
    |
    <TRIM : <START_TAG> "t" <CLOSE_TAG2>> 
    |
    <LTRIM : <START_TAG> "lt" <CLOSE_TAG2>> 
    |
    <RTRIM : <START_TAG> "rt" <CLOSE_TAG2>> 
    |
    <NOTRIM : <START_TAG> "nt" <CLOSE_TAG2>> 
    |
    <DEFAUL : <START_TAG> "default" <CLOSE_TAG1>> 
    |
    <SIMPLE_NESTED : <START_TAG> "nested" <CLOSE_TAG2>> 
    |
    <NESTED : <START_TAG> "nested" <BLANK>> 
    |
    <SIMPLE_RECURSE : <START_TAG> "recurse" <CLOSE_TAG2>>
    |
    <RECURSE : <START_TAG> "recurse" <BLANK>>
    |
    <FALLBACK : <START_TAG> "fallback" <CLOSE_TAG2>> 
    |
    <ESCAPE : <START_TAG> "escape" <BLANK>> 
    |
    <NOESCAPE : <START_TAG> "noescape" <CLOSE_TAG1>> 
    |
    <UNIFIED_CALL : "<@" | "[@" > 
    |
    <UNIFIED_CALL_END : ("<" | "[") "/@" ((<ID>) ("."<ID>)*)? <CLOSE_TAG1>> 
    |
    <FTL_HEADER : ("<#ftl" | "[#ftl") <BLANK>>
    |
    <TRIVIAL_FTL_HEADER : ("<#ftl" | "[#ftl") ("/")? (">" | "]")>
    |
    <UNKNOWN_DIRECTIVE : ("[#" | "[/#" | "<#" | "</#") (["a"-"z","A"-"Z", "_"])+>
}

<DEFAULT, NODIRECTIVE> TOKEN :
{
    <WHITESPACE : (["\t", " ", "\r", "\n"])+>
    |
    <PRINTABLE_CHARS : ("$" | "#" | "<" | "[" | "{") 
                      | (~["$", "<", "#", "[", "{", "\n", "\r", "\t", " "])+>
    |
    <OUTPUT_ESCAPE : "${" > : EXPRESSION
    |
    <NUMERICAL_ESCAPE : "#{" > : EXPRESSION
}

<EXPRESSION> SKIP :
{
    < ( " " | "\t" | "\n" | "\r" )+ >
    |
    < ["<", "["]  ["#", "!"] "--"> : EXPRESSION_COMMENT
}

<EXPRESSION_COMMENT> SKIP:
{
    < ~[] >  
    |
    < "-->"> : EXPRESSION
    |
    < "--]" > : EXPRESSION
}

<EXPRESSION, NO_SPACE_EXPRESSION> TOKEN :
{
  <STRING_LITERAL :
      ("\"" 
          ((~["\\", "\""]) | ("\\" ~[]))*      
      "\"")
      |
      ("'"
          ((~["\\", "'"]) | ("\\" ~[]))*            
      "'")
  > 
  |
  <RAW_STRING : "r" (("\"" (~["\""])* "\"") | ("'" (~["'"])* "'"))>
  |
  <FALSE : "false">
  |
  <TRUE : "true">
  |
  <NULL : "null">
  |
  <INTEGER : (["0"-"9"])+>
  |
  <DECIMAL : <INTEGER> "." <INTEGER>>
  |
  <DOT : ".">
  |
  <DOT_DOT : "..">
  |
  <BUILT_IN : "?">
  |
  <EXISTS : "??">
  |
  <EQUALS : "=">
  |
  <DOUBLE_EQUALS : "==">
  |
  <NOT_EQUALS : "!=">
  |
  <GREATER_THAN : ">">
  |
  <GREATER_THAN_EQUALS: ">=">
  |
  <EMPTY_DIRECTIVE_END : "/>" | "/]"> :DEFAULT
  |
  <LESS_THAN : "lt" | "<" | "&lt;">
  |
  <LESS_THAN_EQUALS : "lte" | "<=" | "&lt;=">
  |
  <ESCAPED_GT: "gt" | "\\gt" |  "&gt;">
  |
  <ESCAPED_GTE : "gte" | "\\gte" | "&gt;=">
  |
  <PLUS : "+">
  |
  <MINUS : "-">
  |
  <TIMES : "*">
  |
  <DOUBLE_STAR : "**">
  |
  <ELLIPSIS : "...">
  |
  <DIVIDE : "/">
  |
  <PERCENT : "%">
  |
  <AND : "&" | "&&" >
  |
  <OR : "|" | "||">
  |
  <EXCLAM : "!">
  |
  <COMMA : ",">
  |
  <SEMICOLON : ";">
  |
  <COLON : ":">
  |
  <OPEN_BRACKET : "[">
  |
  <CLOSE_BRACKET : "]"> 
  |
  <OPEN_PAREN : "(">
  |
  <CLOSE_PAREN : ")">
  |
  <OPEN_BRACE : "{" > 
  |
  <CLOSE_BRACE : "}" >
  |
  <IN : "in">
  |
  <AS : "as">
  |
  <USING : "using">
  |
  <ID: <LETTER> (<LETTER>|<DIGIT>)* >
  |
  < #LETTER:
      [
       "\u0024",
       "\u0040"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
  |
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

<NO_SPACE_EXPRESSION> TOKEN :
{
    <TERMINATING_WHITESPACE :  (["\n", "\r", "\t", " "])+> : EXPRESSION
}

<EXPRESSION, NO_SPACE_EXPRESSION> TOKEN :
{
	<UNEXPECTED : ~[]>
}

<NO_PARSE> MORE: { <(~[])> }

<NO_PARSE> TOKEN :
{
	<TERSE_COMMENT_END : "-->" | "--]">
	|
    <COMMENT_END : ("</#comment" (<BLANK>)* ">") | ("[/#comment" (<BLANK>)* "]")>
    |
    <NOPARSE_END : ("</#noparse" (<BLANK>)* ">") | ("[/#noparse" (<BLANK>)* "]")>
}

<PHONY> TOKEN: {<DIRECTIVE_END : ">"|"]">}

// Now the actual parsing code, starting
// with the productions for FreeMarker's
// expression syntax.

/**
 * An Expression production with error recovery
 * The start Token is the token just before the expression
 * we are trying to parse, the recoverToType is 
 * the kind of token to scan ahead for to recover from 
 * errors, and the boolean consumeToken
 * says whether to consume the recoverToken or not.
 */

Expression Expression(Token start, int recoverToType, boolean consumeToken) :
{
   Expression exp = null;
   Token end;
}
{
   try {
	   exp=OrExpression()
   } catch (ParseException pe) {
   	   String msg = "invalid expression";
       Token t = this.token, prevToken;
       do {
  	  	   prevToken = t;
		   t = getNextToken();
 	   } while (t.kind != recoverToType && t.kind != EOF);
       if (!consumeToken) {
  	  	   this.token = prevToken;
  	   }
  	   exp = new InvalidExpression(msg);
  	   exp.setLocation(template, start.next, prevToken);
   }
   {
      return exp;
   }
}

Expression Exp() :
{
	Expression exp;
}
{
	 exp=OrExpression() {return exp;}
}

JAVACODE
Token KeepGoingUntil(int type) {
	Token t = null;
	do {
		t = getNextToken();
	} while (t.kind != type && t.kind != EOF);
	if (t.kind == type) {
		this.token = t;
	}
	return t;
}


/**
 * Lowest level expression, a literal, a variable,
 * or a possibly more complex expression bounded
 * by parentheses.
 */
Expression PrimaryExpression() :
{
   Expression exp;
}
{
   (
      exp=NumberLiteral()
      |
      exp=HashLiteral()
      |
      exp=StringLiteral()
      |
      exp=BooleanLiteral()
      |
      exp=NullLiteral()
      |
      exp=ListLiteral()
      |
      exp=Identifier()
      |
      exp=Parenthesis()
      |
      exp=BuiltinVariable()
  )
  (
      LOOKAHEAD(<DOT>
                |<OPEN_BRACKET>
                |<OPEN_PAREN>
                |<BUILT_IN>
                |<EXISTS>
                |<EXCLAM>)
      exp=AddSubExpression(exp)
  )*
  {
     return exp;
  }
}

Expression Parenthesis() :
{
   Expression exp, result;
   Token start, end;
}
{
    start=<OPEN_PAREN>
    exp=Expression(start, CLOSE_PAREN, false) 
    end=<CLOSE_PAREN>
    {
       result = new ParentheticalExpression(exp);
       result.setLocation(template, start, end);
       return result;
    }
}

/**
 * A primary expression preceded by zero or
 * more unary operators. 
 */
Expression UnaryExpression() :
{
   Expression result;
}
{
  (
   result=UnaryPlusMinusExpression()
   |
   result=NotExpression()
   |
   result=PrimaryExpression()
  )
  {
     return result;
  }
}

Expression NotExpression() : 
{
   Token t;
   Expression exp, result=null;
   List<Token> nots = new ArrayList<Token>();
}
{
   (
      t=<EXCLAM> {nots.add(t);}
   )+
   exp=PrimaryExpression() 
   {
      for (int i=0; i<nots.size(); i++) {
         result = new NotExpression(exp);
         Token tok = nots.get(nots.size() -i -1);
         result.setLocation(template, tok, exp);
         exp = result;
      }
      return result;
   }
}

Expression UnaryPlusMinusExpression() :
{
   Expression exp, result;
   boolean isMinus = false;
   Token t;
}
{
   (
      t=<PLUS>
      |
      t=<MINUS> {isMinus = true;}
   )
   exp=PrimaryExpression() 
   {
      result = new UnaryPlusMinusExpression(exp, isMinus);  
      result.setLocation(template, t, exp);
      return result;
   }
}

Expression AdditiveExpression() :
{
   Expression lhs, rhs, result;
   boolean plus;
}
{
   lhs=MultiplicativeExpression() {result = lhs;}
   (
      LOOKAHEAD(<PLUS>|<MINUS>)
      (
        (
         <PLUS> {plus = true;}
         |
         <MINUS> {plus = false;}
        )
      )
      rhs=MultiplicativeExpression()
      {
         if (plus) {
           // plus is treated separately, since it is also
           // used for concatenation.
             result = new AddConcatExpression(lhs, rhs);
         }
         else {
             result = new ArithmeticExpression(lhs,
                                            rhs,
                                            ArithmeticExpression.SUBSTRACTION);
         }
         result.setLocation(template, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
}

/**
 * A unary expression followed by zero or more
 * unary expressions with operators in between.
 */
Expression MultiplicativeExpression() :
{
   Expression lhs, rhs, result;
   int operation = ArithmeticExpression.MULTIPLICATION;
}
{
   lhs=UnaryExpression() {result = lhs;}
   (
      LOOKAHEAD(<TIMES>|<DIVIDE>|<PERCENT>)
      (
        (
         <TIMES> {operation = ArithmeticExpression.MULTIPLICATION;}
         |
         <DIVIDE> {operation = ArithmeticExpression.DIVISION;}
         |
         <PERCENT>{operation = ArithmeticExpression.MODULUS;}
        )
      )
      rhs=UnaryExpression()
      {
         result = new ArithmeticExpression(lhs, rhs, operation);
         result.setLocation(template, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
}


Expression EqualityExpression() :
{
   Expression lhs, rhs, result;
   Token t;
}
{
   lhs=RelationalExpression() {result = lhs;}
   [
     LOOKAHEAD(<NOT_EQUALS>|<EQUALS>|<DOUBLE_EQUALS>)
     (
      t=<NOT_EQUALS> 
      |
      t=<EQUALS> 
      |
      t=<DOUBLE_EQUALS>
     )
     rhs=RelationalExpression()
     {
        result = new ComparisonExpression(lhs, rhs, t.image);
        result.setLocation(template, lhs, rhs);
     }
   ]
   {
      return result;
   }
}

Expression RelationalExpression() :
{
   Expression lhs, rhs, result;
   Token t;
}
{
   lhs=RangeExpression() {result = lhs;}
   [
     LOOKAHEAD(<GREATER_THAN_EQUALS>|<ESCAPED_GTE>|<GREATER_THAN>|<ESCAPED_GT>|<LESS_THAN_EQUALS>|<LESS_THAN_EQUALS>|<LESS_THAN>)
     (
      t=<GREATER_THAN_EQUALS>
      |
      t=<ESCAPED_GTE>
      |
      t=<GREATER_THAN>
      |
      t=<ESCAPED_GT>
      |
      t=<LESS_THAN_EQUALS>
      |
      t=<LESS_THAN>
     )
     rhs=RangeExpression()
     {
        result = new ComparisonExpression(lhs, rhs, t.image);
        result.setLocation(template, lhs, rhs);
     }
   ]
   {
      return result;
   }
}

Expression RangeExpression() :
{
   Expression lhs, rhs=null, result;
}
{
    lhs=AdditiveExpression() {result = lhs;}
    [
      LOOKAHEAD(<DOT_DOT>)
      <DOT_DOT>
       [
        LOOKAHEAD(Expression())
        rhs=AdditiveExpression()
       ]
       {
           Range range = new Range(lhs, rhs);
           if (rhs != null) {
               range.setLocation(template, lhs, rhs);
           } else {
              range.setLocation(template, lhs, lhs);
           }
           result = range;
        }
    ]
    {
        return result;
    }
}




Expression AndExpression() :
{
   Expression lhs, rhs, result;
}
{
   lhs=EqualityExpression() {result = lhs;}
   (
      LOOKAHEAD(<AND>)
      <AND>
      rhs=EqualityExpression()
      {
         result = new AndExpression(lhs, rhs);
         result.setLocation(template, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
}

Expression OrExpression() :
{
   Expression lhs, rhs, result;
}
{
   lhs=AndExpression() {result = lhs;}
   (
     LOOKAHEAD(<OR>)
      <OR>
      rhs=AndExpression()
      {
         result = new OrExpression(lhs, rhs);
         result.setLocation(template, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
}

ListLiteral ListLiteral() :
{
   Expression exp;
   ArrayList<Expression> values = new ArrayList<Expression>();
   Token begin, end;
}
{
    begin=<OPEN_BRACKET>
    [
      exp=Exp() {values.add(exp);}
      (
         [<COMMA>]
         exp=Exp() {values.add(exp);}
      )*
    ]
    end=<CLOSE_BRACKET>
    {
        ListLiteral result = new ListLiteral(values);
        result.setLocation(template, begin, end);
        return result;
    }
}

Expression NumberLiteral() :
{
   Token op = null, t;
   Number number;
}
{
   (
      t=<INTEGER>
      |
      t=<DECIMAL>
   )
   {
       String s = t.image;
       Number n = template != null ? template.getArithmeticEngine().toNumber(s) : new java.math.BigDecimal(s);
       Expression result = new NumberLiteral(n);
       Token startToken = (op != null) ? op : t;
       result.setLocation(template, startToken, t);
       return result;
   }
}

Identifier Identifier() :
{
    Token t;
}
{
    t=<ID>
    {
        Identifier id = new Identifier(t.image);
        id.setLocation(template, t, t);
        return id;
    }
}

Expression IdentifierOrStringLiteral() :
{
   Expression exp;
}
{
   (
      exp=Identifier()
      |
      exp=StringLiteral()
   )
   {
      return exp;
   }   
}

BuiltinVariable BuiltinVariable() :
{
   Token dot, name;
}
{
   dot=<DOT>
   name=<ID>
   {
      BuiltinVariable result = null;
      try {
          result = new BuiltinVariable(name.image);
      } catch (ParseException pe) {
          pe.lineNumber = dot.beginLine;
          pe.columnNumber = dot.beginColumn;
          throw pe;
      }
      result.setLocation(template, dot, name);
      return result;
   }
}

/**
 * Production that builds up an expression
 * using the dot or dynamic key name
 * or the args list if this is a method invocation.
 */
Expression AddSubExpression(Expression exp) :
{
   Expression result = null;
}
{
     (
       result=DotVariable(exp)
       |
       result=DynamicKey(exp)
       |
       result=MethodArgs(exp)
       |
       result=BuiltIn(exp)
       |
       result=Exists(exp)
       |
       result=DefaultTo(exp)
     )
     {
        return result;
     }
}

Expression DefaultTo(Expression exp) :
{
   Expression rhs = null;
   Token t;
}
{
   
   (
       t=<EXCLAM>
       [
         LOOKAHEAD(PrimaryExpression(), {getToken(1).kind != ID || getToken(2).kind != EQUALS})
          rhs=PrimaryExpression()
       ]
   )
   {
      DefaultToExpression result = new DefaultToExpression(exp, rhs);
      if (rhs ==null) {
          result.setLocation(template, exp, t);
      }
      else {
          result.setLocation(template, exp, rhs);
      }
      return result;
   }
}

Expression Exists(Expression exp) :
{
   Token t;
}
{
   t=<EXISTS>
   {
       ExistsExpression result = new ExistsExpression(exp);
       result.setLocation(template, exp, t);
       return result;
   }
}



Expression BuiltIn(Expression exp) :
{
   Token t=null;
}
{
   <BUILT_IN>
   t=<ID>
   {
   	   BuiltInExpression result = new BuiltInExpression(exp, t.image);
   	   result.setLocation(template, exp, t);
   	   return result;
   }
}

/**
 * production for when a key is specified by <DOT> + keyname
 */
Expression DotVariable(Expression exp) :
{
  Token t;
}
{
     <DOT>{token_source.justAfterDot = true;}
     t=<ID>{token_source.justAfterDot = false;}
     {
         Dot dot = new Dot(exp, t.image);
         dot.setLocation(template, exp, t);
         return dot;
     }
}

/**
 * production for when the key is specified
 * in brackets.
 */
Expression DynamicKey(Expression exp) :
{
   Expression arg;
   Token t;
}
{
   <OPEN_BRACKET>
   arg=Exp()
   t=<CLOSE_BRACKET>
   {
       DynamicKeyName dkn = new DynamicKeyName(exp, arg);
       dkn.setLocation(template, exp, t);
       return dkn;
   }
}

/**
 * production for an arglist part of a method invocation.
 */
MethodCall MethodArgs(Expression exp) :
{
     ArgsList args = new PositionalArgsList();
     Token end;
}
{
     <OPEN_PAREN>
     [args=ArgsList()]
     end=<CLOSE_PAREN>
     {
        MethodCall result = new MethodCall(exp, args);
        result.setLocation(template, exp, end);
		args.setLocationInfoIfAbsent(result);        
        return result;
     }
}

Expression StringLiteral() :
{
  Token t;
  boolean raw = false;
}
{
   (
     t=<STRING_LITERAL>
     |
     t=<RAW_STRING> {raw = true;}
   )
   {
       String s = t.image;
       // Get rid of the quotes.
       s = s.substring(1, s.length() -1);
       if (raw) {
           s=s.substring(1);
       }
       else try {
          s = StringUtil.FTLStringLiteralDec(s);
       } catch (ParseException pe) {
       	  InvalidExpression invalid = new InvalidExpression("Malformed string literal: " + pe.getMessage());
       	  invalid.setLocation(template, t, t);
       	  return invalid;
       }
       StringLiteral result = new StringLiteral(s, raw);
       result.setLocation(template, t, t);
       return result;
   }
}

Expression BooleanLiteral() :
{
   Token t;
   Expression result;
}
{
   (
       t=<FALSE> {result = new BooleanLiteral(false);}
       |
       t=<TRUE> {result = new BooleanLiteral(true);}
   )
   {
       result.setLocation(template, t, t);
       return result;
   }
}

Expression NullLiteral() :
{
   Token t;
}
{
   t=<NULL>
   {
       Expression result = new NullLiteral();
       result.setLocation(template, t, t);
       return result;
   }
}


HashLiteral HashLiteral() :
{
   Token begin, end;
   Expression key, value;
   ArrayList<Expression> keys = new ArrayList<Expression>();
   ArrayList<Expression> values = new ArrayList<Expression>();
}
{
   begin=<OPEN_BRACE>
   [
       key=Exp()
       (<COMMA>|<COLON>)
       value=Exp()
       {
          keys.add(key);
          values.add(value);
       }
       (
          <COMMA>
           key=Exp()
           (<COMMA>|<COLON>)
           value=Exp()
           {
               keys.add(key);
               values.add(value);
           }
       )*
   ]
   end=<CLOSE_BRACE>
   {
      HashLiteral result = new HashLiteral(keys, values);
      result.setLocation(template, begin, end);
      return result;
   }
}

/**
 * A production representing the ${...}
 * that outputs a variable.
 */
TemplateElement StringOutput() :
{
   Expression exp;
   Token begin, end;
   boolean unclosed = false;
}
{
   begin=<OUTPUT_ESCAPE> 
   exp=Expression(begin, CLOSE_BRACE, false)
   try {
	   end=<CLOSE_BRACE>
   }
   catch (ParseException pe2) {
   	   end=recoverToToken(CLOSE_BRACE, true);
   	   exp=new InvalidExpression("The expression inside the interpolation is invalid.");
   	   exp.setLocation(template, begin.next, end);
   	   if (end.next.kind != EOF) {
	   	   end = end.next;
   	   } else {
   	   	   unclosed = true;
   	   }
   }
   {
   	  TemplateElement result;
   	  if (unclosed) {
   	  	  result = new UnclosedElement("Unclosed output interpolation, expecting a closing '}'");
   	  } else {
	      result = new Interpolation(exp);
   	  }
      result.setLocation(template, begin, end);
      return result;
   }
}

NumericalOutput NumericalOutput() :
{
   Expression exp;
   Token fmt = null, begin, end;
}
{
   begin=<NUMERICAL_ESCAPE>
   exp=Exp()
   [
      <SEMICOLON>
      fmt=<ID>
   ]
   end=<CLOSE_BRACE>
   {
   	  String formatString = fmt == null ? null : fmt.image;
      NumericalOutput result = new NumericalOutput(exp, formatString);
      result.setLocation(template, begin, end);
      return result;
   }
}

TemplateElement If() :
{
    Token start, end, t;
    Expression condition;
    TemplateElement block;
    IfBlock ifBlock;
    ConditionalBlock cblock;
}
{
   start=<IF>
   condition=Exp()
   <DIRECTIVE_END>
   block=OptionalBlock()
   {
      cblock = new ConditionalBlock(condition, block, true);
      cblock.setLocation(template, start, block);
      ifBlock = new IfBlock(cblock);
   }
   (
       t=<ELSE_IF>
       condition=Exp()
       LooseDirectiveEnd()
       block=OptionalBlock()
       {
          cblock = new ConditionalBlock(condition, block, false);
          cblock.setLocation(template, t, block);
          ifBlock.addBlock(cblock);
       }
   )*
   [
         t=<ELSE>
         block=OptionalBlock()
         {
            cblock = new ConditionalBlock(null, block, false);
            cblock.setLocation(template, t, block);
            ifBlock.addBlock(cblock);
         }
   ]
   end=CloseDirectiveBlock("if")
   {
       ifBlock.setLocation(template, start, end);
       return ifBlock;
   }
}

AttemptBlock Attempt() :
{
   Token start, end;
   TemplateElement block=null, recoveryBlock;
   ParseException problem = null;
}
{
   start=<ATTEMPT>
   block=OptionalBlock()
/*   
   try {
	   block=OptionalBlock()
   } catch (ParseException pe) {
   	   recoverToToken(RECOVER, false);
   	   problem = pe;
   } catch (TokenMgrError tme) {
   	   recoverToToken(RECOVER, false);
   	   problem = new ParseException(tme.getMessage());
   }*/
   recoveryBlock=Recover()
   end=CloseDirectiveBlock("attempt, recover")
   {
      AttemptBlock result = new AttemptBlock(block, recoveryBlock);
      result.setLocation(template, start, end);
      if (problem != null) {
      	ParsingProblem pp = new ParsingProblem(problem.getMessage(), result);
      	result.addParsingProblem(pp);
      }
      return result;
   }
}

RecoveryBlock Recover() : 
{
   Token start;
   TemplateElement block;
}
{
   start=<RECOVER>
   block=OptionalBlock()
   {
      RecoveryBlock result = new RecoveryBlock(block);
      result.setLocation(template, start, block);
      return result;
   }
}

TemplateElement List() :
{
    Expression exp;
    Token index, start, end, as=null, directiveEnd=null;
    TemplateElement block;
}
{
   start=<LIST> 
   exp=Expression(start, AS, false)
   <AS>
   index=<ID>
   <DIRECTIVE_END>
   block=OptionalBlock()
   end=CloseDirectiveBlock("list")
   {
     IteratorBlock result = new IteratorBlock(exp,
                                              index.image,
                                              block,
                                              false);
     result.setLocation(template, start, end);
     return result;
   }
}

IteratorBlock ForEach() :
{
     Expression exp;
     Token index, start, end;
     TemplateElement block;
}
{
   start=<FOREACH> 
   index=<ID>
   <IN>
   exp=Exp()
   <DIRECTIVE_END>
   block=OptionalBlock()
   end=CloseDirectiveBlock("foreach")
   {
     IteratorBlock result = new IteratorBlock(exp,
                                              index.image,
                                              block,
                                              true);
     result.setLocation(template, start, end);
     return result;
   }
}

VisitNode Visit() :
{
   Token start, end;
   Expression targetNode, namespaces=null;
}
{
   start=<VISIT>
   targetNode=Exp()
   [
       <USING>
       namespaces=Exp()
   ]
   end=LooseDirectiveEnd()
   {
       VisitNode result = new VisitNode(targetNode, namespaces);
       result.setLocation(template, start, end);
       return result;
   }
}

RecurseNode Recurse() :
{
   Token start, end = null;
   Expression node=null, namespaces=null;
}
{
   (
      start=<SIMPLE_RECURSE>
      |
      (
         start=<RECURSE>
         [
            node=Exp()
         ]
         [
            <USING>
            namespaces=Exp()
         ]
         end=LooseDirectiveEnd()
      )
   )
   {
       if (end == null) end = start;
       RecurseNode result = new RecurseNode(node, namespaces);
       result.setLocation(template, start, end);
       return result;
   }
}

FallbackInstruction FallBack() :
{
   Token tok;
}
{
   tok=<FALLBACK>
   {
      FallbackInstruction result = new FallbackInstruction();
      result.setLocation(template, tok, tok);
      return result;
   }
}

/**
 * Production used to break out of a loop or a switch block.
 */
BreakInstruction Break() :
{
   Token start;
}
{
    start=<BREAK>
    {
       BreakInstruction result = new BreakInstruction();
       result.setLocation(template, start, start);
       return result;
    }
}

/**
 * Production used to jump out of a macro.
 * The stop instruction terminates the rendering of the template.
 */
ReturnInstruction Return() :
{
   Token start, end=null;
   Expression exp = null;
}
{
   (
      start=<SIMPLE_RETURN>{end = start;}
      |
      start=<RETURN> exp=Exp() end=LooseDirectiveEnd()
   )
   {
      ReturnInstruction result = new ReturnInstruction(exp);
      result.setLocation(template, start, end);
      return result;
   }
}

StopInstruction Stop() :
{
   Token start = null;
   Expression exp = null;
}
{
    (
      start=<HALT>
      |
      start=<STOP> exp=Exp() LooseDirectiveEnd()
    )
    {
       StopInstruction result = new StopInstruction(exp);
       result.setLocation(template, start, start);
       return result;
    }
}

TemplateElement Nested() :
{
  Token t, end;
  PositionalArgsList args=null;
  BodyInstruction result = null;
}
{
   (
      (
         t=<SIMPLE_NESTED>
         {
            result = new BodyInstruction(null);
            result.setLocation(template, t, t);
         }
      )
      |
      (
          t=<NESTED>
          args=PositionalArgsList()
          end=LooseDirectiveEnd()
          {
             result = new BodyInstruction(args);
             result.setLocation(template, t, end);
          }
      )
   )
   {
       return result;
   }
}

TemplateElement Flush() :
{
  Token t;
}
{
   t=<FLUSH>
   {
       FlushInstruction result = new FlushInstruction();
       result.setLocation(template, t, t);
       return result;
   }
}

TemplateElement Trim() :
{
  Token t;
  TrimInstruction result=null;
}
{
   (
     t=<TRIM> {result = new TrimInstruction(true, true);}
     |
     t=<LTRIM> {result = new TrimInstruction(true, false);}
     |
     t=<RTRIM> {result = new TrimInstruction(false, true);}
     |
     t=<NOTRIM> {result = new TrimInstruction(false, false);}
   )
   {
       result.setLocation(template, t, t);
       return result;
   }
}

TemplateElement Assign() :
{
   Token start, end;
   int type;
   Token id=null;
   Expression nameExp, exp, nsExp=null;
   String varName;
   TemplateElement block;
   LinkedHashMap<String, Expression> assignments = new LinkedHashMap<String, Expression>();
   String assignmentType;
   AssignmentInstruction result;
}
{
    (
      start=<ASSIGN> {type = AssignmentInstruction.NAMESPACE; assignmentType="assign";}
      |
      start=<GLOBALASSIGN>{type = AssignmentInstruction.GLOBAL; assignmentType = "global";}
      |
      start=<LOCALASSIGN> {type = AssignmentInstruction.LOCAL; assignmentType = "local";}
      |
      start=<SET> {type = AssignmentInstruction.SET; assignmentType = "set";}
    )
    {result = new AssignmentInstruction(type);}
    nameExp=IdentifierOrStringLiteral()
    {
       varName = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
    }
    ((
       <EQUALS>
       exp=Exp() {assignments.put(varName, exp);}
       (
         LOOKAHEAD([<COMMA>](<ID>|<STRING_LITERAL>)<EQUALS>)
            [<COMMA>]
            nameExp=IdentifierOrStringLiteral()
            {
               varName = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
            }
            <EQUALS>
            exp=Exp()
            {
            	assignments.put(varName, exp);
            } 
       )*
       [
          id=<IN>
          nsExp=Exp() {if (type != AssignmentInstruction.SET && type != AssignmentInstruction.NAMESPACE) {
          	   ParsingProblem problem = new ParsingProblem("Can only assign to namespace with #set or #assign.", result);
          	   template.addParsingProblem(problem);
            } 
          }
       ]
       end=LooseDirectiveEnd()
       {
           result.setNamespaceExp(nsExp);
		   for (Map.Entry<String,Expression> entry : assignments.entrySet()) {
           	    result.addAssignment(entry.getKey(), entry.getValue());
           }
           result.setLocation(template, start, end);
           return result;
       }
    )
    |
    (
       [
          id=<IN>
          nsExp=Exp() {if (type != AssignmentInstruction.NAMESPACE && type != AssignmentInstruction.SET) throw new ParseException(getErrorStart(id) + "\nCannot assign to namespace here.", id.beginLine, id.beginColumn);}
       ]
       <DIRECTIVE_END>
       block=OptionalBlock()
       end=CloseDirectiveBlock(assignmentType)
       {
       	  String name = end.image.substring(3, end.image.length() -1);
       	  switch (type) {
       	   	   case AssignmentInstruction.LOCAL : if (name.length() >0 && !name.equals("local")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.beginLine, end.beginColumn); break;
       	   	   case AssignmentInstruction.NAMESPACE : if (name.length() >0 && !name.equals("assign")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.beginLine, end.beginColumn); break;
       	   	   case AssignmentInstruction.GLOBAL : if (name.length() >0 && !name.equals("global")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.beginLine, end.beginColumn); break;
       	   	   case AssignmentInstruction.SET : if (name.length() >0 && !name.equals("set")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.beginLine, end.beginColumn); break;
       	  }
          BlockAssignment ba = new BlockAssignment(block, varName, type, nsExp);
          ba.setLocation(template, start, end);
          return ba;
       }
    ))
}


Include Include() :
{
   Token att, start, end;
   Expression nameExp, exp, parseExp = null, encodingExp = null;
   boolean freshNamespace;
}
{
    (
        start=<INCLUDE> {freshNamespace = false;}
        |
        start=<EMBED> {freshNamespace=true;}
    )
    nameExp=Exp()
    [<SEMICOLON>]
    (
	  att=<ID>
	  <EQUALS>
	  exp=Exp()
	  {
	     String attString = att.image;
	     if (attString.equalsIgnoreCase("parse")) {
	        if (parseExp != null) {
	           String msg = getErrorStart(att)
	                 + "\nparse may not be specified more than once.";
	           throw new ParseException(msg, att.beginLine, att.beginColumn);
	        }
	        parseExp = exp;
	     }
	     else if (attString.equalsIgnoreCase("encoding")) {
	        if (encodingExp != null) {
	           String msg = getErrorStart(att)
	                 + "\nencoding may not be specified more than once.";
	           throw new ParseException(msg, att.beginLine, att.beginColumn);
	        }
	        encodingExp = exp;
	     }
	     else {
	         String msg = getErrorStart(att)
	               + "\nexpecting parse= or encoding= to be specified.";
	         throw new ParseException(msg, att.beginLine, att.beginColumn);
	     }
	  }
	)*
    end=LooseDirectiveEnd()
    {
       Include result = new Include(template, nameExp, freshNamespace, encodingExp, parseExp);
       result.setLocation(template, start, end);
       return result;
    }
}

LibraryLoad Import() :
{
   Token start, end, ns;
   Expression nameExp;
}
{
   start=<IMPORT>
   nameExp=Exp()
   <AS>
   ns=<ID>
   end=LooseDirectiveEnd()
   {
       LibraryLoad result = new LibraryLoad(template, nameExp, ns.image);
       result.setLocation(template, start, end);
       if (template != null) template.addImport(result);
       return result;
   }
}

ParameterList ParameterList() :
{
	Token arg=null, firstArg=null, ellipsis = null;
	Expression defValue = null;
	ParameterList result = new ParameterList();
	String catchAll = null;
	boolean isCatchAll = false, hasDefaults = false;
	Set<String> paramNames = new HashSet<String>();
}
{
    (
          arg=<ID> 
          {
          	if (firstArg == null) firstArg = arg;
          	defValue = null;
          	if (paramNames.contains(arg.image)) {
          		throw new ParseException(getErrorStart(arg) + "\nThe parameter " + arg.image + " cannot be repeated.");
          	}
          	paramNames.add(arg.image);
          }
          [
             ellipsis=<ELLIPSIS> { isCatchAll = true; }
          ]
          [
            <EQUALS>
          	defValue=Exp()
            {
		      hasDefaults = true;
            }
          ]
          [<COMMA>]
	  {
          if (catchAll != null) {
              throw new ParseException(getErrorStart(arg)
                + "\nThere may only be one \"catch-all\" parameter in a macro declaration, "
                + "and it must be the last parameter.", arg.beginLine, arg.endLine);
          }
          if (isCatchAll) {
              if (defValue != null) {
                  throw new ParseException(getErrorStart(arg)
                    + "\n\"Catch-all\" macro parameter may not have a default value.",
                    arg.beginLine, arg.endLine);
              }
              result.setCatchAll(arg.image);
          } 
          else if (defValue == null) {
             if (hasDefaults) {
                  throw new ParseException(getErrorStart(arg)
                    + "\nIn a macro declaration, parameters without a default value "
                    + "must all occur before the parameters with default values.",
                    arg.beginLine, arg.endLine);
             }
          	 result.addParam(arg.image);
          }
          else {
              result.addParam(arg.image, defValue);
          	  hasDefaults = true;
          }
	  }
    )*
	{
		if (ellipsis != null) {
			result.setLocation(template, firstArg, ellipsis);
		}
		else if (defValue != null) {
			result.setLocation(template, firstArg, defValue);
		}
		else if (firstArg != null) {
			result.setLocation(template, firstArg, arg);
		}
		return result;
	}
}

Macro Macro() :
{
   CodeSource codeSource = Template.NULL_CODE_SOURCE;
   if (template != null) codeSource = template.getCodeSource();
   Macro result = new Macro(codeSource);
   Token arg, start, end;
   Expression nameExp;
   String name;
   TemplateElement block;
   ParameterList params;
   String functionOrMacro;
}
{
    (
        start=<MACRO> {functionOrMacro = "macro";}
        |
        start=<FUNCTION> {result.setFunction(true); functionOrMacro = "function";}
    )
    nameExp=IdentifierOrStringLiteral()
    {
       name = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
       result.setName(name);
    }
    [<OPEN_PAREN>]
    params=ParameterList() {result.setParams(params);}
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    block=OptionalBlock()
    end=CloseDirectiveBlock(functionOrMacro)
    {
	   result.setName(name);
	   result.setNestedBlock(block);
       result.setLocation(template, start, end);
       return result;
    }
}


CompressedBlock Compress() :
{
   TemplateElement block;
   Token start, end;
}
{
    start=<COMPRESS>
    block=OptionalBlock()
    end=CloseDirectiveBlock("compress")
    {
       CompressedBlock cb = new CompressedBlock(block);
       cb.setLocation(template, start, end);
       return cb;
    }
}


PositionalArgsList PositionalArgsList() : 
{
	Expression firstArg=null, arg=null;
	PositionalArgsList result = new PositionalArgsList();
}
{
	firstArg=Exp() {result.addArg(firstArg); arg=firstArg;}
	(
	   [<COMMA>]
	   arg=Exp() {result.addArg(arg);}
	)*
	{
		if (firstArg != null)
		result.setLocation(template, firstArg, arg);
		return result;
	}
}

NamedArgsList NamedArgsList() :
{
	Token firstParam, id;
	Expression arg;
	NamedArgsList result = new NamedArgsList();
}
{
	firstParam=<ID>
	<EQUALS> 
	arg=Exp()  
	{
		result.addNamedArg(firstParam.image, arg);
	}
	(
	   [<COMMA>]
	   id=<ID>
	   <EQUALS>
	   arg=Exp()
	   {result.addNamedArg(id.image, arg);}
	)*
	{
		token_source.inInvocation = false;
		result.setLocation(template, firstParam, arg);
		return result;
	}
}

ArgsList ArgsList() :
{
	ArgsList result = null;
	Token id;
	Expression exp = null;
}
{
	(
	   LOOKAHEAD(<ID><EQUALS>)
       result=NamedArgsList()
       |
       result=PositionalArgsList()
    )
	{
		return result;
	}
}



TemplateElement UnifiedMacroTransform() :
{
   Token start=null, end, t;
   Map<String, Expression> namedArgs = null;
   ArrayList<Expression> positionalArgs = null;
   String directiveName = null;
   TemplateElement nestedBlock = null;
   Expression exp;
   UnifiedCall result = new UnifiedCall();
   ArgsList args = null;
   ParameterList bodyParameters = null;
}
{
    start=<UNIFIED_CALL>
    exp=Exp()
    {
        if (exp instanceof Identifier || (exp instanceof Dot && ((Dot) exp).onlyHasIdentifiers())) {
           directiveName = exp.getCanonicalForm();
	    }
	    result.setNameExp(exp);
    }
    [<TERMINATING_WHITESPACE>]
    [args=ArgsList() {result.setArgs(args);}]
    [
       <SEMICOLON>[<TERMINATING_WHITESPACE>]
       bodyParameters=ParameterList()
       {
           result.setBodyParameters(bodyParameters);
       }
    ]
    (
      end=<EMPTY_DIRECTIVE_END>
      |
      (
        <DIRECTIVE_END>
		nestedBlock=OptionalBlock()
		end=<UNIFIED_CALL_END>
		{
           String s=end.image.substring(2);;
           if (s.charAt(0) == '@') {
              s = s.substring(1);
           }
	       s = s.substring(0, s.length() -1).trim();
           if (s.length() >0 && !s.equals(directiveName)) {
           String msg = getErrorStart(end);
           if (directiveName == null) {
                throw new ParseException(msg + "\nExpecting </@>", end.beginLine, end.beginColumn);
	       }
	       else {
	           throw new ParseException(msg + "\nExpecting </@> or </@" + directiveName + ">", end.beginLine, end.beginColumn);
	       }
	    }
	    result.setNestedBlock(nestedBlock);
	  }
      )
    )
    {
       result.setLocation(template, start, end);
       return result;
    }
}

TemplateElement Call() :
{
   Token start, end;
   Identifier id;
   String macroName= null;
   UnifiedCall result = new UnifiedCall();
   ArgsList args = null;
}
{
    start=<CALL>
    id=Identifier() {result.setNameExp(id);}
    [
	    LOOKAHEAD(<OPEN_PAREN>)
	    <OPEN_PAREN>
	]
    args=ArgsList() {result.setArgs(args);}
    [<CLOSE_PAREN>]
    end=LooseDirectiveEnd()
    {
       result.setLocation(template, start, end);
       args.setLocationInfoIfAbsent(result);
       return result;
    }
}

Map<String, Expression> NamedArgs() :
{
    Map<String, Expression> result = new LinkedHashMap<String, Expression>();
    Token t;
    Expression exp;
}
{
  (
     t=<ID>
     <EQUALS>
     exp=Exp()
     {
        if (result.containsKey(t.image)) {
           throw new ParseException(getErrorStart(t)
              + "\nValue of named parameter '" + t.image
              + "' may only be specified once.", t.beginLine, t.endLine);
        }
        result.put(t.image, exp);
     }
  )+
  {
     return result;
  }
}

Comment TerseComment() :
{
	Token start, end, t;
	StringBuilder buf = new StringBuilder();
}
{
	start=<TERSE_COMMENT>
	(
	   t=<PRINTABLE_CHARS> {buf.append(t.image);}
	)*
	end=<TERSE_COMMENT_END>
	{
		Comment result = new Comment(buf.toString());
		result.setLocation(template, start, end);
		return result;
	}
}

Comment Comment() :
{
   Token start, end, t;
   StringBuilder buf = new StringBuilder();
}
{
    start=<COMMENT>
    (
       t=<PRINTABLE_CHARS> {buf.append(t.image);}
    )*
    end=<COMMENT_END>
    {
       Comment result = new Comment(buf.toString());
       result.setLocation(template, start, end);
       return result;
    }
}

NoParseBlock NoParse() :
{
   Token start, end, t;
   StringBuilder buf = new StringBuilder();
}
{
    start=<NOPARSE>
    (
       t=<PRINTABLE_CHARS> {buf.append(t.image);}
    )*
    end=<NOPARSE_END>
    {
    	int beginColumn = start.beginColumn;
    	int beginLine = start.beginLine;
    	char lastChar = 0;
    	for (char c : start.image.toCharArray()) {
    		switch (c) {
    			case '\n' : if (lastChar == '\r') break;
    			case '\r' : beginColumn = 1; beginLine++; break;   
    			default : ++beginColumn;
    		}
    		lastChar = c;
    	}
       	List<TextBlock> text = TextBlock.breakIntoBlocks(buf.toString(), template, beginColumn, beginLine);
        NoParseBlock result = new NoParseBlock(start.image, end.image, text);
        result.setLocation(template, start, end);
        return result;
    }
}


TransformBlock Transform() :
{
   Token start, end, argName;
   Expression exp, argExp;
   TemplateElement content = null;
   HashMap<String, Expression> args = null;
}
{
    start=<TRANSFORM>
    exp=Exp()
    [<SEMICOLON>]
    (
       argName=<ID>
       <EQUALS>
       argExp=Exp()
       {
           if (args == null) args = new HashMap<String, Expression>();
           args.put(argName.image, argExp);
       }
    )*
    (
       end=<EMPTY_DIRECTIVE_END>
       |
       (
          <DIRECTIVE_END>
          content=OptionalBlock()
          end=CloseDirectiveBlock("transform")
       )
    )
    {
       TransformBlock result = new TransformBlock(exp, args, content);
       result.setLocation(template, start, end);
       return result;
    }
}

SwitchBlock Switch() :
{
    SwitchBlock switchBlock;
    Case caseIns;
    Expression switchExp;
    Token start, end;
    boolean defaultFound = false;
}
{
   start=<SWITCH>
   switchExp=Exp()
   <DIRECTIVE_END>
   (<WHITESPACE>|Comment())*   
   {
      switchBlock = new SwitchBlock(switchExp);
   }
   (
     LOOKAHEAD(2)
     caseIns=Case()
     {
       if (caseIns.isDefault) {
	   if (defaultFound) {
                String msg = getErrorStart(start)
                            + "\nYou can only have one default case in a switch statement";
                throw new ParseException(msg, start.beginLine, start.beginColumn);
	   }
	   defaultFound = true;
	}
        switchBlock.addCase(caseIns);
     }
   )*
   end=CloseDirectiveBlock("switch")
   {
      switchBlock.setLocation(template, start, end);
      return switchBlock;
   }
}

Case Case() :
{
    Expression exp = null;
    TemplateElement block;
    boolean isDefault = false;
    Token start;
}
{
   (
      start=<CASE>exp=Exp()<DIRECTIVE_END>
      |
      start=<DEFAUL>{isDefault = true;}
   )
   block=OptionalBlock()
   {
       Case result = new Case(exp, block, isDefault);
       result.setLocation(template, start, block);
       return result;
   }
}

TrimBlock TrimBlock() :
{
	Token start, end;
	TemplateElement content;
	boolean left = false, right = false;
	String closeTag = null;
}
{
	(
	   start=<BLOCKTRIM> {closeTag = "trim"; left = right = true;}
	   |
	   start=<BLOCKTRIML> {closeTag = "ltrim"; left = true;}
	   |
	   start=<BLOCKTRIMR> {closeTag = "rtrim"; right = true;}
	   |
	   start=<BLOCKNOTRIM> {closeTag = "notrim";}
	) 
	{trimBlockNesting++;}
	content=OptionalBlock()
	end=CloseDirectiveBlock(closeTag)
	{
		TrimBlock result = new TrimBlock(content, left, right);
		result.setLocation(template, start, end);
		trimBlockNesting--;
		return result;
	}
}
	

EscapeBlock Escape() :
{
    Token variable, start, end;
    Expression escapeExpr;
    TemplateElement content;
}
{
    start=<ESCAPE>
    variable=<ID>
    <AS>
    escapeExpr=Exp()
    <DIRECTIVE_END>
    {
        EscapeBlock result = new EscapeBlock(variable.image, escapeExpr);
    }
    content=OptionalBlock()
    {
        result.setContent(content);
    }
    end=CloseDirectiveBlock("escape")
    {
       result.setLocation(template, start, end);
       return result;
    }
}

NoEscapeBlock NoEscape() :
{
    Token start, end;
    TemplateElement content;
}
{
    start=<NOESCAPE>
    content=OptionalBlock()
    end=CloseDirectiveBlock("noescape")
    {
       NoEscapeBlock result = new NoEscapeBlock(content);
       result.setLocation(template, start, end);
       return result;
    }
}


Token CloseDirectiveBlock(String expectedTags) :
{
	Token t;
}
{
    t=<CLOSE_DIRECTIVE_BLOCK>
	{
		String name = t.image;
		name = name.substring(3, name.length() -1);
		if (name.length()>0) {
			StringTokenizer st = new StringTokenizer(expectedTags, ", ");
			boolean found = false;
			while (st.hasMoreTokens()) {
				if (st.nextToken().equals(name.trim())) found = true;
			}
			if (!found) {
				throw new ParseException(getErrorStart(t) + " Expecting " + t.image.substring(0,3) + expectedTags + t.image.charAt(t.image.length() -1));
			}
		}
		return t;
	}
}


/**
 * Production to terminate potentially empty elements. Either a ">" or "/>"
 */

Token LooseDirectiveEnd() :
{
    Token t;
}
{
   (
      t=<DIRECTIVE_END>
      |
      t=<EMPTY_DIRECTIVE_END>
   )
   {
      return t;
   }
}

PropertySetting Setting() :
{
   Token start, end, key;
   Expression value;
}
{
   start=<SETTING>
   key=<ID>
   <EQUALS>
   value=Exp()
   end=LooseDirectiveEnd()
   {
      PropertySetting result = new PropertySetting(key.image, value);
      result.setLocation(template, start, end);
      return result;
   }
}

VarDirective Var() :
{
    Token start, end;
    Expression var, valueExp = null;
    VarDirective result = new VarDirective();
}
{
   start=<VAR>
   (
     var=IdentifierOrStringLiteral()
     [
       <EQUALS>
       valueExp=Exp()
     ]
   )
   {
      result.addVar(var, valueExp);
      valueExp = null;
   }
   (
      (
        [<COMMA>]
        var=IdentifierOrStringLiteral()
        [
           <EQUALS>
           valueExp=Exp()
        ]
      )
      {
         result.addVar(var, valueExp);
         valueExp = null;
      }
   )*
   end=LooseDirectiveEnd()
   {
      result.setLocation(template, start, end);
      return result;
   }
}

/**
 * A production for FreeMarker directives.
 */
TemplateElement FreemarkerDirective() :
{
   TemplateElement tp;
}
{
   (
     tp=If()
     |
     tp=List()
     |
     tp=ForEach()
     |
     tp=Assign()
     |
     tp=Include()
     |
     tp=Import()
     |
     tp=Macro()
     |
     tp=Compress()
     |
     tp=UnifiedMacroTransform()
     |
     tp=Call()
     |
     tp=TerseComment()
     |
     tp=Comment()
     |
     tp=NoParse()
     |
     tp=Transform()
     |
     tp=Switch()
     |
     tp=Setting()
     |
     tp=Var()
     |
     tp=Break()
     |
     tp=Return()
     |
     tp=Stop()
     |
     tp=Flush()
     |
     tp=Trim()
     |
     tp=Nested()
     |
     tp=Escape()
     |
     tp=NoEscape()
     |
     tp=TrimBlock()
     |
     tp=Visit()
     |
     tp=Recurse()
     |
     tp=FallBack()
     |
     tp=Attempt()
   )
   {
      return tp;
   }
}

/**
 * Production for a block of raw text
 * i.e. text that contains no
 * FreeMarker directives.
 */

List<TextBlock> PCData() :
{
    StringBuilder buf = new StringBuilder();
    Token t=null, start=null, prevToken = null;
    List<TextBlock> result = new ArrayList<TextBlock>();
}
{
    (
      LOOKAHEAD(<WHITESPACE>|<PRINTABLE_CHARS>) 
      (
         {prevToken = t;}         
         t=<PRINTABLE_CHARS> 
         |
         t=<WHITESPACE> 
      )
      {
         buf.append(t.image);
         if (start == null) start = t;
         if (prevToken != null) prevToken.next = null;
      }
    )+
    {
         if (stripText && contentNesting == 1) {
             result.add(TextBlock.EMPTY_BLOCK);
             return result;
         }
    	 if (trimBlockNesting>0) {
    		result = TextBlock.breakIntoBlocksLineByLine(buf.toString(), template, start.beginColumn, start.beginLine); 
    	 } else {
            result = TextBlock.breakIntoBlocks(buf.toString(), template, start.beginColumn, start.beginLine);
    	 }
         return result;
    }
}

/**
 * Production for dealing with unparsed content,
 * i.e. what is inside a comment or noparse tag.
 * It returns the ending token. The content
 * of the tag is put in buf.
 */

TemplateElement Content() :
{
    MixedContent nodes = new MixedContent();
    TemplateElement elem=null, begin=null;
    contentNesting++;
    List<TextBlock> text = null;
}
{
    (
      LOOKAHEAD(1) // Just tells javacc that we know what we're doing.
      (
         text=PCData() {elem = null;}
         |
         elem=StringOutput()
         |
         elem=NumericalOutput()
         |
         elem=FreemarkerDirective()
      )
      {
            if (begin == null) {
               begin = elem == null ? text.get(0) : elem;
            }
            if (elem == null) {
            	for (TextBlock tb : text) nodes.addElement(tb);
            } else {
            	nodes.addElement(elem);
            }
      }
    )+
    {
        contentNesting--;
        if (elem == null) elem = text.get(text.size() -1);
        nodes.setLocation(template, begin, elem);
	    return nodes;
    }
}

/**
 * A production freemarker text that may contain
 * ${...} and #{...} but no directives.
 */

TemplateElement FreeMarkerText() :
{
     MixedContent nodes = new MixedContent();
     TemplateElement elem = null, begin = null;
     List<TextBlock> text = null;
}
{
    (
      (
        text=PCData() {elem = null;}
        |
        elem=StringOutput()
        |
        elem=NumericalOutput()
      )
      {
         if (begin == null) {
            begin = (elem == null) ? text.get(0) : elem;
         }
         if (elem != null) {
         	nodes.addElement(elem);
         } else {
         	for (TextBlock tb : text) nodes.addElement(tb);
         }
      }
    )+
    {
       if (elem == null) elem = text.get(text.size() -1);
       nodes.setLocation(template, begin, elem);
       return nodes;
    }
}

/**
 * A production for a block of optional content.
 * Returns an empty Text block if there is no
 * content.
 */

TemplateElement OptionalBlock() :
{
   TemplateElement tp = TextBlock.EMPTY_BLOCK;
}
{
   [
      LOOKAHEAD(1) // has no effect but to get rid of a spurious warning.
         tp=Content()
   ]
   {
      return tp;
   }
}


TemplateHeaderElement HeaderElement() : 
{
	Token key, start, end;
	Expression exp;
	Map<String,Expression> params = new LinkedHashMap<String,Expression>();
}
{
   [<WHITESPACE>]
   (
     start=<TRIVIAL_FTL_HEADER> {end=start;}
     |
     (
       start=<FTL_HEADER>
       (
          key=<ID>
          <EQUALS>
          exp=Exp() {params.put(key.image.toLowerCase(), exp);}
       )*
       end=LooseDirectiveEnd()
     )
   )
   {
   	   TemplateHeaderElement header = new TemplateHeaderElement(params);
   	   header.setLocation(template, start, end);
   	   return header;
   }
}

Map<String,Expression> ParamList() :
{
   Identifier id;
   Expression exp;
   Map<String,Expression> result = new HashMap<String,Expression>();
}
{
   (
      id=Identifier()
      <EQUALS>
      exp=Exp() {result.put(id.toString(), exp);}
      [<COMMA>]
   )+
   {
       return result;
   }
}


/**
 * Root production to be used when parsing
 * an entire file.
 */
TemplateElement Root() :
{
   TemplateHeaderElement header;
   TemplateElement doc;
}
{
   [
      LOOKAHEAD([<WHITESPACE>](<TRIVIAL_FTL_HEADER>|<FTL_HEADER>))
       header=HeaderElement()
       {
       	   template.setHeaderElement(header);
       	   String templateEncoding = template.getEncoding();
       	   if (templateEncoding != null && header.hasParameter("encoding")) {
       	   	  String encoding = null;
       	   	  try {
       	   	     encoding = header.getStringParameter("encoding");
       	   	  } catch (Exception e) {}
       	   	  if (encoding != null && !encoding.equals(templateEncoding)) {
       	   	  	throw new Template.WrongEncodingException(encoding);
       	   	  }
       	   }
       	   if (header.hasParameter("strip_text")) {
       	   	  try {
       	   	  	 this.stripText = header.getBooleanParameter("strip_text");
       	   	  } catch (Exception e) {
       	   	  	throw new ParseException(e.getMessage());
       	   	  }
       	   }
       	   	
       }
   ]
   doc=OptionalBlock()
   <EOF>
   {
       doc.setParentRecursively(null);
       return doc;
   }
}
