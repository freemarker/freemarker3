FreeMarker 2.4 preview, Backward Compatibility Issues, Syntax Conversion
Utility:

This is the first preview release of FreeMarker 2.4. Since 2.4 is a full decimal
point move in version number, backward compatibility is not guaranteed and you should
test your templates to be sure they still work. That said, by and large, templates
written to run with FreeMarker 2.3 should work with FreeMarker 2.4. The cases in
which this does not hold will tend to be relatively rare corner cases. However,
some constructs from FreeMarker 2.3 are deprecated (though still working) in favor 
of newer constructs. In particular, #assign and #local (though they still work) are
superseded in FreeMarker 2.4 by #set and #var. 

The default syntax is now considered to be the square bracket syntax. Note,
however, that FreeMarker 2.4 autodetects which syntax you are using by simply
assuming that the syntax used in the first FreeMarker directive it encounters on
the page is what will be used.

A conversion utility exists to convert older FreeMarker templates to the newer
constructs. See the class freemarker.core.helpers.Canonicalize. You can run it
from the command line with no arguments to get a list of your options.

FreeMarker 2.4 does, however, does break compatibility with very ancient
versions of FreeMarker, prior to 2.1.x, since it no longer supports the older
syntax in which FreeMarker directives were not distinguished by the '#' symbol,
so that, for example, [#if foo==bar] was written <if foo==bar>.

Java Versions Supported:

As of the 2.4 release cycle, FreeMarker is developed against JDK 1.5 (or
higher.) We use the retrotranslator tool to provide a freemarker-1.4compat.jar
that has been tested to work with Java 1.4. This may work with even earlier java
versions but this is unsupported.

The new null keyword, potential incompatibility:

In FreeMarker 2.4, 'null' is a keyword and refers to the special singleton value
TemplateModel.JAVA_NULL on the Java side, which is used to wrap a null value
that comes from the Java layer. If, by some chance, you have a variable named 'null', 
you will have to rename it. Also, note that in previous versions of FreeMarker, you 
could pass a null into a java method that expected a null by using an undefined 
variable. This trick will no longer work. You now must use the null keyword in these
cases.

Unified Syntax for macros, functions, and methods, using the
freemarker.template.Parameters annotation: 

As of FreeMarker 2.4, macros, functions, and methods can be invoked using the
named parameter syntax. Thus, you could write:

${func(value1, value2)}

or:

${func(param1 = value1 param2 = value2)}

Note that, for this to work with methods defined on the Java side, you must use
the newly introduced freemarker.template.Parameters annotation. Thus, a java method, 
either bean-wrapped or directly implementing the freemarker.template.TemplateMethodModel 
API can specify parameter names as well as default values using the same syntax as in 
the template layer. 

For example, in the java source:

@freemarker.template.Parameters("title = 'Hello, World'")

public String myMethod(String title) {
  ...
}

could be invoked from the template layer with no parameter, and thus, the title
parameter would default to 'Hello, World' or it could be invoked with a named parameter
syntax if that is considered to provide greater clarity, i.e.

   ${foo.myMethod(title = "Foobar")}

New Tree-walking API for tools that walk the FreeMarker AST (Abstract Syntax Tree)

A new API has been introduced that can be used by tool writers to walk the FreeMarker 
AST using the visitor pattern. That is freemakrer.core.ast.ASTVisitor. For examples of 
usage, you can refer to where it is used internally, for example, in 
freemarker.template.PostParseVisitor and freemarker.template.WhitespaceAdjuster. Also,
the syntax updating tool mentioned above is an implementation of the ASTVisitor API.
See freemarker.core.helpers.DefaultTreeDumper and 
freemarker.core.helpers.CanonicalizingTreeDumper.

 