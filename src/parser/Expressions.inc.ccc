// This file defines the expression
// grammar. It is INCLUDEd from the main template.

#Expression#abstract :
{
	Expression exp;
}
	 exp=OrExpression {return exp;}
;

INJECT Expression :
   import freemarker.template.*;
   import freemarker.ext.beans.ObjectWrapper;
   import freemarker.core.Environment;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.core.ast.NonBooleanException;
   import freemarker.core.ast.NonStringException;
   import static freemarker.ext.beans.ObjectWrapper.*;
   extends TemplateNode
{
    public abstract Object evaluate(Environment env);
    
    
    public String getDescription() {
    	return "the expression: "  + this;
    }

    public String getStringValue(Environment env) {
        return getStringValue(evaluate(env), this, env);
    }
    
    static public boolean isDisplayableAsString(Object tm) {
    	return ObjectWrapper.isString(tm)
    	     || ObjectWrapper.isNumber(tm)
    	     || tm instanceof TemplateDateModel;
    }
    
    public static String getStringValue(Object referent, Expression exp, Environment env)
    {
        if (isNumber(referent)) {
            return env.formatNumber(asNumber(referent));
        }
        if (referent instanceof TemplateDateModel) {
            TemplateDateModel dm = (TemplateDateModel) referent;
            return env.formatDate(EvaluationUtil.getDate(dm, exp, env), dm.getDateType());
        }
        if (isString(referent)) {
            return asString(referent);
        }
        assertNonNull(referent, exp, env);
        String msg = "Error " + exp.getStartLocation()
                     +"\nExpecting a string, " 
                     + "date or number here, Expression " + exp 
                     + " is instead a " 
                     + referent.getClass().getName();
        throw new NonStringException(msg, env);
    }

    public Expression deepClone(String name, Expression subst) {
        Expression clone = _deepClone(name, subst);
        clone.copyLocationFrom(this);
        clone.setParent(this.getParent());
        return clone;
    }

    public abstract Expression _deepClone(String name, Expression subst);

    public boolean isTrue(Environment env) {
        Object referent = evaluate(env);
        if (isBoolean(referent)) {
            return asBoolean(referent);
        }
        assertNonNull(referent, this, env);
        String msg = "Error " + getStartLocation()
                     + "\nExpecting a boolean (true/false) expression here"
                     + "\nExpression " + this + " does not evaluate to true/false "
                     + "\nit is an instance of " + referent.getClass().getName();
        throw new NonBooleanException(msg, env);
    }
}

/**
 * Lowest level expression, a literal, a variable,
 * or a possibly more complex expression bounded
 * by parentheses.
 */
PrimaryExpression :
   (
      NumberLiteral
      |
      HashLiteral
      |
      StringLiteral
      |
      BooleanLiteral
      |
      NullLiteral
      |
      ListLiteral
      |
      Identifier
      |
      ParentheticalExpression
      |
      BuiltinVariable
  )
  (
      (
        <DOT>
        {token_source.justAfterDot = true;} 
        <ID> 
        {token_source.justAfterDot=false;}
      ) #DotVariable(+1) 
      |
      (<OPEN_BRACKET> Expression <CLOSE_BRACKET>) #DynamicKeyName(+1)
      |
      (<OPEN_PAREN> [ArgsList] <CLOSE_PAREN>) #MethodCall(+1)
      |
      (<BUILT_IN><ID>) #BuiltInExpression(+1)
      |
      <EXISTS>#ExistsExpression(2) 
      |
      (
        <EXCLAM>
        [
            SCAN {getToken(1).getType() != TokenType.ID || getToken(2).getType() != TokenType.EQUALS}
            => PrimaryExpression =>||
        ]
      ) #DefaultToExpression(+1)
  )*
;

ParentheticalExpression# :
    <OPEN_PAREN> 
    Expression 
    <CLOSE_PAREN>
;

INJECT ParentheticalExpression :
   import freemarker.core.Environment;
   import freemarker.core.parser.ast.Expression;
   extends Expression
{
   public Expression getNested() {
        return firstChildOfType(Expression.class);
    }

    public boolean isTrue(Environment env) {
        return getNested().isTrue(env);
    }
    
    public Object evaluate(Environment env) {
        return getNested().evaluate(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        ParentheticalExpression result = new ParentheticalExpression();
        result.add(get(0));
        result.add(getNested().deepClone(name, subst));
        result.add(get(2));
        return result;
    }   
}

/**
 * A primary expression preceded (optionally)
 * by a unary operator
 */
UnaryExpression :
   UnaryPlusMinusExpression
   |
   NotExpression 
   |
   PrimaryExpression 
;

NotExpression# :
   <EXCLAM>
   (
      PrimaryExpression 
      |
      NotExpression 
   )
;

INJECT NotExpression :
    import freemarker.core.Environment;
    import freemarker.core.parser.ast.Expression;
    import freemarker.core.ast.BooleanExpression;
    extends BooleanExpression
{
    public Expression getTarget() {
        return (Expression) get(1);
    }

    public boolean isTrue(Environment env) {
        return (!getTarget().isTrue(env));
    }

    public Expression _deepClone(String name, Expression subst) {
        NotExpression result = new NotExpression();
    	result.add(getTarget().deepClone(name, subst));
        return result;
    }
}

UnaryPlusMinusExpression# :
   (
      <PLUS>
      |
      <MINUS>
   )
   (
      UnaryPlusMinusExpression
      |
      PrimaryExpression
   )
;

INJECT UnaryPlusMinusExpression : 
    import freemarker.core.Environment;
    import freemarker.core.parser.ast.Expression;
    import freemarker.core.ast.ArithmeticEngine;
    import freemarker.core.ast.NonNumericalException;
    import freemarker.template.*;
    import static freemarker.ext.beans.ObjectWrapper.asNumber;
    extends Expression
{
    private static final Integer MINUS_ONE = Integer.valueOf(-1); 

    public Expression getTarget() {
    	return firstChildOfType(Expression.class);
    }
    
    public boolean isMinus() {
    	return get(0).getType()==MINUS;
    }
    
    public Object evaluate(Environment env) {
        Number value = null;
        try {
            value = asNumber(getTarget().evaluate(env));
        } catch (ClassCastException cce) {
            String msg = "Error " + getStartLocation();
            msg += "\nExpression " + getTarget() + " is not numerical.";
            throw new NonNumericalException(msg, env);
        }
        if (!isMinus()) {
            return value;
        }
        return ArithmeticEngine.CONSERVATIVE_ENGINE.multiply(MINUS_ONE, value);
    }

    public Expression _deepClone(String name, Expression subst) {
        UnaryPlusMinusExpression result = new UnaryPlusMinusExpression();
        result.add(get(0));
        result.add(getTarget().deepClone(name,subst));
        return result;
    }
}

AdditiveExpression#(>1) :
   MultiplicativeExpression 
   [
      (
         <PLUS> 
         |
         <MINUS>
      )
      AdditiveExpression
   ]
;

INJECT AdditiveExpression : //THIS NEEDS TO BE SIMPLIFIED!
   import java.util.*;
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.ast.ArithmeticEngine;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.core.parser.ast.Expression;
   import static freemarker.ext.beans.ObjectWrapper.isNumber;   
   import static freemarker.ext.beans.ObjectWrapper.isList;   
   import static freemarker.ext.beans.ObjectWrapper.asString;   
   extends Expression
{
    public boolean isPlus() {
        return get(1).getType() == PLUS;
    }

    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        Object left = getLeft().evaluate(env);
        Object right = getRight().evaluate(env);
        ArithmeticEngine ae = 
            env != null 
                ? env.getArithmeticEngine()
                : getTemplate().getArithmeticEngine();        
        if (!isPlus()) {
            Number first = EvaluationUtil.getNumber(left, getLeft(), env);
            Number second = EvaluationUtil.getNumber(right, getRight(), env);
            return ae.subtract(first, second);
        }
        boolean bothAreNumbers = isNumber(left) && isNumber(right);
        if (bothAreNumbers) {
            Number first = EvaluationUtil.getNumber(left, getLeft(), env);
            Number second = EvaluationUtil.getNumber(right, getRight(), env);
            return ae.add(first, second);
        }
        if (isList(left) && isList(right)) {
            /*List merged = new ArrayList(asList(leftModel));
            merged.addAll(asList(rightModel));
            return merged;*/
            return new ConcatenatedSequence((TemplateSequenceModel)left, (TemplateSequenceModel)right);            
        }
        if (isDisplayableAsString(left) && isDisplayableAsString(right)) {
            String s1 = getStringValue(left, getLeft(), env);
            if(s1 == null) s1 = "null";
            String s2 = getStringValue(right, getRight(), env);
            if(s2 == null) s2 = "null";
            return s1.concat(s2);
        }
        if (left instanceof TemplateHashModel && right instanceof TemplateHashModel) {
            if (left instanceof TemplateHashModelEx && right instanceof TemplateHashModelEx) {
                TemplateHashModelEx leftModelEx = (TemplateHashModelEx)left;
                TemplateHashModelEx rightModelEx = (TemplateHashModelEx)right;
                if (leftModelEx.size() == 0) {
                    return rightModelEx;
                } else if (rightModelEx.size() == 0) {
                    return leftModelEx;
                } else {
                    return new ConcatenatedHashEx(leftModelEx, rightModelEx);
                }
            } else {
                return new ConcatenatedHash((TemplateHashModel)left,
                                            (TemplateHashModel)right);
            }
        }
        String msg = this.getStartLocation() + ": Cannot add or concatenate";
        throw new TemplateException(msg, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        AdditiveExpression result = new AdditiveExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    	//return new AddConcatExpression(getLeft().deepClone(name, subst), getRight().deepClone(name, subst));
    }

    private static final class ConcatenatedSequence implements TemplateSequenceModel
    {
        private final TemplateSequenceModel left;
        private final TemplateSequenceModel right;

        ConcatenatedSequence(TemplateSequenceModel left, TemplateSequenceModel right)
        {
            this.left = left;
            this.right = right;
        }

        public int size() {
            return left.size() + right.size();
        }

        public Object get(int i) {
            int ls = left.size();
            return i < ls ? left.get(i) : right.get(i - ls);
        }
    }

    private static class ConcatenatedHash implements TemplateHashModel {
        final TemplateHashModel left;
        final TemplateHashModel right;

        ConcatenatedHash(TemplateHashModel left, TemplateHashModel right)
        {
            this.left = left;
            this.right = right;
        }
        
        public Object get(String key)
        {
            Object model = right.get(key);
            return (model != null) ? model : left.get(key);
        }

        public boolean isEmpty()
        {
            return left.isEmpty() && right.isEmpty();
        }
    }

    private static final class ConcatenatedHashEx extends ConcatenatedHash implements TemplateHashModelEx
    {
        private Iterable<String> keys;
        private Iterable<Object> values;
        private int size;

        ConcatenatedHashEx(TemplateHashModelEx left, TemplateHashModelEx right)
        {
            super(left, right);
        }
        
        public int size() throws TemplateModelException
        {
            initKeys();
            return size;
        }

        public Iterable keys()
        {
            initKeys();
            return keys;
        }

        public Iterable values()
        {
            initValues();
            return values;
        }

        private void initKeys()
        {
            if (keys == null) {
                HashSet<String> keySet = new HashSet<String>();
                List<String> keySeq = new ArrayList<>();
                addKeys(keySet, keySeq, (TemplateHashModelEx)this.left);
                addKeys(keySet, keySeq, (TemplateHashModelEx)this.right);
                size = keySet.size();
                keys = keySeq;
            }
        }

        private static void addKeys(Set<String> set, List<String> keySeq, TemplateHashModelEx hash)
        throws TemplateModelException
        {
            Iterator<?> it = hash.keys().iterator();
            while (it.hasNext()) {
                String s = asString(it.next());
                if (set.add(s)) {
                    // The first occurence of the key decides the index;
                    // this is consisten with stuff like java.util.LinkedHashSet.
                    keySeq.add(s);
                }
            }
        }        

        private void initValues() {
            if (values == null) {
                List<Object> seq = new ArrayList<>();
                for (String key : keys) {
                    seq.add(get(key));
                }
                values = seq;
            }
        }
    }
}

MultiplicativeExpression#(>1) :
   UnaryExpression 
   [
      (
         <TIMES>
         |
         <DIVIDE>
         |
         <PERCENT>
      )
      MultiplicativeExpression
   ]
;

INJECT MultiplicativeExpression :
   import freemarker.template.TemplateException;
   import freemarker.core.Environment;
   import freemarker.core.ast.ArithmeticEngine;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.core.parser.ast.Expression;
   import freemarker.core.ast.NonNumericalException;
   import static freemarker.ext.beans.ObjectWrapper.isNumber;
   extends freemarker.core.parser.ast.Expression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }
    
    public TokenType getOperation() {
        return (TokenType) get(1).getType();
    }

    public Object evaluate(Environment env) throws TemplateException 
    {
        Object leftModel = getLeft().evaluate(env);
        Object rightModel = getRight().evaluate(env);
        boolean leftIsNumber = isNumber(leftModel);
        boolean rightIsNumber = isNumber(rightModel);
        boolean bothNumbers = leftIsNumber && rightIsNumber;
        if (!bothNumbers) {
            String msg = "Error " + getStartLocation();
            if (!leftIsNumber) {
                msg += "\nExpression " + getLeft() + " is not numerical";
            }
            if (!rightIsNumber) {
                msg += "\nExpression " + getRight() + " is not numerical";
            }
            throw new NonNumericalException(msg, env);
        }
        Number first = EvaluationUtil.getNumber(leftModel, getLeft(), env);
        Number second = EvaluationUtil.getNumber(rightModel, getRight(), env);
        ArithmeticEngine ae = 
            env != null 
                ? env.getArithmeticEngine()
                : getTemplate().getArithmeticEngine();
        switch (getOperation()) {
            case TIMES :
                return ae.multiply(first, second);
            case DIVIDE :
                return ae.divide(first, second);
            case PERCENT :
                return ae.modulus(first, second);
            default:
                throw new TemplateException("unknown operation : " + getOperation(), env);
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        MultiplicativeExpression result = new MultiplicativeExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

Expression EqualityExpression#ComparisonExpression(>1) :
   RelationalExpression
   [
     (
      <NOT_EQUALS> 
      |
      <EQUALS> 
      |
      <DOUBLE_EQUALS>
     )
     RelationalExpression
   ]
   {
      return nodeArity() > 1 ? CURRENT_NODE : (Expression) peekNode();
   }
;

RelationalExpression#ComparisonExpression(>1) :
   RangeExpression 
   [
     (
      <GREATER_THAN_EQUALS>
      |
      <ESCAPED_GTE>
      |
      <GREATER_THAN>
      |
      <ESCAPED_GT>
      |
      <LESS_THAN_EQUALS>
      |
      <LESS_THAN>
     )
     RangeExpression
   ]
;

INJECT ComparisonExpression :
   import java.text.Collator;
   import java.util.Date;
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.ast.ArithmeticEngine;
   import freemarker.core.ast.BooleanExpression;
   import freemarker.core.parser.ast.Expression;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.ext.beans.Pojo;
   import static freemarker.ext.beans.ObjectWrapper.asBoolean;
   import static freemarker.ext.beans.ObjectWrapper.isBoolean;
   import static freemarker.ext.beans.ObjectWrapper.asNumber;
   import static freemarker.ext.beans.ObjectWrapper.isNumber;
   import static freemarker.ext.beans.ObjectWrapper.asString;
   import static freemarker.ext.beans.ObjectWrapper.isString;
   extends BooleanExpression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }

    public TokenType getOperation() {
        return (TokenType) get(1).getType();
    }
    
    /*
     * WARNING! This algorithm is duplicated in SequenceBuiltins.modelsEqual.
     * Thus, if you update this method, then you have to update that too!
     */
    public boolean isTrue(Environment env) {
        TokenType operation = getOperation();
        Object ltm = getLeft().evaluate(env);
        Object rtm = getRight().evaluate(env);
        assertNonNull(ltm, getLeft(), env);
       	assertNonNull(rtm, getRight(), env);
        int comp = 0;
        if (isNumber(ltm) && isNumber(rtm)) { 
            Number first = asNumber(ltm);
            Number second = asNumber(rtm);
            ArithmeticEngine ae = 
                env != null 
                    ? env.getArithmeticEngine()
                    : getTemplate().getArithmeticEngine();
            comp = ae.compareNumbers(first, second);
        }
        else if(ltm instanceof TemplateDateModel && rtm instanceof TemplateDateModel) {
            TemplateDateModel ltdm = (TemplateDateModel)ltm;
            TemplateDateModel rtdm = (TemplateDateModel)rtm;
            int ltype = ltdm.getDateType();
            int rtype = rtdm.getDateType();
            if(ltype != rtype) {
                throw new TemplateException(
                    "Can not compare dates of different type. Left date is of "
                    + TemplateDateModel.TYPE_NAMES.get(ltype)
                    + " type, right date is of " 
                    + TemplateDateModel.TYPE_NAMES.get(rtype) + " type.", 
                    env);
            }
            if(ltype == TemplateDateModel.UNKNOWN) {
                throw new TemplateException(
                    "Left date is of UNKNOWN type, and can not be compared.", env);
            }
            if(rtype == TemplateDateModel.UNKNOWN) {
                throw new TemplateException(
                    "Right date is of UNKNOWN type, and can not be compared.", env);
            }
            
            Date first = EvaluationUtil.getDate(ltdm, getLeft(), env);
            Date second = EvaluationUtil.getDate(rtdm, getRight(), env);
            comp = first.compareTo(second);
        }
        else if (isString(ltm) && isString(rtm)) {
            if(operation != EQUALS && operation != DOUBLE_EQUALS && operation != NOT_EQUALS) {
                throw new TemplateException("Can not use operator " + operation + " on string values.", env);
            }
            String first = asString(ltm);
            String second = asString(rtm);
            Collator collator;
            if(env == null) {
                collator = Collator.getInstance(getTemplate().getLocale());
            } else {
                collator = env.getCollator();
            }
            comp = collator.compare(first, second);
        }
        else if(isBoolean(ltm) && isBoolean(rtm)) {
            if(operation != EQUALS && operation != NOT_EQUALS) {
                throw new TemplateException("Can not use operator " + operation + " on boolean values.", env);
            }
            boolean first = asBoolean(ltm);
            boolean second = asBoolean(rtm);
            comp = (first ? 1 : 0) - (second ? 1 : 0);
        }
        else if (ltm instanceof Pojo && rtm instanceof Pojo) {
            Object left = ((Pojo)ltm).getWrappedObject();
            Object right = ((Pojo)rtm).getWrappedObject();
            if (operation == EQUALS) {
                return left.equals(right);
            }
            if (operation == NOT_EQUALS) {
                return !left.equals(right);
            }
            throw new UnsupportedOperationException();
        }
        else {
            throw new TemplateException(
                  "The only legal comparisons are between two numbers, two strings, or two dates.\n"
                + "Left  hand operand is a " + ltm.getClass().getName() + "\n"
                + "Right hand operand is a " + rtm.getClass().getName() + "\n"
                , env);
        }
        switch (getOperation()) {
            case EQUALS:
            case DOUBLE_EQUALS :
                return comp == 0;
            case NOT_EQUALS:
                return comp != 0;
            case LESS_THAN : 
                return comp < 0;
            case GREATER_THAN : 
            case ESCAPED_GT :
                return comp > 0;
            case LESS_THAN_EQUALS :
                return comp <= 0;
            case GREATER_THAN_EQUALS :
            case ESCAPED_GTE :
                return comp >= 0;
            default :
                throw new TemplateException("unknown operation", env);
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        ComparisonExpression result = new ComparisonExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }    
}

Expression RangeExpression#(>1) :
   AdditiveExpression
   [
    <DOT_DOT>
    [
       AdditiveExpression
    ]
   ]
   {
      if (nodeArity() == 1) return (Expression) peekNode();;
      return CURRENT_NODE;
   }
;

INJECT RangeExpression :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.core.parser.ast.Expression;
   import freemarker.core.ast.NonBooleanException;
   import freemarker.core.ast.NumericalRange;
   extends Expression
{
    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return hasRhs() ? (Expression) get(2) : null;
    }

    public boolean hasRhs() {
        return size()==3;
    }
    
    public Object evaluate(Environment env) 
        throws TemplateException
    {
        int min = EvaluationUtil.getNumber(getLeft(), env).intValue();
        int max = 0;
        if (hasRhs()) {
            max = EvaluationUtil.getNumber(getRight(), env).intValue();
            return new NumericalRange(min, max);
        }
        return new NumericalRange(min);
    }
    
    public boolean isTrue(Environment env) {
        String msg = "Error " + getStartLocation() + ". " 
                    + "\nExpecting a boolean here."
                    + " Expression " + this + " is a range.";
        throw new NonBooleanException(msg, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        RangeExpression result = new RangeExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        if (hasRhs()) result.add(getRight().deepClone(name, subst));
        return result;
    }
}

Expression AndExpression#(>1) :
{
   Expression lhs;
}
   lhs=EqualityExpression
   [
      <AND>
      AndExpression
   ]
   {
      return nodeArity() > 1 ? CURRENT_NODE : lhs;
   }
;

INJECT AndExpression :
    import freemarker.core.Environment;
    import freemarker.core.parser.ast.Expression;
    extends freemarker.core.ast.BooleanExpression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }

    public boolean isTrue(Environment env) {
        return getLeft().isTrue(env) && getRight().isTrue(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        AndExpression result = new AndExpression();
        result.add(getLeft().deepClone(name,subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

Expression OrExpression#(>1) :
{
   Expression lhs;
}
   lhs=AndExpression
   [
      <OR>
      OrExpression
   ]
   {
      return nodeArity() > 1 ? CURRENT_NODE : lhs;
   }
;

INJECT OrExpression :
    import freemarker.core.Environment;
    import freemarker.core.parser.ast.Expression;
    extends freemarker.core.ast.BooleanExpression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }

    public boolean isTrue(Environment env) {
        return getLeft().isTrue(env) || getRight().isTrue(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        OrExpression result = new OrExpression();
        result.add(getLeft().deepClone(name,subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

#ListLiteral# :
    <OPEN_BRACKET>
    [
      Expression 
      (
         <COMMA>
         Expression 
      )*
    ]
    <CLOSE_BRACKET>
    {
        return CURRENT_NODE;
    }
;

INJECT ListLiteral :
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  import freemarker.core.Environment;
  import freemarker.core.TemplateNamespace;
  import freemarker.ext.beans.ListModel;
  import freemarker.template.TemplateException;
  import freemarker.template.*;
  import freemarker.core.parser.ast.Expression;
  extends Expression
{
    public List<Expression> getElements() {
        return childrenOfType(Expression.class);
    }
    
    public Object evaluate(Environment env) {
        ListModel list = new ListModel();
        for (Expression exp: getElements()) {
            Object tm = exp.evaluate(env);
            assertIsDefined(tm, exp, env);
            list.add(tm);
        }
        return list;
    }

    // A hacky routine used by VisitNode and RecurseNode
    
    public TemplateSequenceModel evaluateStringsToNamespaces(Environment env) {
        ListModel result = new ListModel();
        for (Expression exp : getElements()) {
            if (exp instanceof StringLiteral) {
                String s = ((StringLiteral) exp).getAsString();
                try {
                    TemplateNamespace ns = env.importLib(s, null);
                    result.add(ns);
                } 
                catch (IOException ioe) {
                    throw new TemplateException("Could not import library '" + s + "', " + ioe.getMessage(), env); 
                }
            }
            else {
                result.add(exp);
            }
        }
        return result;
    }
    
    public Expression _deepClone(String name, Expression subst) {
        ListLiteral result = new ListLiteral();
        for (Node node : this) {
            if (node instanceof Expression) {
                node = ((Expression) node).deepClone(name, subst);
            }
            result.add(node);
        }
        return result;
    }
}

NumberLiteral# :
   (
      <INTEGER>
      |
      <DECIMAL>
   )
   {
       String s = lastConsumedToken.toString();
       Number n = template != null ? template.getArithmeticEngine().toNumber(s) : new java.math.BigDecimal(s);
       CURRENT_NODE.setValue(n);
   }
;

INJECT NumberLiteral :
  import freemarker.core.Environment;
  import freemarker.core.parser.ast.Expression;
  import freemarker.ext.beans.NumberModel;
  extends Expression
{
    @Property Number value;

    public NumberLiteral() {}

    public NumberLiteral(Number value) {
        this.value = value;
    }
    
    public Object evaluate(Environment env) {
        //return new NumberModel(value);
        return value;
    }
    
    public String getStringValue(Environment env) {
        return env.formatNumber(value);
    }

    public Number getAsNumber() {
        return value;
    }
    
    String getName() {
        return "the number: '" + value + "'";
    }

    public Expression _deepClone(String name, Expression subst) {
        return new NumberLiteral(value);
    }
}

Identifier# :
   <ID> 
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   } 
;

INJECT Identifier :
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.parser.ast.Expression;
    extends Expression
{
    @Property String name;

    public Identifier() {}

    public Identifier(String name) {
        this.name = name;
    }
    
    public Object evaluate(Environment env) {
        try {
            return env.getVariable(name);
        } catch (NullPointerException e) {
            if (env == null) {
                throw new TemplateException("Variables are not available "
                + "(certainly you are in a parse-time executed directive). The name of the variable "
                + "you tried to read: " + name, null);
            } else {
                throw e;
            }
        }
    }

    public String toString() {
        return name;
    }

    public Expression _deepClone(String name, Expression subst) {
        if(this.name.equals(name)) {
        	return subst.deepClone(null, null);
        }
        return new Identifier(this.name);
    }
}

Expression IdentifierOrStringLiteral :
{
   Expression exp;
}
   (
      exp=Identifier
      |
      exp=StringLiteral
   )
   {
      return exp;
   }   
;

BuiltinVariable# :
   <DOT>
   <ID>
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   }
;

INJECT BuiltinVariable :
    import freemarker.template.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ParseException;
    import freemarker.core.parser.ast.Expression;
    import freemarker.core.ast.Macro;
    extends Expression
{
    private String name;

    public void setName(String name) {
      this.name = name.intern();
    }
    
    public String getName() {
        return name;
    }

    public Object evaluate(Environment env) {
        switch (name) {
           case "namespace" : return env.getCurrentNamespace();
           case "main" : return env.getMainNamespace();
           case "globals" : return env;
           case "locals" : return env.getCurrentMacroContext();
           case "data_model" : return env.getDataModel();
           case "scope" : return env.getCurrentScope();
           case "vars" : return new VarsHash(env);
           case "locale" : return env.getLocale().toString();
           case "lang" : return env.getLocale().getLanguage();
           case "current_node" :
           case "node" : return env.getCurrentVisitorNode();
           case "pass" : return Macro.DO_NOTHING_MACRO;
           case "name" : return env.getTemplate().getName(); 
           case "version" : return Configuration.getVersionNumber();
           case "output_encoding" : return env.getOutputEncoding();
           case "url_escaping_charset" : return env.getURLEscapingCharset();
           case "error" : return env.getCurrentRecoveredErrorMessage();
        }
        throw new TemplateException("Invalid built-in variable: " + this, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        return this;
    }

    static class VarsHash implements TemplateHashModel {
        
        private final Environment env;
        
        VarsHash(Environment env) {
            this.env = env;
        }
        
        public Object get(String key) {
            return env.getVariable(key);
        }
        
        public boolean isEmpty() {
            return false;
        }
    }
}

INJECT DefaultToExpression : 
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.template.*;
    import freemarker.core.parser.ast.Expression;
    extends Expression
{
	public Expression getLeft() {
		return (Expression) get(0);
	}
	
	public Expression getRight() {
		return childrenOfType(Expression.class).size() == 2 ?
		(Expression) getLastChild() : null;
	}

	public Object evaluate(Environment env) {
		Object left = null;		
		try {
			left = getLeft().evaluate(env);
		} catch (InvalidReferenceException ire) {
			if (!(getLeft() instanceof ParentheticalExpression)) {
				throw ire;
			}
		}
		if (left != null && left != Constants.JAVA_NULL) return left;
		if (getRight() == null) return Constants.NOTHING;
		return getRight().evaluate(env);
	}

	public Expression _deepClone(String name, Expression subst) {
		DefaultToExpression result = new DefaultToExpression();
		result.add(getLeft().deepClone(name, subst));
		result.add(get(1));
		if (getRight() != null) {
			result.add(getRight().deepClone(name, subst));
		}
		return result;
	}
}

INJECT ExistsExpression :
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.core.parser.ast.ParentheticalExpression;
    import freemarker.core.parser.ast.Expression;
    import static freemarker.template.Constants.JAVA_NULL;
    extends Expression
{
	public Expression getExpression() {
		return (Expression) get(0);
	}

	public Object evaluate(Environment env) {
		Object value = null;
		try {
			value = getExpression().evaluate(env);
		} catch (InvalidReferenceException ire) {
			if (!(getExpression() instanceof ParentheticalExpression)) {
				throw ire;
			}
		}
		return value != null && value != JAVA_NULL;
	}

	public Expression _deepClone(String name, Expression subst) {
		ExistsExpression result = new ExistsExpression();
		result.add(getExpression().deepClone(name, subst));
		return result;
	}
}

INJECT BuiltInExpression :
import java.util.HashMap;

    import freemarker.core.Environment;
    import freemarker.core.builtins.*;
    import freemarker.template.TemplateDateModel;
    import freemarker.core.parser.ast.Expression;
    extends Expression;
{
    private static final HashMap<String, BuiltIn> knownBuiltins = new HashMap<String, BuiltIn>();
    {
        knownBuiltins.put("c", new cBI());
        knownBuiltins.put("size", new sizeBI());
        knownBuiltins.put("string", new stringBI());
        knownBuiltins.put("eval", new evalBI());
        knownBuiltins.put("new", new newBI());
        knownBuiltins.put("interpret", new interpretBI());
        knownBuiltins.put("resolve", new resolveBI());
        NumericalCast numericalCast = new NumericalCast();
        knownBuiltins.put("byte", numericalCast);
        knownBuiltins.put("double", numericalCast);
        knownBuiltins.put("float", numericalCast);
        knownBuiltins.put("int", numericalCast);
        knownBuiltins.put("long", numericalCast);
        knownBuiltins.put("short", numericalCast);
        knownBuiltins.put("floor", numericalCast);
        knownBuiltins.put("ceiling", numericalCast);
        knownBuiltins.put("round", numericalCast);
        knownBuiltins.put("capitalize", new StringTransformations.Capitalize());
        knownBuiltins.put("lower_case", new StringTransformations.LowerCase());
        knownBuiltins.put("upper_case", new StringTransformations.UpperCase());
        knownBuiltins.put("cap_first", new StringTransformations.CapFirst(true));
        knownBuiltins.put("uncap_first", new StringTransformations.CapFirst(false));
        knownBuiltins.put("j_string", new StringTransformations.Java());
        knownBuiltins.put("js_string", new StringTransformations.JavaScript());
        knownBuiltins.put("chop_linebreak", new StringTransformations.Chomp());
        knownBuiltins.put("trim", new StringTransformations.Trim());
        knownBuiltins.put("html", new StringTransformations.Html());
        knownBuiltins.put("rtf", new StringTransformations.Rtf());
        knownBuiltins.put("xml", new StringTransformations.Xml());
        knownBuiltins.put("xhtml", new StringTransformations.Xhtml());
        knownBuiltins.put("web_safe", knownBuiltins.get("html"));
        TypeChecks typeChecks = new TypeChecks();
        knownBuiltins.put("is_boolean", typeChecks);
        knownBuiltins.put("is_collection", typeChecks);
        knownBuiltins.put("is_date", typeChecks);
        knownBuiltins.put("is_enumerable", typeChecks);
        knownBuiltins.put("is_hash", typeChecks);
        knownBuiltins.put("is_hash_ex", typeChecks);
        knownBuiltins.put("is_indexable", typeChecks);
        knownBuiltins.put("is_directive", typeChecks);
        knownBuiltins.put("is_method", typeChecks);
        knownBuiltins.put("is_null", typeChecks);
        knownBuiltins.put("is_number", typeChecks);
        knownBuiltins.put("is_macro", typeChecks);
        knownBuiltins.put("is_node", typeChecks);
        knownBuiltins.put("is_sequence", typeChecks);
        knownBuiltins.put("is_string", typeChecks);
        knownBuiltins.put("is_transform", typeChecks);
        knownBuiltins.put("index_of", new StringFunctions.IndexOf());
        knownBuiltins.put("last_index_of", new StringFunctions.LastIndexOf());
        knownBuiltins.put("contains", new StringFunctions.Contains());
        knownBuiltins.put("number", new numberBI());
        knownBuiltins.put("left_pad", new StringFunctions.LeftPad());
        knownBuiltins.put("right_pad", new StringFunctions.RightPad());
        knownBuiltins.put("length", new StringFunctions.Length());
        knownBuiltins.put("replace", new StringFunctions.Replace());
        knownBuiltins.put("split", new StringFunctions.Split());
        knownBuiltins.put("groups", new groupsBI());
        knownBuiltins.put("matches", new StringFunctions.Matches());
        knownBuiltins.put("starts_with", new StringFunctions.StartsWith());
        knownBuiltins.put("ends_with", new StringFunctions.EndsWith());
        knownBuiltins.put("substring", new StringFunctions.Substring());
        knownBuiltins.put("word_list", new StringFunctions.WordList());
        knownBuiltins.put("url", new StringFunctions.Url());
        knownBuiltins.put("parent", new NodeFunctions.Parent());
        knownBuiltins.put("children", new NodeFunctions.Children());
        knownBuiltins.put("node_name", new NodeFunctions.NodeName());
        knownBuiltins.put("node_type", new NodeFunctions.NodeType());
        knownBuiltins.put("node_namespace", new NodeFunctions.NodeNamespace());
        knownBuiltins.put("root", new NodeFunctions.Root());
        knownBuiltins.put("ancestors", new NodeFunctions.Ancestors());
        knownBuiltins.put("first", new SequenceFunctions.First());
        knownBuiltins.put("last", new SequenceFunctions.Last());
        knownBuiltins.put("reverse", new SequenceFunctions.Reverse());
        knownBuiltins.put("sort", new SequenceFunctions.Sort());
        knownBuiltins.put("sort_by", new SequenceFunctions.SortBy());
        knownBuiltins.put("chunk", new SequenceFunctions.Chunk());
        knownBuiltins.put("seq_contains", new SequenceContainsBuiltIn());
        knownBuiltins.put("seq_index_of", new SequenceFunctions.IndexOf());
        knownBuiltins.put("seq_last_index_of", new SequenceFunctions.LastIndexOf());
        knownBuiltins.put("scope", new MacroBuiltins.Scope());
        knownBuiltins.put("namespace", new MacroBuiltins.Namespace());
        knownBuiltins.put("keys", new HashBuiltin.Keys());
        knownBuiltins.put("values", new HashBuiltin.Values());
        knownBuiltins.put("date", new DateTime(TemplateDateModel.DATE));
        knownBuiltins.put("time", new DateTime(TemplateDateModel.TIME));
        knownBuiltins.put("datetime", new DateTime(TemplateDateModel.DATETIME));
        knownBuiltins.put("is_defined", new ExistenceBuiltIn.IsDefinedBuiltIn());
        knownBuiltins.put("if_exists", new ExistenceBuiltIn.IfExistsBuiltIn());
        knownBuiltins.put("exists", new ExistenceBuiltIn.ExistsBuiltIn());
        knownBuiltins.put("default", new ExistenceBuiltIn.DefaultBuiltIn());
        knownBuiltins.put("has_content", new ExistenceBuiltIn.HasContentBuiltIn());
        knownBuiltins.put("source", new sourceBI());
    }

    private String key;
    private BuiltIn bi;

    public void close() {
        key = getKeyTok().toString().intern();
        bi = knownBuiltins.get(key);
    }

    public Expression getTarget() {
        return (Expression) get(0);
    }

    public Token getKeyTok() {
        return (Token) firstChildOfType(Token.TokenType.ID);
    }

    public BuiltIn getBuiltIn() {
        return bi;
    }

    public Object evaluate(Environment env) {
        return bi.get(env, this);
    }

    public String getName() {
        return key;
    }

    public Expression _deepClone(String name, Expression subst) {
        BuiltInExpression result = new BuiltInExpression();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        result.add(getKeyTok());
        result.key = key;
        result.bi = bi;
        return result;
    }
}

INJECT DotVariable : 
    import freemarker.core.Environment;
    import freemarker.core.parser.Token;
    import freemarker.template.TemplateHashModel;
    import freemarker.core.parser.ast.Expression;
    import java.util.Map;
    import static freemarker.ext.beans.ObjectWrapper.wrap;
    extends Expression
{
    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public String getKey() {
    	return get(2).toString();
    }

    public Object evaluate(Environment env) {
        Object leftModel = getTarget().evaluate(env);
        if (leftModel instanceof Map) {
            return wrap(((Map)leftModel).get(getKey()));
        }
        if(leftModel instanceof TemplateHashModel) {
            return wrap(((TemplateHashModel) leftModel).get(getKey()));
        }
        throw invalidTypeException(leftModel, getTarget(), env, "hash");
    }

    public Expression _deepClone(String name, Expression subst) {
        Expression clonedTarget = getTarget().deepClone(name, subst);
        Token op = (Token) get(1);
        Token key = (Token) get(2);
        Expression result = new DotVariable();
        result.add(clonedTarget);
        result.add(op);
        result.add(key);
        return result;
    }

    public boolean onlyHasIdentifiers() {
        Expression target = getTarget();
        return (target instanceof Identifier) 
               || ((target instanceof DotVariable) 
               && ((DotVariable) target).onlyHasIdentifiers());
    }    
}

INJECT DynamicKeyName :
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Map;
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.ext.beans.ListModel;
    import freemarker.core.parser.ast.Expression;
    import freemarker.core.ast.EvaluationUtil;
    import freemarker.core.ast.NonStringException;
    import freemarker.core.ast.Range;
    import static freemarker.ext.beans.ObjectWrapper.*;
    import static freemarker.template.Constants.JAVA_NULL;
    extends Expression
{

    public Expression getNameExpression() {
    	return (Expression) get(2);
    }
    
    public Expression getTarget() {
    	return (Expression) get(0);
    }

    public Object evaluate(Environment env) throws TemplateException
    {
        Object value = getTarget().evaluate(env);
        assertNonNull(value, getTarget(), env);
        if (getNameExpression() instanceof RangeExpression) {
            return dealWithRangeKey(value, (RangeExpression) getNameExpression(), env);
        }
        Object key = getNameExpression().evaluate(env);
        if(key == null) {
            assertNonNull(key, getNameExpression(), env);
        }
        if (isNumber(key)) {
            int index = asNumber(key).intValue();
            return dealWithNumericalKey(value, index, env);
        }
        if (isString(key)) {
            return dealWithStringKey(value, asString(key), env);
        }
        throw invalidTypeException(key, getNameExpression(), env, "number, range, or string");
    }


    private Object dealWithNumericalKey(Object targetModel, 
                                               int index, 
                                               Environment env)
    {
        if (targetModel instanceof TemplateSequenceModel) {
            TemplateSequenceModel tsm = (TemplateSequenceModel) targetModel;
            int size = Integer.MAX_VALUE;
            try {
                size = tsm.size();
            } catch (Exception e) {}
            return index<size ? tsm.get(index) : null;
        } 
        if (targetModel instanceof List) {
            try {
                return wrap(((List)targetModel).get(index));
            } catch (ArrayIndexOutOfBoundsException ae) {
                return JAVA_NULL;
            }
        }
        try
        {
            String s = getTarget().getStringValue(env);
            try {
               return s.substring(index, index+1);
            } catch (RuntimeException re) {
                throw new TemplateException("", re, env);
            }
        }
        catch(NonStringException e)
        {
            throw invalidTypeException(targetModel, getTarget(), env, "number, sequence, or string");
        }
    }

    private Object dealWithStringKey(Object targetModel, 
                                            String key,
                                            Environment env)
    {
        if (targetModel instanceof Map) {
            return wrap(((Map) targetModel).get(key));
        }
        if(targetModel instanceof TemplateHashModel) {
            return wrap(((TemplateHashModel) targetModel).get(key));
        }
        throw invalidTypeException(targetModel, getTarget(), env, "hash");
    }

    private Object dealWithRangeKey(Object targetModel, 
                                           RangeExpression range, 
                                           Environment env)
    {
        int start = EvaluationUtil.getNumber(range.getLeft(), env).intValue();
        int end = 0;
        boolean hasRhs = range.hasRhs();
        if (hasRhs) {
            end = EvaluationUtil.getNumber(range.getRight(), env).intValue();
        }
        if (targetModel instanceof TemplateSequenceModel) {
            TemplateSequenceModel sequence = (TemplateSequenceModel) targetModel;
            if (!hasRhs) end = sequence.size() -1;
            if (start < 0) {
                String msg = range.getRight().getStartLocation() + "\nNegative starting index for range, is " + range;
                throw new TemplateException(msg, env);
            }
            if (end < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative ending index for range, is " + range;
                throw new TemplateException(msg, env);
            }
            if (start >= sequence.size()) {
                String msg = range.getLeft().getStartLocation() 
                            + "\nLeft side index of range out of bounds, is " + start
                            + ", but the sequence has only " + sequence.size() + " element(s) "
                            + "(note that indices are 0 based, and ranges are inclusive).";
                throw new TemplateException(msg, env);
            }
            if (end >= sequence.size()) {
                String msg = range.getRight().getStartLocation() 
                             + "\nRight side index of range out of bounds, is " + end
                             + ", but the sequence has only " + sequence.size() + " element(s)."
                             + "(note that indices are 0 based, and ranges are inclusive).";
                throw new TemplateException(msg, env);
            }
            ArrayList<Object> list = new ArrayList<>(1+Math.abs(start-end));
            if (start>end) {
                for (int i = start; i>=end; i--) {
                    list.add(sequence.get(i));
                }
            }
            else {
                for (int i = start; i<=end; i++) {
                    list.add(sequence.get(i));
                }
            }
            return new ListModel(list);
        }
        
        try
        {
            String s = getTarget().getStringValue(env);
            if (!hasRhs) end = s.length() -1;
            if (start < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative starting index for range " + range + " : " + start;
                throw new TemplateException(msg, env);
            }
            if (end < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative ending index for range " + range + " : " + end;
                throw new TemplateException(msg, env);
            }
            if (start > s.length()) {
                String msg = range.getLeft().getStartLocation() 
                            + "\nLeft side of range out of bounds, is: " + start
                            + "\nbut string " + targetModel + " has " + s.length() + " elements.";
                throw new TemplateException(msg, env);
            }
            if (end > s.length()) {
                String msg = range.getRight().getStartLocation() 
                             + "\nRight side of range out of bounds, is: " + end
                             + "\nbut string " + targetModel + " is only " + s.length() + " characters.";
                throw new TemplateException(msg, env);
            }
            try {
                return s.substring(start, end+1);
            } catch (RuntimeException re) {
                String msg = "Error " + getStartLocation();
                throw new TemplateException(msg, re, env);
            }
        }
        catch(NonStringException e)
        {
            throw invalidTypeException(getTarget().evaluate(env), getTarget(), env, "number, scalar, or sequence");
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        DynamicKeyName result = new DynamicKeyName();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        result.add(getNameExpression().deepClone(name, subst));
        result.add(get(3));
        return result;
    }
}

INJECT MethodCall :
    import java.util.ArrayList;
    import java.util.List;
    import java.io.Writer;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ObjectWrapper;
    import freemarker.template.*;
    import java.io.IOException;
    import java.io.StringWriter;
    import freemarker.core.ast.Macro;
    extends Expression;
{

    public ArgsList getArgs() {
        return firstChildOfType(ArgsList.class);
    }

    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public Object evaluate(Environment env) throws TemplateException
    {
        Object value = getTarget().evaluate(env);
        if (value instanceof TemplateMethodModel) {
            TemplateMethodModel targetMethod = (TemplateMethodModel)value;
            ArgsList args = getArgs();
            List argumentStrings = new ArrayList();
            if (args !=null) {
                argumentStrings = args.getParameterSequence(targetMethod, env);
            }
            Object result = targetMethod.exec(argumentStrings);
            return ObjectWrapper.wrap(result);
        }
        else if (value instanceof Macro) {
            Macro func = (Macro) value;
            StringWriter sw = null;
            env.setLastReturnValue(null);
            Writer prevOut = env.getOut();
            try {
                env.setOut(Environment.NULL_WRITER);
                if (!func.isFunction()) {
                    sw = new StringWriter();
                    env.setOut(sw);
                 }
                env.render(func, getArgs(), null, null);
            } catch (IOException ioe) {
                throw new InternalError("This should be impossible.");
            } finally {
                env.setOut(prevOut);
            }
            return sw != null ? ObjectWrapper.wrap(sw.getBuffer().toString()) : env.getLastReturnValue();
        }
        else {
            throw invalidTypeException(value, getTarget(), env, "method");
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        MethodCall result = new MethodCall();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        ArgsList args = getArgs();
        if (args != null) {
            result.add(getArgs().deepClone(name, subst));
            result.add(get(3));
        } else {
            result.add(get(2));
        }
        return result;
    }
}

#PositionalArgsList# : 
	Expression 
	(
	   [<COMMA>]
	   Expression 
	)*
    {
        return CURRENT_NODE;
    }
;

INJECT PositionalArgsList :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.template.utility.UndeclaredThrowableException;
    extends ArgsList
{
   public List getParameterSequence(Object target, Environment env) {
        ParameterList annotatedParameterList = getParameterList(target);
        if (annotatedParameterList == null) {
            List<Object> result = new ArrayList<>();
            for (Expression exp : childrenOfType(Expression.class)) {
               result.add(exp.evaluate(env));
            }
            return result;
        }
        return annotatedParameterList.getParameterSequence(this, env);
    }

    public Map<String, Object> getParameterMap(Object target, Environment env)
    {
        Map<String, Object> result = new HashMap<String, Object>();
        ParameterList annotatedParameterList = getParameterList(target);
        if (annotatedParameterList == null) {
            if (firstChildOfType(Expression.class) != null) {
                throw new TemplateModelException("Cannot pass positional arguments to this TemplateTransformModel");
            }
        }
        else {
            result = annotatedParameterList.getParameterMap(this, env, false);
        }
        return result;
    }

    public Object getValueAt(int i, Environment env) {
        Expression exp = childrenOfType(Expression.class).get(i);
        Object value = exp.evaluate(env);
        TemplateNode.assertIsDefined(value, exp, env);
        return value;
    }

    public PositionalArgsList deepClone(String name, Expression subst) {
        PositionalArgsList result = new PositionalArgsList();
        for (Node node : this) {
            if (node instanceof Expression) {
                node = ((Expression)node).deepClone(name, subst);
            }
            result.add(node);
        }
        return result;
    }    
}

#NamedArgsList# :
{
    String param;
	Expression arg;
}
	<ID> {param = lastConsumedToken.toString();}
	<EQUALS> 
	arg=Expression  
	{
		CURRENT_NODE.addNamedArg(param, arg);
	}
	(
	   [<COMMA>]
	   <ID> {param = lastConsumedToken.toString();}
	   <EQUALS>
	   arg=Expression
	   {CURRENT_NODE.addNamedArg(param, arg);}
	)*
	{
		token_source.inInvocation = false;
		return CURRENT_NODE;
	}
;

INJECT NamedArgsList :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ParseException;
    import freemarker.core.parser.ast.ArgsList;
    import freemarker.core.parser.ast.Expression;
    import freemarker.core.parser.ast.ParameterList;
    import freemarker.core.parser.ast.TemplateNode;
    import freemarker.template.*;
    extends ArgsList;
{

    private LinkedHashMap<String,Expression> namedArgs = 
        new LinkedHashMap<String, Expression>();

    public void addNamedArg(String name, Expression exp) throws ParseException{
        if (namedArgs.containsKey(name)) throw new ParseException(
                "Error at: " + exp.getStartLocation() + "\nArgument " + name + " was already specified.");
        namedArgs.put(name, exp);
        exp.setParent(this);
    }

    public Map<String, Expression> getArgs() {
        return namedArgs;
    }

    public int size() {
        return namedArgs.size();
    }

    public Map<String,Expression> getCopyOfMap() {
        return (Map<String,Expression>)namedArgs.clone();
    }

    public Map<String, Object> getParameterMap(Object tm, Environment env) {
        Map<String, Object> result = null; 
        ParameterList annotatedParameterList = ArgsList.getParameterList(tm);
        if (annotatedParameterList == null) {
            result = new HashMap<String, Object>();
            for (String paramName : namedArgs.keySet()) {
                Expression exp = namedArgs.get(paramName);
                Object value = exp.evaluate(env);
                TemplateNode.assertIsDefined(value, exp, env);
                result.put(paramName, value);
            }
        }
        else {
            result = annotatedParameterList.getParameterMap(this, env);
        }
        return result;
    }

    public List<Object> getParameterSequence(Object target, Environment env) {
        ParameterList annotatedParameterList = getParameterList(target);
        if (annotatedParameterList == null) {
            String msg = "Error at: " + getStartLocation() 
            + "\nCannot invoke method " + target + " with a key=value parameter list because it is not annotated.";
            throw new TemplateException(msg, env);
        }
        return annotatedParameterList.getParameterSequence(this, env);
    }

    public ArgsList deepClone(String name, Expression subst) {
        NamedArgsList result = new NamedArgsList();
        for (Map.Entry<String, Expression> entry : namedArgs.entrySet()) {
            try {
                result.addNamedArg(entry.getKey(), entry.getValue());
            } catch (ParseException pe) {} // This can't happen anyway, since we already checked for repeats
        }
        return result;
    }
}

#ArgsList#abstract :
{
	ArgsList result = null;
	Token id;
	Expression exp = null;
}
	(
	   SCAN <ID><EQUALS> =>
       result=NamedArgsList
       |
       result=PositionalArgsList
    )
	{
		return result;
	}
;

INJECT ArgsList :
    import java.util.*;
    import java.util.concurrent.ConcurrentHashMap;
    import java.lang.reflect.*;

    import freemarker.annotations.Parameters;
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.core.parser.*;
    import freemarker.core.parser.FMLexer.LexicalState;
    import freemarker.ext.beans.SimpleMethodModel;
{
	/**
	 * Cache the retrieved annotation information, since it seems like 
	 * this operation could be a bit expensive.
	 */
	private static Map<String, ParameterList> parameterListCache = new ConcurrentHashMap<String, ParameterList>();
   // Placeholder for null - ConcurrentHashMap doesn't tolerate null values
	private static final ParameterList NO_PARAM_LIST = new ParameterList();
        
	/**
	 * The target will be either a TemplateTranformModel or TemplateMethodModel.
	 * This returns a key-value map of the arguments to be passed to the target.
	 * A TemplateException will be thrown if the target's parameters do not match
	 * this ArgList in some way.
	 */
	
	public abstract Map<String, Object> getParameterMap(Object target, Environment env);
	
	public abstract List<Object> getParameterSequence(Object target, Environment env);
	
	public static ParameterList getParameterList(Object target) {
            String keyName = target.getClass().getName();
            if (target instanceof SimpleMethodModel) {
                keyName = target.toString();
            }
            ParameterList result = parameterListCache.get(keyName);
            if(result == NO_PARAM_LIST) {
                return null;
            }
            if(result != null) {
                return result;
            }
            Parameters params = getAnnotatedParameters(target);
            if (params != null) {
                String paramString = params.value();
                if("".equals(paramString)) {
                    result = new ParameterList();
                }
                else try {
                    result = getParameterList(paramString);
                } catch (Exception pe) {
                    throw new TemplateException("Can't parse parameter list [" + paramString + "] on " + target, pe, Environment.getCurrentEnvironment());
                }
                parameterListCache.put(keyName, result);
                return result;
            } else {
                parameterListCache.put(keyName, NO_PARAM_LIST);
                return null;
            }
	}
	
	private static ParameterList getParameterList(String s) {
		FMLexer token_source = new FMLexer(s);
		token_source.switchTo(LexicalState.EXPRESSION);
		FMParser parser = new FMParser(token_source);
		return parser.ParameterList();
	}
	
	@SuppressWarnings("deprecation")
	private static Parameters getAnnotatedParameters(Object target) {
		Parameters params = null;
		Method keyMethod = null;
		if (target instanceof TemplateTransformModel) {
			try {
				keyMethod = target.getClass().getMethod("getWriter", new Class[] {java.io.Writer.class, java.util.Map.class}); 
			} catch (Exception e) {
				// This should be impossible, since
				// if the target is a TemplateTransformModel, it has this method, no?
				throw new InternalError(e.getMessage());
			}
		}
        else if (target instanceof SimpleMethodModel) {
            params = ((SimpleMethodModel) target).getParametersAnnotation();
        }
		else if (target instanceof TemplateMethodModel) {
			try {
				keyMethod = target.getClass().getMethod("exec", new Class[] {List.class});
			} catch (Exception e) {
				// Again, this condition should be impossible. If something is
				// a TemplateMethodModel, it must implement this exec method.
				throw new InternalError(e.getMessage());
			}
		}
		if (keyMethod != null) {
			params = keyMethod.getAnnotation(Parameters.class);
		}
		if (params == null) {
			// Check if the class is annotated now
			params = target.getClass().getAnnotation(Parameters.class);
		}
		return params;
	}
	
	public void setLocationInfoIfAbsent(TemplateNode invoker) {
		if (getBeginLine() == 0) {
			this.copyLocationFrom(invoker);
			
		}
	}
	
	public abstract ArgsList deepClone(String name, Expression subst);
}

Expression StringLiteral# :
{
  boolean raw = false;
}
   (
     <STRING_LITERAL>
     |
     <RAW_STRING> {raw = true;}
   )
   {
       String s = lastConsumedToken.toString();
       if (raw) s = s.substring(1);
       // Get rid of the quotes.
       s = s.substring(1, s.length() -1);
       if (!raw) s = StringUtil.FTLStringLiteralDec(s);
       CURRENT_NODE.setRaw(raw);
       CURRENT_NODE.setValue(s);
       return CURRENT_NODE;
   }
;

INJECT StringLiteral :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.parser.*;
   import freemarker.core.parser.ast.Expression;
   import freemarker.core.ast.TemplateElement;
   import java.io.*;
   extends Expression
{
    private TemplateElement interpolatedOutput;
    private String value;
    private boolean raw;

    public StringLiteral() {}
    
    public StringLiteral(String value, boolean raw) {
        this.value = value;
        this.raw = raw;
    }
    
    public boolean isRaw() {
    	return raw;
    }

    public void setRaw(boolean raw) {
        this.raw = raw;
    }
    
    public String getValue() {
    	return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
    
    public void checkInterpolation() {
    	String src = this.getSource();
        if (src.length() >5 && (src.indexOf("${") >= 0)) {
            FMLexer token_source = new FMLexer("input", value, FMLexer.LexicalState.DEFAULT, getBeginLine(), getBeginColumn() +1);
            token_source.setOnlyTextOutput(true);
            FMParser parser = new FMParser(token_source);
            parser.setTemplate(getTemplate());
            try {
                interpolatedOutput = parser.FreeMarkerText();
            }
            catch(ParseException e) {
                e.setTemplateName(getTemplate().getName());
                throw e;
            }
        }
    }
    
    public Object evaluate(Environment env) {
        return getStringValue(env);
    }

    public String getAsString() {
        return value;
    }
    
    public String getStringValue(Environment env) {
        if (interpolatedOutput == null) {
            return value;
        } 
        else {
            TemplateExceptionHandler teh = env.getTemplateExceptionHandler();
            env.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
            try {
               return env.renderElementToString(interpolatedOutput);
            }
            catch (IOException ioe) {
                throw new TemplateException(ioe, env);
            }
            finally {
                env.setTemplateExceptionHandler(teh);
            }
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        StringLiteral cloned = new StringLiteral(value, raw);
        cloned.interpolatedOutput = this.interpolatedOutput;
        return cloned;
    }
}

BooleanLiteral# :
   <FALSE>
   |
   <TRUE> {CURRENT_NODE.setValue(true);}
;

INJECT BooleanLiteral :
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.core.parser.ast.Expression;
    extends Expression
{
    @Property boolean value;

    public BooleanLiteral() {}
    public BooleanLiteral(boolean value) {this.value = value;}

    public boolean isTrue(Environment env) {
        return value;
    }

    public String toString() {
        return value ? "true" : "false";
    }

    public Boolean evaluate(Environment env) {
        return value;
    }

    public Expression _deepClone(String name, Expression subst) {
        BooleanLiteral result = new BooleanLiteral();
        result.setValue(value);
        return result;
    }

}

NullLiteral# :
   <NULL>
;

INJECT NullLiteral : 
   import freemarker.core.Environment;
   import freemarker.template.Constants;
   import freemarker.template.TemplateModel;
   import freemarker.core.parser.ast.Expression;
   extends Expression
{
    public String toString() {
    	return "null";
    }

    public Object evaluate(Environment env) {
        return Constants.JAVA_NULL;
    }

    public Expression _deepClone(String name, Expression subst) {
    	return new NullLiteral();
    }
}

HashLiteral# :
{
   Expression key, value;
   ArrayList<Expression> keys = new ArrayList<>();
   ArrayList<Expression> values = new ArrayList<>();
}
   <OPEN_BRACE>
   [
       key=Expression
       <COLON>
       value=Expression
       {
          keys.add(key);
          values.add(value);
       }
       (
          <COMMA>
           key=Expression
           <COLON>
           value=Expression
           {
               keys.add(key);
               values.add(value);
           }
       )*
   ]
   <CLOSE_BRACE>
   {
      clearNodeScope();
      for (int i = 0; i<keys.size();i++) {
         pushNode(keys.get(i));
         pushNode(values.get(i));
      }
   }
;

INJECT HashLiteral :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ListModel;
    import freemarker.template.*;
    import freemarker.core.parser.ast.Expression;
    import freemarker.core.ast.CollectionAndSequence;
    extends Expression
{
    private List<Expression> keys = new ArrayList<>();
    private List<Expression> values = new ArrayList<>();
    
    public void close() {
        boolean justSawKey = false;
        for (Expression exp : childrenOfType(Expression.class)) {
            if (justSawKey) values.add(exp);
            else keys.add(exp);
            justSawKey = !justSawKey;
       }
       assert keys.size() == values.size() : getSource();
    }
    
    public Object evaluate(Environment env) {
        return new SequenceHash(env);
    }
    
    public List<Expression> getKeys() {
    	return Collections.unmodifiableList(keys);
    }
    
    public List<Expression> getValues() {
    	return Collections.unmodifiableList(values);
    }

    public Expression _deepClone(String name, Expression subst) {
    	HashLiteral result = new HashLiteral();
        for (int i = 0; i< keys.size(); i++) {
            Expression keyClone = keys.get(i).deepClone(name, subst);
            Expression valueClone = values.get(i).deepClone(name, subst);
            result.keys.add(keyClone);
            result.values.add(valueClone);
        }
        result.close();
        return result;
    }

    private class SequenceHash implements TemplateHashModelEx {

        private HashMap<String, Object> keyMap  = new HashMap<>(); // maps keys to integer offset
        private Iterable<String> keyCollection;
        private Iterable<Object> valueCollection; 

        SequenceHash(Environment env) {
            List<String> keyList = new ArrayList<String>(keys.size());
            List<Object> valueList = new ArrayList<>(keys.size());
            for (int i = 0; i< keys.size(); i++) {
                Expression keyExp = keys.get(i);
                Expression valExp = values.get(i);
                String key = keyExp.getStringValue(env);
                Object value = valExp.evaluate(env);
                assertIsDefined(value, valExp, env);
                keyMap.put(key, value);
                keyList.add(key);
                valueList.add(value);
            }
            keyCollection = keyList;
            valueCollection = valueList;
        }

        public int size() {
            return keys.size();
        }

        public Iterable keys() {
            return keyCollection;
        }

        public Iterable values() {
            return valueCollection;
        }

        public Object get(String key) {
            return keyMap.get(key);
        }

        public boolean isEmpty() {
            return size() == 0;
        }
    }
}
