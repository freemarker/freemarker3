// This file defines the expression
// grammar. It is INCLUDEd from the main template.

#Expression :
{
	Expression exp;
}
	 exp=OrExpression {return exp;}
;

/**
 * Lowest level expression, a literal, a variable,
 * or a possibly more complex expression bounded
 * by parentheses.
 */
Expression PrimaryExpression :
{
   Expression exp;
}
   (
      exp=NumberLiteral
      |
      exp=HashLiteral
      |
      exp=StringLiteral
      |
      exp=BooleanLiteral
      |
      exp=NullLiteral
      |
      exp=ListLiteral
      |
      exp=Identifier
      |
      exp=ParentheticalExpression
      |
      exp=BuiltinVariable
  )
  (
      exp=DotVariable(exp)
      |
      exp=DynamicKeyName(exp)
      |
      exp=MethodCall(exp)
      |
      exp=BuiltIn(exp)
      |
      exp=Exists(exp)
      |
      exp=DefaultTo(exp)
  )*
  {
     return exp;
  }
;

ParentheticalExpression# :
{
   Expression exp;
}
    <OPEN_PAREN> 
    exp=Expression 
    {
      clearNodeScope();
      pushNode(exp);
    }
    <CLOSE_PAREN>
;

INJECT ParentheticalExpression :
   import freemarker.core.Environment;
   import freemarker.core.ast.Expression;
   extends Expression
{
   public Expression getNested() {
        return firstChildOfType(Expression.class);
    }

    public boolean isTrue(Environment env) {
        return getNested().isTrue(env);
    }
    
    public Object evaluate(Environment env) {
        return getNested().evaluate(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        ParentheticalExpression result = new ParentheticalExpression();
        result.add(getNested().deepClone(name, subst));
        return result;
    }   
}

/**
 * A primary expression preceded by zero or
 * more unary operators. 
 */
Expression UnaryExpression :
{
   Expression result;
}
  (
   result=UnaryPlusMinusExpression
   |
   result=NotExpression
   |
   result=PrimaryExpression
  )
  {
     return result;
  }
;

Expression NotExpression : 
{
   Token t;
   Expression exp, result=null;
   List<Token> nots = new ArrayList<Token>();
}
   (
      t=<EXCLAM> {nots.add(t);}
   )+
   exp=PrimaryExpression 
   {
      for (int i=0; i<nots.size(); i++) {
         result = new NotExpression(exp);
         Token tok = nots.get(nots.size() -i -1);
         result.setLocation(template, token_source, tok, exp);
         exp = result;
      }
      return result;
   }
;

Expression UnaryPlusMinusExpression :
{
   Expression exp, result;
   boolean isMinus = false;
   Token t;
}
   (
      t=<PLUS>
      |
      t=<MINUS> {isMinus = true;}
   )
   exp=PrimaryExpression 
   {
      result = new UnaryPlusMinusExpression(exp, isMinus);  
      result.setLocation(template, token_source, t, exp);
      return result;
   }
;

Expression AdditiveExpression :
{
   Expression lhs, rhs, result;
   boolean plus;
}
   lhs=MultiplicativeExpression {result = lhs;}
   (
      (
         <PLUS> {plus = true;}
         |
         <MINUS> {plus = false;}
      )
      rhs=MultiplicativeExpression
      {
         if (plus) {
           // plus is treated separately, since it is also
           // used for concatenation.
             result = new AddConcatExpression(lhs, rhs);
         } 
         else {
             result = new ArithmeticExpression(lhs, rhs,
                                            ArithmeticExpression.SUBTRACTION);
         }
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;

/**
 * A unary expression followed by zero or more
 * unary expressions with operators in between.
 */
Expression MultiplicativeExpression :
{
   Expression lhs, rhs, result;
   int operation = ArithmeticExpression.MULTIPLICATION;
}
   lhs=UnaryExpression {result = lhs;}
   (
      (
         <TIMES> {operation = ArithmeticExpression.MULTIPLICATION;}
         |
         <DIVIDE> {operation = ArithmeticExpression.DIVISION;}
         |
         <PERCENT>{operation = ArithmeticExpression.MODULUS;}
      )
      rhs=UnaryExpression
      {
         result = new ArithmeticExpression(lhs, rhs, operation);
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;


Expression EqualityExpression :
{
   Expression lhs, rhs, result;
   Token t;
}
   lhs=RelationalExpression {result = lhs;}
   [
     (
      t=<NOT_EQUALS> 
      |
      t=<EQUALS> 
      |
      t=<DOUBLE_EQUALS>
     )
     rhs=RelationalExpression
     {
        result = new ComparisonExpression(lhs, rhs, t.toString());
        result.setLocation(template, token_source, lhs, rhs);
     }
   ]
   {
      return result;
   }
;

Expression RelationalExpression :
{
   Expression lhs, rhs, result;
   Token t;
}
   lhs=RangeExpression {result = lhs;}
   [
     (
      t=<GREATER_THAN_EQUALS>
      |
      t=<ESCAPED_GTE>
      |
      t=<GREATER_THAN>
      |
      t=<ESCAPED_GT>
      |
      t=<LESS_THAN_EQUALS>
      |
      t=<LESS_THAN>
     )
     rhs=RangeExpression
     {
        result = new ComparisonExpression(lhs, rhs, t.toString());
        result.setLocation(template, token_source, lhs, rhs);
     }
   ]
   {
      return result;
   }
;

Expression RangeExpression :
{
   Expression lhs, rhs=null, result;
}
    lhs=AdditiveExpression {result = lhs;}
    [
      <DOT_DOT>
       [ rhs=AdditiveExpression =>|| 
       ]
       {
           Range range = new Range(lhs, rhs);
           if (rhs != null) {
               range.setLocation(template, token_source, lhs, rhs);
           } else {
              range.setLocation(template, token_source, lhs, lhs);
           }
           result = range;
        }
    ]
    {
        return result;
    }
;

Expression AndExpression :
{
   Expression lhs, rhs, result;
}
   lhs=EqualityExpression {result = lhs;}
   (
      <AND>
      rhs=EqualityExpression
      {
         result = new AndExpression(lhs, rhs);
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;

Expression OrExpression :
{
   Expression lhs, rhs, result;
}
   lhs=AndExpression {result = lhs;}
   (
      <OR>
      rhs=AndExpression
      {
         result = new OrExpression(lhs, rhs);
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;

#ListLiteral#(false) :
{
   Expression exp;
   ArrayList<Expression> values = new ArrayList<Expression>();
   Token begin, end;
}
    begin=<OPEN_BRACKET>
    [
      exp=Expression {values.add(exp);}
      (
         <COMMA>
         exp=Expression {values.add(exp);}
      )*
    ]
    end=<CLOSE_BRACKET>
    {
        CURRENT_NODE.setLocation(template, token_source, begin, end);
        CURRENT_NODE.addAll(values);
        return CURRENT_NODE;
    }
;

INJECT ListLiteral :
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  import freemarker.core.Environment;
  import freemarker.core.TemplateNamespace;
  import freemarker.ext.beans.ListModel;
  import freemarker.template.TemplateException;
  import freemarker.template.*;
  import freemarker.core.ast.Expression;
  extends Expression
{
    public List<Expression> getElements() {
        return childrenOfType(Expression.class);
    }
    
    public Object evaluate(Environment env) {
        ListModel list = new ListModel();
        for (Expression exp: getElements()) {
            Object tm = exp.evaluate(env);
            assertIsDefined(tm, exp, env);
            list.add(tm);
        }
        return list;
    }

    // A hacky routine used by VisitNode and RecurseNode
    
    public TemplateSequenceModel evaluateStringsToNamespaces(Environment env) {
        ListModel result = new ListModel();
        for (Expression exp : getElements()) {
            if (exp instanceof StringLiteral) {
                String s = ((StringLiteral) exp).getAsString();
                try {
                    TemplateNamespace ns = env.importLib(s, null);
                    result.add(ns);
                } 
                catch (IOException ioe) {
                    throw new TemplateException("Could not import library '" + s + "', " + ioe.getMessage(), env); 
                }
            }
            else {
                result.add(exp);
            }
        }
        return result;
    }
    
    public Expression _deepClone(String name, Expression subst) {
    	ArrayList<Expression> clonedValues = new ArrayList<Expression>(size());
    	for (Expression exp : getElements()) {
    		clonedValues.add(exp.deepClone(name, subst));
    	}
      ListLiteral ll = new ListLiteral();
      ll.addAll(clonedValues);
      return ll;
    }
}

NumberLiteral# :
   (
      <INTEGER>
      |
      <DECIMAL>
   )
   {
       String s = lastConsumedToken.toString();
       Number n = template != null ? template.getArithmeticEngine().toNumber(s) : new java.math.BigDecimal(s);
       CURRENT_NODE.setValue(n);
   }
;

INJECT NumberLiteral :
  import freemarker.core.Environment;
  import freemarker.core.ast.Expression;
  import freemarker.template.*;
  import freemarker.ext.beans.NumberModel;
  extends Expression
{
    @Property Number value;

    public NumberLiteral() {}

    public NumberLiteral(Number value) {
        this.value = value;
    }
    
    public Object evaluate(Environment env) {
        return new NumberModel(value);
    }
    
    public String getStringValue(Environment env) {
        return env.formatNumber(value);
    }

    public Number getAsNumber() {
        return value;
    }
    
    String getName() {
        return "the number: '" + value + "'";
    }

    public Expression _deepClone(String name, Expression subst) {
        return new NumberLiteral(value);
    }
}

Identifier# :
   <ID> 
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   } 
;

INJECT Identifier :
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.ast.Expression;
    extends Expression
{
    @Property String name;

    public Identifier() {}

    public Identifier(String name) {
        this.name = name;
    }
    
    public Object evaluate(Environment env) {
        try {
            return env.getVariable(name);
        } catch (NullPointerException e) {
            if (env == null) {
                throw new TemplateException("Variables are not available "
                + "(certainly you are in a parse-time executed directive). The name of the variable "
                + "you tried to read: " + name, null);
            } else {
                throw e;
            }
        }
    }

    public String toString() {
        return name;
    }

    public Expression _deepClone(String name, Expression subst) {
        if(this.name.equals(name)) {
        	return subst.deepClone(null, null);
        }
        return new Identifier(this.name);
    }
}

Expression IdentifierOrStringLiteral :
{
   Expression exp;
}
   (
      exp=Identifier
      |
      exp=StringLiteral
   )
   {
      return exp;
   }   
;

BuiltinVariable# :
   <DOT>
   <ID>
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   }
;

INJECT BuiltinVariable :
    import freemarker.template.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ParseException;
    import freemarker.ext.beans.StringModel;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.Macro;
    extends Expression
{
    private String name;

    public void setName(String name) {
      this.name = name.intern();
    }
    
    public String getName() {
        return name;
    }

    public Object evaluate(Environment env) {
        switch (name) {
           case "namespace" : return env.getCurrentNamespace();
           case "main" : return env.getMainNamespace();
           case "globals" : return env;
           case "locals" : return env.getCurrentMacroContext();
           case "data_model" : return env.getDataModel();
           case "scope" : return env.getCurrentScope();
           case "vars" : return new VarsHash(env);
           case "locale" : return new StringModel(env.getLocale().toString());
           case "lang" : return new StringModel(env.getLocale().getLanguage());
           case "current_node" :
           case "node" : return env.getCurrentVisitorNode();
           case "pass" : return Macro.DO_NOTHING_MACRO;
           case "name" : return new StringModel(env.getTemplate().getName()); 
           case "version" : return new StringModel(Configuration.getVersionNumber());
           case "output_encoding" : String s = env.getOutputEncoding();
                                    return s != null ? new StringModel(s) : null;
           case "url_escaping_charset" : s = env.getURLEscapingCharset();
                                         return s != null ? new StringModel(s) : null;
           case "error" : return new StringModel(env.getCurrentRecoveredErrorMessage());
        }
        throw new TemplateException("Invalid built-in variable: " + this, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        return this;
    }

    static class VarsHash implements TemplateHashModel {
        
        private final Environment env;
        
        VarsHash(Environment env) {
            this.env = env;
        }
        
        public Object get(String key) {
            return env.getVariable(key);
        }
        
        public boolean isEmpty() {
            return false;
        }
    }
}

Expression DefaultTo(Expression exp) :
{
   Expression rhs = null;
   Token t;
}
   (
       t=<EXCLAM>
       [
         SCAN {getToken(1).getType() != TokenType.ID || getToken(2).getType() != TokenType.EQUALS}
         => rhs=PrimaryExpression =>|| 
       ]
   )
   {
      DefaultToExpression result = new DefaultToExpression(exp, rhs);
      if (rhs ==null) {
          result.setLocation(template, token_source, exp, t);
      }
      else {
          result.setLocation(template, token_source, exp, rhs);
      }
      return result;
   }
;

Expression Exists(Expression exp) :
{
   Token t;
}
   t=<EXISTS>
   {
       ExistsExpression result = new ExistsExpression(exp);
       result.setLocation(template, token_source, exp, t);
       return result;
   }
;

Expression BuiltIn(Expression exp) :
{
   Token t=null;
}
   <BUILT_IN>
   t=<ID>
   {
   	   BuiltInExpression result = new BuiltInExpression(exp, t.toString());
         if (result.getBuiltIn() == null) {
            fail("Unknown builtin ",t);
           //throw new ParseException(this, "Unknown builtin " + t.toString());
         }
   	   result.setLocation(template, token_source, exp, t);
   	   return result;
   }
;

/**
 * production for when a key is specified by <DOT> + keyname
 */
Expression DotVariable(Expression exp)# :
     {pushNode(exp);}
     <DOT>{token_source.justAfterDot = true;}
     <ID>{token_source.justAfterDot = false;}
     {
         return CURRENT_NODE;
     }
;

INJECT DotVariable : 
    import freemarker.core.Environment;
    import freemarker.core.parser.Token;
    import freemarker.template.TemplateHashModel;
    import freemarker.core.ast.Expression;
    import java.util.Map;
    extends Expression
{
    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public String getKey() {
    	return get(2).toString();
    }

    public Object evaluate(Environment env) {
        Object leftModel = getTarget().evaluate(env);
        if (leftModel instanceof Map) {
            return ((Map)leftModel).get(getKey());
        }
        if(leftModel instanceof TemplateHashModel) {
            return ((TemplateHashModel) leftModel).get(getKey());
        }
        throw invalidTypeException(leftModel, getTarget(), env, "hash");
    }

    public Expression _deepClone(String name, Expression subst) {
        Expression clonedTarget = getTarget().deepClone(name, subst);
        Token op = (Token) get(1);
        Token key = (Token) get(2);
        Expression result = new DotVariable();
        result.add(clonedTarget);
        result.add(op);
        result.add(key);
        return result;
    }

    public boolean onlyHasIdentifiers() {
        Expression target = getTarget();
        return (target instanceof Identifier) 
               || ((target instanceof DotVariable) 
               && ((DotVariable) target).onlyHasIdentifiers());
    }    
}

/**
 * production for when the key is specified
 * in brackets.
 */
DynamicKeyName(Expression exp)# :
{
   pushNode(exp);
   Expression arg;
}
   <OPEN_BRACKET>
   arg=Expression 
   {
     while (currentNodeScope.size() > 2) {
        currentNodeScope.remove(currentNodeScope.size()-1);
     }
     pushNode(arg);
   }
   <CLOSE_BRACKET>
;

INJECT DynamicKeyName :
    import java.util.ArrayList;
    import java.util.Map;
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.ext.beans.ListModel;
    import freemarker.ext.beans.StringModel;
    import static freemarker.ext.beans.ObjectWrapper.*;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.EvaluationUtil;
    import freemarker.core.ast.NonStringException;
    import freemarker.core.ast.Range;
    extends Expression
{

    public Expression getNameExpression() {
    	return (Expression) get(2);
    }
    
    public Expression getTarget() {
    	return (Expression) get(0);
    }

    public Object evaluate(Environment env) throws TemplateException
    {
        Object value = getTarget().evaluate(env);
        assertNonNull(value, getTarget(), env);
        if (getNameExpression() instanceof Range) {
            return dealWithRangeKey(value, (Range) getNameExpression(), env);
        }
        Object key = getNameExpression().evaluate(env);
        if(key == null) {
            assertNonNull(key, getNameExpression(), env);
        }
        if (isNumber(key)) {
            int index = asNumber(key).intValue();
            return dealWithNumericalKey(value, index, env);
        }
        if (isString(key)) {
            return dealWithStringKey(value, asString(key), env);
        }
        throw invalidTypeException(key, getNameExpression(), env, "number, range, or string");
    }


    private Object dealWithNumericalKey(Object targetModel, 
                                               int index, 
                                               Environment env)
    {
        if (targetModel instanceof TemplateSequenceModel) {
            TemplateSequenceModel tsm = (TemplateSequenceModel) targetModel;
            int size = Integer.MAX_VALUE;
            try {
                size = tsm.size();
            } catch (Exception e) {}
            return index<size ? tsm.get(index) : null;
        } 
        try
        {
            String s = getTarget().getStringValue(env);
            try {
               return new StringModel(s.substring(index, index+1));
            } catch (RuntimeException re) {
                throw new TemplateException("", re, env);
            }
        }
        catch(NonStringException e)
        {
            throw invalidTypeException(targetModel, getTarget(), env, "number, sequence, or string");
        }
    }

    private Object dealWithStringKey(Object targetModel, 
                                            String key,
                                            Environment env)
    {
        if (targetModel instanceof Map) {
            return ((Map) targetModel).get(key);
        }
        if(targetModel instanceof TemplateHashModel) {
            return((TemplateHashModel) targetModel).get(key);
        }
        throw invalidTypeException(targetModel, getTarget(), env, "hash");
    }

    private Object dealWithRangeKey(Object targetModel, 
                                           Range range, 
                                           Environment env)
    {
        int start = EvaluationUtil.getNumber(range.getLeft(), env).intValue();
        int end = 0;
        boolean hasRhs = range.hasRhs();
        if (hasRhs) {
            end = EvaluationUtil.getNumber(range.getRight(), env).intValue();
        }
        if (targetModel instanceof TemplateSequenceModel) {
            TemplateSequenceModel sequence = (TemplateSequenceModel) targetModel;
            if (!hasRhs) end = sequence.size() -1;
            if (start < 0) {
                String msg = range.getRight().getStartLocation() + "\nNegative starting index for range, is " + range;
                throw new TemplateException(msg, env);
            }
            if (end < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative ending index for range, is " + range;
                throw new TemplateException(msg, env);
            }
            if (start >= sequence.size()) {
                String msg = range.getLeft().getStartLocation() 
                            + "\nLeft side index of range out of bounds, is " + start
                            + ", but the sequence has only " + sequence.size() + " element(s) "
                            + "(note that indices are 0 based, and ranges are inclusive).";
                throw new TemplateException(msg, env);
            }
            if (end >= sequence.size()) {
                String msg = range.getRight().getStartLocation() 
                             + "\nRight side index of range out of bounds, is " + end
                             + ", but the sequence has only " + sequence.size() + " element(s)."
                             + "(note that indices are 0 based, and ranges are inclusive).";
                throw new TemplateException(msg, env);
            }
            ArrayList<Object> list = new ArrayList<>(1+Math.abs(start-end));
            if (start>end) {
                for (int i = start; i>=end; i--) {
                    list.add(sequence.get(i));
                }
            }
            else {
                for (int i = start; i<=end; i++) {
                    list.add(sequence.get(i));
                }
            }
            return new ListModel(list);
        }
        
        try
        {
            String s = getTarget().getStringValue(env);
            if (!hasRhs) end = s.length() -1;
            if (start < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative starting index for range " + range + " : " + start;
                throw new TemplateException(msg, env);
            }
            if (end < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative ending index for range " + range + " : " + end;
                throw new TemplateException(msg, env);
            }
            if (start > s.length()) {
                String msg = range.getLeft().getStartLocation() 
                            + "\nLeft side of range out of bounds, is: " + start
                            + "\nbut string " + targetModel + " has " + s.length() + " elements.";
                throw new TemplateException(msg, env);
            }
            if (end > s.length()) {
                String msg = range.getRight().getStartLocation() 
                             + "\nRight side of range out of bounds, is: " + end
                             + "\nbut string " + targetModel + " is only " + s.length() + " characters.";
                throw new TemplateException(msg, env);
            }
            try {
                return new StringModel(s.substring(start, end+1));
            } catch (RuntimeException re) {
                String msg = "Error " + getStartLocation();
                throw new TemplateException(msg, re, env);
            }
        }
        catch(NonStringException e)
        {
            throw invalidTypeException(getTarget().evaluate(env), getTarget(), env, "number, scalar, or sequence");
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        DynamicKeyName result = new DynamicKeyName();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        result.add(getNameExpression().deepClone(name, subst));
        result.add(get(3));
        return result;
    }
}

/**
 * production for an arglist part of a method invocation.
 */
MethodCall MethodCall(Expression exp)# : 
{
     ArgsList args = new PositionalArgsList();
     Token end;
     pushNode(exp);
}
     <OPEN_PAREN>
     [
        args=ArgsList 
        {
            while (currentNodeScope.size() > 2) {
                currentNodeScope.remove(currentNodeScope.size()-1);
            }
            pushNode(args);
        }
     ]
     end=<CLOSE_PAREN>
     {
        return CURRENT_NODE;
     }
;

INJECT MethodCall :
    import java.util.ArrayList;
    import java.util.List;
    import java.io.Writer;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ObjectWrapper;
    import freemarker.template.*;
    import java.io.IOException;
    import java.io.StringWriter;
    import freemarker.core.ast.ArgsList;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.Macro;
    extends Expression;
{

    public ArgsList getArgs() {
        return firstChildOfType(ArgsList.class);
    }

    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public Object evaluate(Environment env) throws TemplateException
    {
        Object value = getTarget().evaluate(env);
        if (value instanceof TemplateMethodModel) {
            TemplateMethodModel targetMethod = (TemplateMethodModel)value;
            ArgsList args = getArgs();
            List argumentStrings = new ArrayList();
            if (args !=null) {
                argumentStrings = args.getParameterSequence(targetMethod, env);
            }
            Object result = targetMethod.exec(argumentStrings);
            return ObjectWrapper.instance().wrap(result);
        }
        else if (value instanceof Macro) {
            Macro func = (Macro) value;
            StringWriter sw = null;
            env.setLastReturnValue(null);
            Writer prevOut = env.getOut();
            try {
                env.setOut(Environment.NULL_WRITER);
                if (!func.isFunction()) {
                    sw = new StringWriter();
                    env.setOut(sw);
                 }
                env.render(func, getArgs(), null, null);
            } catch (IOException ioe) {
                throw new InternalError("This should be impossible.");
            } finally {
                env.setOut(prevOut);
            }
            return sw != null ? ObjectWrapper.instance().wrap(sw.getBuffer().toString()) : env.getLastReturnValue();
        }
        else {
            throw invalidTypeException(value, getTarget(), env, "method");
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        MethodCall result = new MethodCall();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        ArgsList args = getArgs();
        if (args != null) {
            result.add(getArgs().deepClone(name, subst));
            result.add(get(3));
        } else {
            result.add(get(2));
        }
        return result;
    }
}

Expression StringLiteral# :
{
  boolean raw = false;
}
   (
     <STRING_LITERAL>
     |
     <RAW_STRING> {raw = true;}
   )
   {
       String s = lastConsumedToken.toString();
       // Get rid of the quotes.
       s = s.substring(1, s.length() -1);
       if (raw) {
           s=s.substring(1);
       }
       else try {
          s = StringUtil.FTLStringLiteralDec(s);
       } catch (ParseException pe) {
       	  InvalidExpression invalid = new InvalidExpression("Malformed string literal: " + pe.getMessage());
       	  invalid.setLocation(template, token_source, lastConsumedToken, lastConsumedToken);
       	  return invalid;
       }
       CURRENT_NODE.setRaw(raw);
       CURRENT_NODE.setValue(s);
       return CURRENT_NODE;
   }
;

INJECT StringLiteral :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.parser.*;
   import freemarker.ext.beans.StringModel;
   import freemarker.core.ast.Expression;
   import freemarker.core.ast.TemplateElement;
   import java.io.*;
   extends Expression
{
    private TemplateElement interpolatedOutput;
    private String value;
    private boolean raw;

    public StringLiteral() {}
    
    public StringLiteral(String value, boolean raw) {
        this.value = value;
        this.raw = raw;
    }
    
    public boolean isRaw() {
    	return raw;
    }

    public void setRaw(boolean raw) {
        this.raw = raw;
    }
    
    public String getValue() {
    	return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
    
    public void checkInterpolation() {
    	String src = this.getSource();
        if (src.length() >5 && (src.indexOf("${") >= 0)) {
            FMLexer token_source = new FMLexer("input", value, FMLexer.LexicalState.DEFAULT, getBeginLine(), getBeginColumn() +1);
            token_source.setOnlyTextOutput(true);
            FMParser parser = new FMParser(token_source);
            parser.setTemplate(getTemplate());
            try {
                interpolatedOutput = parser.FreeMarkerText();
            }
            catch(ParseException e) {
                e.setTemplateName(getTemplate().getName());
                throw e;
            }
        }
    }
    
    public Object evaluate(Environment env) {
        return new StringModel(getStringValue(env));
        //return getStringValue(env);
    }

    public String getAsString() {
        return value;
    }
    
    public String getStringValue(Environment env) {
        if (interpolatedOutput == null) {
            return value;
        } 
        else {
            TemplateExceptionHandler teh = env.getTemplateExceptionHandler();
            env.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
            try {
               return env.renderElementToString(interpolatedOutput);
            }
            catch (IOException ioe) {
                throw new TemplateException(ioe, env);
            }
            finally {
                env.setTemplateExceptionHandler(teh);
            }
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        StringLiteral cloned = new StringLiteral(value, raw);
        cloned.interpolatedOutput = this.interpolatedOutput;
        return cloned;
    }
}

BooleanLiteral# :
   <FALSE>
   |
   <TRUE> {CURRENT_NODE.setValue(true);}
;

INJECT BooleanLiteral :
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    extends Expression
{
    @Property boolean value;

    public BooleanLiteral() {}
    public BooleanLiteral(boolean value) {this.value = value;}

    public boolean isTrue(Environment env) {
        return value;
    }

    public String toString() {
        return value ? "true" : "false";
    }

    public Boolean evaluate(Environment env) {
        return value;
    }

    public Expression _deepClone(String name, Expression subst) {
        BooleanLiteral result = new BooleanLiteral();
        result.setValue(value);
        return result;
    }

}

NullLiteral# :
   <NULL>
;

INJECT NullLiteral : 
   import freemarker.core.Environment;
   import freemarker.template.Constants;
   import freemarker.template.TemplateModel;
   import freemarker.core.ast.Expression;
   extends Expression
{
    public String toString() {
    	return "null";
    }

    public Object evaluate(Environment env) {
        return Constants.JAVA_NULL;
    }

    public Expression _deepClone(String name, Expression subst) {
    	return new NullLiteral();
    }
}

HashLiteral# :
{
   Expression key, value;
   ArrayList<Expression> keys = new ArrayList<>();
   ArrayList<Expression> values = new ArrayList<>();
}
   <OPEN_BRACE>
   [
       key=Expression
       <COLON>
       value=Expression
       {
          keys.add(key);
          values.add(value);
       }
       (
          <COMMA>
           key=Expression
           <COLON>
           value=Expression
           {
               keys.add(key);
               values.add(value);
           }
       )*
   ]
   <CLOSE_BRACE>
   {
      clearNodeScope();
      for (int i = 0; i<keys.size();i++) {
         pushNode(keys.get(i));
         pushNode(values.get(i));
      }
   }
;

INJECT HashLiteral :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ListModel;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.CollectionAndSequence;
    extends Expression
{
    private List<Expression> keys = new ArrayList<>();
    private List<Expression> values = new ArrayList<>();
    
    public void close() {
        boolean justSawKey = false;
        for (Expression exp : childrenOfType(Expression.class)) {
            if (justSawKey) values.add(exp);
            else keys.add(exp);
            justSawKey = !justSawKey;
       }
       assert keys.size() == values.size() : getSource();
    }
    
    public Object evaluate(Environment env) {
        return new SequenceHash(env);
    }
    
    public List<Expression> getKeys() {
    	return Collections.unmodifiableList(keys);
    }
    
    public List<Expression> getValues() {
    	return Collections.unmodifiableList(values);
    }

    public Expression _deepClone(String name, Expression subst) {
    	HashLiteral result = new HashLiteral();
        for (int i = 0; i< keys.size(); i++) {
            Expression keyClone = keys.get(i).deepClone(name, subst);
            Expression valueClone = values.get(i).deepClone(name, subst);
            result.keys.add(keyClone);
            result.values.add(valueClone);
        }
        result.close();
        return result;
    }

    private class SequenceHash implements TemplateHashModelEx {

        private HashMap<String, Object> keyMap  = new HashMap<>(); // maps keys to integer offset
        private TemplateCollectionModel keyCollection, valueCollection; // ordered lists of keys and values

        SequenceHash(Environment env) {
            ArrayList<String> keyList = new ArrayList<String>(keys.size());
            ArrayList<Object> valueList = new ArrayList<>(keys.size());
            for (int i = 0; i< keys.size(); i++) {
                Expression keyExp = keys.get(i);
                Expression valExp = values.get(i);
                String key = keyExp.getStringValue(env);
                Object value = valExp.evaluate(env);
                assertIsDefined(value, valExp, env);
                keyMap.put(key, value);
                keyList.add(key);
                valueList.add(value);
            }
            keyCollection = new CollectionAndSequence(new ListModel(keyList));
            valueCollection = new CollectionAndSequence(new ListModel(valueList));
        }

        public int size() {
            return keys.size();
        }

        public TemplateCollectionModel keys() {
            return keyCollection;
        }

        public TemplateCollectionModel values() {
            return valueCollection;
        }

        public Object get(String key) {
            return keyMap.get(key);
        }

        public boolean isEmpty() {
            return size() == 0;
        }
    }
}

