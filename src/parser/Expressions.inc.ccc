// This file defines the expression
// grammar. It is INCLUDEd from the main template.

#Expression :
{
	Expression exp;
}
	 exp=OrExpression {return exp;}
;

/**
 * Lowest level expression, a literal, a variable,
 * or a possibly more complex expression bounded
 * by parentheses.
 */
Expression PrimaryExpression :
{
   Expression exp;
}
   (
      exp=NumberLiteral
      |
      exp=HashLiteral
      |
      exp=StringLiteral
      |
      exp=BooleanLiteral
      |
      exp=NullLiteral
      |
      exp=ListLiteral
      |
      exp=Identifier
      |
      exp=ParentheticalExpression
      |
      exp=BuiltinVariable
  )
  (
      exp=DotVariable(exp)
      |
      exp=DynamicKey(exp)
      |
      exp=MethodArgs(exp)
      |
      exp=BuiltIn(exp)
      |
      exp=Exists(exp)
      |
      exp=DefaultTo(exp)
  )*
  {
     return exp;
  }
;

ParentheticalExpression# :
{
   Expression exp;
}
    <OPEN_PAREN> 
    exp=Expression 
    {
      clearNodeScope();
      pushNode(exp);
    }
    <CLOSE_PAREN>
;

INJECT ParentheticalExpression :
   import freemarker.core.Environment;
   import freemarker.core.ast.Expression;
   extends Expression
{
   public Expression getNested() {
        return firstChildOfType(Expression.class);
    }

    public boolean isTrue(Environment env) {
        return getNested().isTrue(env);
    }
    
    public Object getAsTemplateModel(Environment env) {
        return getNested().getAsTemplateModel(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        ParentheticalExpression result = new ParentheticalExpression();
        result.add(getNested().deepClone(name, subst));
        return result;
    }   
}

/**
 * A primary expression preceded by zero or
 * more unary operators. 
 */
Expression UnaryExpression :
{
   Expression result;
}
  (
   result=UnaryPlusMinusExpression
   |
   result=NotExpression
   |
   result=PrimaryExpression
  )
  {
     return result;
  }
;

Expression NotExpression : 
{
   Token t;
   Expression exp, result=null;
   List<Token> nots = new ArrayList<Token>();
}
   (
      t=<EXCLAM> {nots.add(t);}
   )+
   exp=PrimaryExpression 
   {
      for (int i=0; i<nots.size(); i++) {
         result = new NotExpression(exp);
         Token tok = nots.get(nots.size() -i -1);
         result.setLocation(template, token_source, tok, exp);
         exp = result;
      }
      return result;
   }
;

Expression UnaryPlusMinusExpression :
{
   Expression exp, result;
   boolean isMinus = false;
   Token t;
}
   (
      t=<PLUS>
      |
      t=<MINUS> {isMinus = true;}
   )
   exp=PrimaryExpression 
   {
      result = new UnaryPlusMinusExpression(exp, isMinus);  
      result.setLocation(template, token_source, t, exp);
      return result;
   }
;

Expression AdditiveExpression :
{
   Expression lhs, rhs, result;
   boolean plus;
}
   lhs=MultiplicativeExpression {result = lhs;}
   (
      (
         <PLUS> {plus = true;}
         |
         <MINUS> {plus = false;}
      )
      rhs=MultiplicativeExpression
      {
         if (plus) {
           // plus is treated separately, since it is also
           // used for concatenation.
             result = new AddConcatExpression(lhs, rhs);
         } 
         else {
             result = new ArithmeticExpression(lhs, rhs,
                                            ArithmeticExpression.SUBTRACTION);
         }
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;

/**
 * A unary expression followed by zero or more
 * unary expressions with operators in between.
 */
Expression MultiplicativeExpression :
{
   Expression lhs, rhs, result;
   int operation = ArithmeticExpression.MULTIPLICATION;
}
   lhs=UnaryExpression {result = lhs;}
   (
      (
         <TIMES> {operation = ArithmeticExpression.MULTIPLICATION;}
         |
         <DIVIDE> {operation = ArithmeticExpression.DIVISION;}
         |
         <PERCENT>{operation = ArithmeticExpression.MODULUS;}
      )
      rhs=UnaryExpression
      {
         result = new ArithmeticExpression(lhs, rhs, operation);
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;


Expression EqualityExpression :
{
   Expression lhs, rhs, result;
   Token t;
}
   lhs=RelationalExpression {result = lhs;}
   [
     (
      t=<NOT_EQUALS> 
      |
      t=<EQUALS> 
      |
      t=<DOUBLE_EQUALS>
     )
     rhs=RelationalExpression
     {
        result = new ComparisonExpression(lhs, rhs, t.toString());
        result.setLocation(template, token_source, lhs, rhs);
     }
   ]
   {
      return result;
   }
;

Expression RelationalExpression :
{
   Expression lhs, rhs, result;
   Token t;
}
   lhs=RangeExpression {result = lhs;}
   [
     (
      t=<GREATER_THAN_EQUALS>
      |
      t=<ESCAPED_GTE>
      |
      t=<GREATER_THAN>
      |
      t=<ESCAPED_GT>
      |
      t=<LESS_THAN_EQUALS>
      |
      t=<LESS_THAN>
     )
     rhs=RangeExpression
     {
        result = new ComparisonExpression(lhs, rhs, t.toString());
        result.setLocation(template, token_source, lhs, rhs);
     }
   ]
   {
      return result;
   }
;

Expression RangeExpression :
{
   Expression lhs, rhs=null, result;
}
    lhs=AdditiveExpression {result = lhs;}
    [
      <DOT_DOT>
       [ rhs=AdditiveExpression =>|| 
       ]
       {
           Range range = new Range(lhs, rhs);
           if (rhs != null) {
               range.setLocation(template, token_source, lhs, rhs);
           } else {
              range.setLocation(template, token_source, lhs, lhs);
           }
           result = range;
        }
    ]
    {
        return result;
    }
;

Expression AndExpression :
{
   Expression lhs, rhs, result;
}
   lhs=EqualityExpression {result = lhs;}
   (
      <AND>
      rhs=EqualityExpression
      {
         result = new AndExpression(lhs, rhs);
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;

Expression OrExpression :
{
   Expression lhs, rhs, result;
}
   lhs=AndExpression {result = lhs;}
   (
      <OR>
      rhs=AndExpression
      {
         result = new OrExpression(lhs, rhs);
         result.setLocation(template, token_source, lhs, rhs);
         lhs = result;
      }
   )*
   {
      return result;
   }
;

#ListLiteral#(false) :
{
   Expression exp;
   ArrayList<Expression> values = new ArrayList<Expression>();
   Token begin, end;
}
    begin=<OPEN_BRACKET>
    [
      exp=Expression {values.add(exp);}
      (
         <COMMA>
         exp=Expression {values.add(exp);}
      )*
    ]
    end=<CLOSE_BRACKET>
    {
        CURRENT_NODE.setLocation(template, token_source, begin, end);
        CURRENT_NODE.addAll(values);
        return CURRENT_NODE;
    }
;

INJECT ListLiteral :
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  import freemarker.core.Environment;
  import freemarker.core.TemplateNamespace;
  import freemarker.ext.beans.ListModel;
  import freemarker.template.TemplateException;
  import freemarker.template.*;
  import freemarker.core.ast.Expression;
  extends Expression
{
    public List<Expression> getElements() {
        return childrenOfType(Expression.class);
    }
    
    public Object getAsTemplateModel(Environment env) {
        ListModel list = new ListModel();
        for (Expression exp: getElements()) {
            Object tm = exp.getAsTemplateModel(env);
            assertIsDefined(tm, exp, env);
            list.add(tm);
        }
        return list;
    }

    // A hacky routine used by VisitNode and RecurseNode
    
    public TemplateSequenceModel evaluateStringsToNamespaces(Environment env) {
        ListModel result = new ListModel();
        for (Expression exp : getElements()) {
            if (exp instanceof StringLiteral) {
                String s = ((StringLiteral) exp).getAsString();
                try {
                    TemplateNamespace ns = env.importLib(s, null);
                    result.add(ns);
                } 
                catch (IOException ioe) {
                    throw new TemplateException("Could not import library '" + s + "', " + ioe.getMessage(), env); 
                }
            }
            else {
                result.add(exp);
            }
        }
        return result;
    }
    
    public Expression _deepClone(String name, Expression subst) {
    	ArrayList<Expression> clonedValues = new ArrayList<Expression>(size());
    	for (Expression exp : getElements()) {
    		clonedValues.add(exp.deepClone(name, subst));
    	}
      ListLiteral ll = new ListLiteral();
      ll.addAll(clonedValues);
      return ll;
    }
}

NumberLiteral# :
   (
      <INTEGER>
      |
      <DECIMAL>
   )
   {
       String s = lastConsumedToken.toString();
       Number n = template != null ? template.getArithmeticEngine().toNumber(s) : new java.math.BigDecimal(s);
       CURRENT_NODE.setValue(n);
   }
;

INJECT NumberLiteral :
  import freemarker.core.Environment;
  import freemarker.core.ast.Expression;
  import freemarker.template.*;
  import freemarker.ext.beans.NumberModel;
  extends Expression
{
    @Property Number value;

    public NumberLiteral() {}

    public NumberLiteral(Number value) {
        this.value = value;
    }
    
    public TemplateModel getAsTemplateModel(Environment env) {
        return new NumberModel(value);
    }
    
    public String getStringValue(Environment env) {
        return env.formatNumber(value);
    }

    public Number getAsNumber() {
        return value;
    }
    
    String getName() {
        return "the number: '" + value + "'";
    }

    public Expression _deepClone(String name, Expression subst) {
        return new NumberLiteral(value);
    }
}

Identifier# :
   <ID> 
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   } 
;

INJECT Identifier :
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.ast.Expression;
    extends Expression
{
    @Property String name;

    public Identifier() {}

    public Identifier(String name) {
        this.name = name;
    }
    
    public Object getAsTemplateModel(Environment env) {
        try {
            return env.getVariable(name);
        } catch (NullPointerException e) {
            if (env == null) {
                throw new TemplateException("Variables are not available "
                + "(certainly you are in a parse-time executed directive). The name of the variable "
                + "you tried to read: " + name, null);
            } else {
                throw e;
            }
        }
    }

    public String toString() {
        return name;
    }

    public Expression _deepClone(String name, Expression subst) {
        if(this.name.equals(name)) {
        	return subst.deepClone(null, null);
        }
        return new Identifier(this.name);
    }
}

Expression IdentifierOrStringLiteral :
{
   Expression exp;
}
   (
      exp=Identifier
      |
      exp=StringLiteral
   )
   {
      return exp;
   }   
;

BuiltinVariable# :
   <DOT>
   <ID>
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   }
;

INJECT BuiltinVariable :
    import freemarker.template.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ParseException;
    import freemarker.ext.beans.StringModel;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.Macro;
    extends Expression
{
    private String name;

    public void setName(String name) {
      this.name = name.intern();
    }
    
    public String getName() {
        return name;
    }

    public Object getAsTemplateModel(Environment env) {
        switch (name) {
           case "namespace" : return env.getCurrentNamespace();
           case "main" : return env.getMainNamespace();
           case "globals" : return env;
           case "locals" : return env.getCurrentMacroContext();
           case "data_model" : return env.getDataModel();
           case "scope" : return env.getCurrentScope();
           case "vars" : return new VarsHash(env);
           case "locale" : return new StringModel(env.getLocale().toString());
           case "lang" : return new StringModel(env.getLocale().getLanguage());
           case "current_node" :
           case "node" : return env.getCurrentVisitorNode();
           case "pass" : return Macro.DO_NOTHING_MACRO;
           case "name" : return new StringModel(env.getTemplate().getName()); 
           case "version" : return new StringModel(Configuration.getVersionNumber());
           case "output_encoding" : String s = env.getOutputEncoding();
                                    return s != null ? new StringModel(s) : null;
           case "url_escaping_charset" : s = env.getURLEscapingCharset();
                                         return s != null ? new StringModel(s) : null;
           case "error" : return new StringModel(env.getCurrentRecoveredErrorMessage());
        }
        throw new TemplateException("Invalid built-in variable: " + this, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        return this;
    }

    static class VarsHash implements TemplateHashModel {
        
        private final Environment env;
        
        VarsHash(Environment env) {
            this.env = env;
        }
        
        public Object get(String key) {
            return env.getVariable(key);
        }
        
        public boolean isEmpty() {
            return false;
        }
    }
}

Expression DefaultTo(Expression exp) :
{
   Expression rhs = null;
   Token t;
}
   (
       t=<EXCLAM>
       [
         SCAN {getToken(1).getType() != TokenType.ID || getToken(2).getType() != TokenType.EQUALS}
         => rhs=PrimaryExpression =>|| 
       ]
   )
   {
      DefaultToExpression result = new DefaultToExpression(exp, rhs);
      if (rhs ==null) {
          result.setLocation(template, token_source, exp, t);
      }
      else {
          result.setLocation(template, token_source, exp, rhs);
      }
      return result;
   }
;

Expression Exists(Expression exp) :
{
   Token t;
}
   t=<EXISTS>
   {
       ExistsExpression result = new ExistsExpression(exp);
       result.setLocation(template, token_source, exp, t);
       return result;
   }
;

Expression BuiltIn(Expression exp) :
{
   Token t=null;
}
   <BUILT_IN>
   t=<ID>
   {
   	   BuiltInExpression result = new BuiltInExpression(exp, t.toString());
         if (result.getBuiltIn() == null) {
            fail("Unknown builtin ",t);
           //throw new ParseException(this, "Unknown builtin " + t.toString());
         }
   	   result.setLocation(template, token_source, exp, t);
   	   return result;
   }
;

/**
 * production for when a key is specified by <DOT> + keyname
 */
Expression DotVariable(Expression exp) :
{
     Token t;
}
     <DOT>{token_source.justAfterDot = true;}
     t=<ID>{token_source.justAfterDot = false;}
     {
         Dot dot = new Dot(exp, t.toString());
         dot.setLocation(template, token_source, exp, t);
         return dot;
     }
;

/**
 * production for when the key is specified
 * in brackets.
 */
Expression DynamicKey(Expression exp) :
{
   Expression arg;
   Token t;
}
   <OPEN_BRACKET>
   arg=Expression
   t=<CLOSE_BRACKET>
   {
       DynamicKeyName dkn = new DynamicKeyName(exp, arg);
       dkn.setLocation(template, token_source, exp, t);
       return dkn;
   }
;

/**
 * production for an arglist part of a method invocation.
 */
MethodCall MethodArgs(Expression exp) :
{
     ArgsList args = new PositionalArgsList();
     Token end;
}
     <OPEN_PAREN>
     [args=ArgsList]
     end=<CLOSE_PAREN>
     {
        MethodCall result = new MethodCall(exp, args);
        result.setLocation(template, token_source, exp, end);
	     args.setLocationInfoIfAbsent(result);        
        return result;
     }
;

Expression StringLiteral# :
{
  boolean raw = false;
}
   (
     <STRING_LITERAL>
     |
     <RAW_STRING> {raw = true;}
   )
   {
       String s = lastConsumedToken.toString();
       // Get rid of the quotes.
       s = s.substring(1, s.length() -1);
       if (raw) {
           s=s.substring(1);
       }
       else try {
          s = StringUtil.FTLStringLiteralDec(s);
       } catch (ParseException pe) {
       	  InvalidExpression invalid = new InvalidExpression("Malformed string literal: " + pe.getMessage());
       	  invalid.setLocation(template, token_source, lastConsumedToken, lastConsumedToken);
       	  return invalid;
       }
       CURRENT_NODE.setRaw(raw);
       CURRENT_NODE.setValue(s);
       return CURRENT_NODE;
   }
;

INJECT StringLiteral :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.parser.*;
   import freemarker.ext.beans.StringModel;
   import freemarker.core.ast.Expression;
   import freemarker.core.ast.TemplateElement;
   import java.io.*;
   extends Expression
{
    private TemplateElement interpolatedOutput;
    private String value;
    private boolean raw;

    public StringLiteral() {}
    
    public StringLiteral(String value, boolean raw) {
        this.value = value;
        this.raw = raw;
    }
    
    public boolean isRaw() {
    	return raw;
    }

    public void setRaw(boolean raw) {
        this.raw = raw;
    }
    
    public String getValue() {
    	return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
    
    public void checkInterpolation() {
    	String src = this.getSource();
        if (src.length() >5 && (src.indexOf("${") >= 0)) {
            FMLexer token_source = new FMLexer("input", value, FMLexer.LexicalState.DEFAULT, getBeginLine(), getBeginColumn() +1);
            token_source.setOnlyTextOutput(true);
            FMParser parser = new FMParser(token_source);
            parser.setTemplate(getTemplate());
            try {
                interpolatedOutput = parser.FreeMarkerText();
            }
            catch(ParseException e) {
                e.setTemplateName(getTemplate().getName());
                throw e;
            }
        }
    }
    
    public Object getAsTemplateModel(Environment env) {
        return new StringModel(getStringValue(env));
    }

    public String getAsString() {
        return value;
    }
    
    public String getStringValue(Environment env) {
        if (interpolatedOutput == null) {
            return value;
        } 
        else {
            TemplateExceptionHandler teh = env.getTemplateExceptionHandler();
            env.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
            try {
               return env.renderElementToString(interpolatedOutput);
            }
            catch (IOException ioe) {
                throw new TemplateException(ioe, env);
            }
            finally {
                env.setTemplateExceptionHandler(teh);
            }
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        StringLiteral cloned = new StringLiteral(value, raw);
        cloned.interpolatedOutput = this.interpolatedOutput;
        return cloned;
    }
}

BooleanLiteral# :
   <FALSE>
   |
   <TRUE> {CURRENT_NODE.setValue(true);}
;

INJECT BooleanLiteral :
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    extends Expression
{
    @Property boolean value;

    public BooleanLiteral() {}
    public BooleanLiteral(boolean value) {this.value = value;}

    public boolean isTrue(Environment env) {
        return value;
    }

    public String toString() {
        return value ? "true" : "false";
    }

    public Object getAsTemplateModel(Environment env) {
        return value ? TemplateBooleanModel.TRUE : TemplateBooleanModel.FALSE;
    }

    public Expression _deepClone(String name, Expression subst) {
        BooleanLiteral result = new BooleanLiteral();
        result.setValue(value);
        return result;
    }

}

NullLiteral# :
   <NULL>
;

INJECT NullLiteral : 
   import freemarker.core.Environment;
   import freemarker.template.Constants;
   import freemarker.template.TemplateModel;
   import freemarker.core.ast.Expression;
   extends Expression
{
    public String toString() {
    	return "null";
    }

    public Object getAsTemplateModel(Environment env) {
        return Constants.JAVA_NULL;
    }

    public Expression _deepClone(String name, Expression subst) {
    	return new NullLiteral();
    }
}

HashLiteral# :
{
   Expression key, value;
   ArrayList<Expression> keys = new ArrayList<>();
   ArrayList<Expression> values = new ArrayList<>();
}
   <OPEN_BRACE>
   [
       key=Expression
       <COLON>
       value=Expression
       {
          keys.add(key);
          values.add(value);
       }
       (
          <COMMA>
           key=Expression
           <COLON>
           value=Expression
           {
               keys.add(key);
               values.add(value);
           }
       )*
   ]
   <CLOSE_BRACE>
   {
      clearNodeScope();
      for (int i = 0; i<keys.size();i++) {
         pushNode(keys.get(i));
         pushNode(values.get(i));
      }
   }
;

INJECT HashLiteral :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ListModel;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.CollectionAndSequence;
    extends Expression
{
    private List<Expression> keys = new ArrayList<>();
    private List<Expression> values = new ArrayList<>();
    
    public void close() {
        boolean justSawKey = false;
        for (Expression exp : childrenOfType(Expression.class)) {
            if (justSawKey) values.add(exp);
            else keys.add(exp);
            justSawKey = !justSawKey;
       }
       assert keys.size() == values.size() : getSource();
    }
    
    public Object getAsTemplateModel(Environment env) {
        return new SequenceHash(env);
    }
    
    public List<Expression> getKeys() {
    	return Collections.unmodifiableList(keys);
    }
    
    public List<Expression> getValues() {
    	return Collections.unmodifiableList(values);
    }

    public Expression _deepClone(String name, Expression subst) {
    	HashLiteral result = new HashLiteral();
        for (int i = 0; i< keys.size(); i++) {
            Expression keyClone = keys.get(i).deepClone(name, subst);
            Expression valueClone = values.get(i).deepClone(name, subst);
            result.keys.add(keyClone);
            result.values.add(valueClone);
        }
        result.close();
        return result;
    }

    private class SequenceHash implements TemplateHashModelEx {

        private HashMap<String, Object> keyMap  = new HashMap<>(); // maps keys to integer offset
        private TemplateCollectionModel keyCollection, valueCollection; // ordered lists of keys and values

        SequenceHash(Environment env) {
            ArrayList<String> keyList = new ArrayList<String>(keys.size());
            ArrayList<Object> valueList = new ArrayList<>(keys.size());
            for (int i = 0; i< keys.size(); i++) {
                Expression keyExp = keys.get(i);
                Expression valExp = values.get(i);
                String key = keyExp.getStringValue(env);
                Object value = valExp.getAsTemplateModel(env);
                assertIsDefined(value, valExp, env);
                keyMap.put(key, value);
                keyList.add(key);
                valueList.add(value);
            }
            keyCollection = new CollectionAndSequence(new ListModel(keyList));
            valueCollection = new CollectionAndSequence(new ListModel(valueList));
        }

        public int size() {
            return keys.size();
        }

        public TemplateCollectionModel keys() {
            return keyCollection;
        }

        public TemplateCollectionModel values() {
            return valueCollection;
        }

        public Object get(String key) {
            return keyMap.get(key);
        }

        public boolean isEmpty() {
            return size() == 0;
        }
    }
}

