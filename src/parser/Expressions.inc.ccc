// This file defines the expression
// grammar. It is INCLUDEd from the main template.

#Expression :
{
	Expression exp;
}
	 exp=OrExpression {return exp;}
;

/**
 * Lowest level expression, a literal, a variable,
 * or a possibly more complex expression bounded
 * by parentheses.
 */
Expression PrimaryExpression :
{
   Expression exp;
}
   (
      exp=NumberLiteral
      |
      exp=HashLiteral
      |
      exp=StringLiteral
      |
      exp=BooleanLiteral
      |
      exp=NullLiteral
      |
      exp=ListLiteral
      |
      exp=Identifier
      |
      exp=ParentheticalExpression
      |
      exp=BuiltinVariable
  )
  (
      exp=DotVariable(exp)
      |
      exp=DynamicKeyName(exp)
      |
      exp=MethodCall(exp)
      |
      exp=BuiltInExpression(exp)
      |
      exp=ExistsExpression(exp)
      |
      exp=DefaultToExpression(exp)
  )*
  {
     return exp;
  }
;

ParentheticalExpression# :
{
   Expression exp;
}
    <OPEN_PAREN> 
    exp=Expression 
    {
      clearNodeScope();
      pushNode(exp);
    }
    <CLOSE_PAREN>
;

INJECT ParentheticalExpression :
   import freemarker.core.Environment;
   import freemarker.core.ast.Expression;
   extends Expression
{
   public Expression getNested() {
        return firstChildOfType(Expression.class);
    }

    public boolean isTrue(Environment env) {
        return getNested().isTrue(env);
    }
    
    public Object evaluate(Environment env) {
        return getNested().evaluate(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        ParentheticalExpression result = new ParentheticalExpression();
        result.add(getNested().deepClone(name, subst));
        return result;
    }   
}

/**
 * A primary expression preceded (optionally)
 * by a unary operator
 */
Expression UnaryExpression :
{
   Expression result;
}
  (
   result=UnaryPlusMinusExpression
   |
   result=NotExpression
   |
   result=PrimaryExpression
  )
  {
     return result;
  }
;

NotExpression# : 
{
    Expression exp;
}
   <EXCLAM> 
   (
      exp=PrimaryExpression 
      |
      exp=NotExpression
   )
   {
      while (currentNodeScope.size()>1) {
         currentNodeScope.remove(currentNodeScope.size()-1);
      }
      pushNode(exp);
   }
;

INJECT NotExpression :
    import freemarker.core.Environment;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.BooleanExpression;
    extends BooleanExpression
{
    public Expression getTarget() {
        return (Expression) get(1);
    }

    public boolean isTrue(Environment env) {
        return (!getTarget().isTrue(env));
    }

    public Expression _deepClone(String name, Expression subst) {
        NotExpression result = new NotExpression();
    	result.add(getTarget().deepClone(name, subst));
        return result;
    }
}

UnaryPlusMinusExpression# :
 {Expression exp;}
   (
      <PLUS>
      |
      <MINUS>
   )
   (
      exp=UnaryPlusMinusExpression
      |
      exp=PrimaryExpression
   )
   {
      while (currentNodeScope.size()>1) {
         currentNodeScope.remove(currentNodeScope.size()-1);
      }
      pushNode(exp);
   } 
;

INJECT UnaryPlusMinusExpression : 
    import freemarker.core.Environment;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.ArithmeticEngine;
    import freemarker.core.ast.NonNumericalException;
    import freemarker.template.*;
    import static freemarker.ext.beans.ObjectWrapper.asNumber;
    extends Expression
{
    private static final Integer MINUS_ONE = Integer.valueOf(-1); 

    public Expression getTarget() {
    	return firstChildOfType(Expression.class);
    }
    
    public boolean isMinus() {
    	return get(0).getType()==MINUS;
    }
    
    public Object evaluate(Environment env) {
        Number value = null;
        try {
            value = asNumber(getTarget().evaluate(env));
        } catch (ClassCastException cce) {
            String msg = "Error " + getStartLocation();
            msg += "\nExpression " + getTarget() + " is not numerical.";
            throw new NonNumericalException(msg, env);
        }
        if (!isMinus()) {
            return value;
        }
        return ArithmeticEngine.CONSERVATIVE_ENGINE.multiply(MINUS_ONE, value);
    }

    public Expression _deepClone(String name, Expression subst) {
        UnaryPlusMinusExpression result = new UnaryPlusMinusExpression();
        result.add(get(0));
        result.add(getTarget().deepClone(name,subst));
        return result;
    }
}

Expression AdditiveExpression#(>1) :
{
   Expression lhs, rhs, result;
   boolean plus;
}
   lhs=MultiplicativeExpression {result = lhs;}
   {
      result = lhs;
      currentNodeScope.clear();
      pushNode(lhs);
   }
   [
      (
         <PLUS> {plus = true;}
         |
         <MINUS> {plus = false;}
      )
      rhs=AdditiveExpression
      {
         while (nodeArity() > 2) popNode();
         pushNode(rhs);
      }
   ]
   {
      if (nodeArity()>1) {
        result = (Expression) CURRENT_NODE;
      }
      return result;
   }
;

INJECT AdditiveExpression : //THIS NEEDS TO BE SIMPLIFIED!
   import java.util.*;
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.ast.ArithmeticEngine;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.core.ast.Expression;
   import static freemarker.ext.beans.ObjectWrapper.isNumber;   
   import static freemarker.ext.beans.ObjectWrapper.isList;   
   import static freemarker.ext.beans.ObjectWrapper.asString;   
   extends Expression
{
    public boolean isPlus() {
        return get(1).getType() == PLUS;
    }

    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        Object left = getLeft().evaluate(env);
        Object right = getRight().evaluate(env);
        ArithmeticEngine ae = 
            env != null 
                ? env.getArithmeticEngine()
                : getTemplate().getArithmeticEngine();        
        if (!isPlus()) {
            Number first = EvaluationUtil.getNumber(left, getLeft(), env);
            Number second = EvaluationUtil.getNumber(right, getRight(), env);
            return ae.subtract(first, second);
        }
        boolean bothAreNumbers = isNumber(left) && isNumber(right);
        if (bothAreNumbers) {
            Number first = EvaluationUtil.getNumber(left, getLeft(), env);
            Number second = EvaluationUtil.getNumber(right, getRight(), env);
            return ae.add(first, second);
        }
        if (isList(left) && isList(right)) {
            /*List merged = new ArrayList(asList(leftModel));
            merged.addAll(asList(rightModel));
            return merged;*/
            return new ConcatenatedSequence((TemplateSequenceModel)left, (TemplateSequenceModel)right);            
        }
        if (isDisplayableAsString(left) && isDisplayableAsString(right)) {
            String s1 = getStringValue(left, getLeft(), env);
            if(s1 == null) s1 = "null";
            String s2 = getStringValue(right, getRight(), env);
            if(s2 == null) s2 = "null";
            return s1.concat(s2);
        }
        if (left instanceof TemplateHashModel && right instanceof TemplateHashModel) {
            if (left instanceof TemplateHashModelEx && right instanceof TemplateHashModelEx) {
                TemplateHashModelEx leftModelEx = (TemplateHashModelEx)left;
                TemplateHashModelEx rightModelEx = (TemplateHashModelEx)right;
                if (leftModelEx.size() == 0) {
                    return rightModelEx;
                } else if (rightModelEx.size() == 0) {
                    return leftModelEx;
                } else {
                    return new ConcatenatedHashEx(leftModelEx, rightModelEx);
                }
            } else {
                return new ConcatenatedHash((TemplateHashModel)left,
                                            (TemplateHashModel)right);
            }
        }
        String msg = this.getStartLocation() + ": Cannot add or concatenate";
        throw new TemplateException(msg, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        AdditiveExpression result = new AdditiveExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    	//return new AddConcatExpression(getLeft().deepClone(name, subst), getRight().deepClone(name, subst));
    }

    private static final class ConcatenatedSequence implements TemplateSequenceModel
    {
        private final TemplateSequenceModel left;
        private final TemplateSequenceModel right;

        ConcatenatedSequence(TemplateSequenceModel left, TemplateSequenceModel right)
        {
            this.left = left;
            this.right = right;
        }

        public int size() {
            return left.size() + right.size();
        }

        public Object get(int i) {
            int ls = left.size();
            return i < ls ? left.get(i) : right.get(i - ls);
        }
    }

    private static class ConcatenatedHash implements TemplateHashModel {
        final TemplateHashModel left;
        final TemplateHashModel right;

        ConcatenatedHash(TemplateHashModel left, TemplateHashModel right)
        {
            this.left = left;
            this.right = right;
        }
        
        public Object get(String key)
        {
            Object model = right.get(key);
            return (model != null) ? model : left.get(key);
        }

        public boolean isEmpty()
        {
            return left.isEmpty() && right.isEmpty();
        }
    }

    private static final class ConcatenatedHashEx extends ConcatenatedHash implements TemplateHashModelEx
    {
        private Iterable<String> keys;
        private Iterable<Object> values;
        private int size;

        ConcatenatedHashEx(TemplateHashModelEx left, TemplateHashModelEx right)
        {
            super(left, right);
        }
        
        public int size() throws TemplateModelException
        {
            initKeys();
            return size;
        }

        public Iterable keys()
        {
            initKeys();
            return keys;
        }

        public Iterable values()
        {
            initValues();
            return values;
        }

        private void initKeys()
        {
            if (keys == null) {
                HashSet<String> keySet = new HashSet<String>();
                List<String> keySeq = new ArrayList<>();
                addKeys(keySet, keySeq, (TemplateHashModelEx)this.left);
                addKeys(keySet, keySeq, (TemplateHashModelEx)this.right);
                size = keySet.size();
                keys = keySeq;
            }
        }

        private static void addKeys(Set<String> set, List<String> keySeq, TemplateHashModelEx hash)
        throws TemplateModelException
        {
            Iterator<?> it = hash.keys().iterator();
            while (it.hasNext()) {
                String s = asString(it.next());
                if (set.add(s)) {
                    // The first occurence of the key decides the index;
                    // this is consisten with stuff like java.util.LinkedHashSet.
                    keySeq.add(s);
                }
            }
        }        

        private void initValues() {
            if (values == null) {
                List<Object> seq = new ArrayList<>();
                for (String key : keys) {
                    seq.add(get(key));
                }
                values = seq;
            }
        }
    }
}

/**
 * A unary expression followed by zero or more
 * unary expressions with multiplicative 
 * operators in between.
 */
Expression MultiplicativeExpression#(>1) :
{
    Expression lhs, rhs, result;
}
   lhs = UnaryExpression 
   {
    result = lhs;
    currentNodeScope.clear();
    pushNode(lhs);
   }
   [
      (
         <TIMES>
         |
         <DIVIDE>
         |
         <PERCENT>
      )
      rhs=MultiplicativeExpression
      {
         while (nodeArity() > 2) popNode();
         pushNode(rhs);
      }
   ]
   {
      if (nodeArity()>1) {
        result = (Expression) CURRENT_NODE;
      }
      return result;
   }
;

INJECT MultiplicativeExpression :
   import freemarker.template.TemplateException;
   import freemarker.core.Environment;
   import freemarker.core.ast.ArithmeticEngine;
   import freemarker.core.ast.EvaluationUtil;
   import freemarker.core.ast.Expression;
   import freemarker.core.ast.NonNumericalException;
   import static freemarker.ext.beans.ObjectWrapper.isNumber;
   extends freemarker.core.ast.Expression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }
    
    public TokenType getOperation() {
        return (TokenType) get(1).getType();
    }

//    public void setOperation(int operation) {
//        this.operation = operation;
//    }
    
    public Object evaluate(Environment env) throws TemplateException 
    {
        Object leftModel = getLeft().evaluate(env);
        Object rightModel = getRight().evaluate(env);
        boolean leftIsNumber = isNumber(leftModel);
        boolean rightIsNumber = isNumber(rightModel);
        boolean bothNumbers = leftIsNumber && rightIsNumber;
        if (!bothNumbers) {
            String msg = "Error " + getStartLocation();
            if (!leftIsNumber) {
                msg += "\nExpression " + getLeft() + " is not numerical";
            }
            if (!rightIsNumber) {
                msg += "\nExpression " + getRight() + " is not numerical";
            }
            throw new NonNumericalException(msg, env);
        }
        Number first = EvaluationUtil.getNumber(leftModel, getLeft(), env);
        Number second = EvaluationUtil.getNumber(rightModel, getRight(), env);
        ArithmeticEngine ae = 
            env != null 
                ? env.getArithmeticEngine()
                : getTemplate().getArithmeticEngine();
        switch (getOperation()) {
            case TIMES :
                return ae.multiply(first, second);
            case DIVIDE :
                return ae.divide(first, second);
            case PERCENT :
                return ae.modulus(first, second);
            default:
                throw new TemplateException("unknown operation : " + getOperation(), env);
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        MultiplicativeExpression result = new MultiplicativeExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}


Expression EqualityExpression :
{
   Expression lhs, rhs, result;
   Token t;
}
   lhs=RelationalExpression {result = lhs;}
   [
     (
      t=<NOT_EQUALS> 
      |
      t=<EQUALS> 
      |
      t=<DOUBLE_EQUALS>
     )
     rhs=RelationalExpression
     {
        result = new ComparisonExpression(lhs, rhs, t.toString());
        result.setLocation(template, token_source, lhs, rhs);
     }
   ]
   {
      return result;
   }
;

Expression RelationalExpression :
{
   Expression lhs, rhs, result;
   Token t;
}
   lhs=RangeExpression {result = lhs;}
   [
     (
      t=<GREATER_THAN_EQUALS>
      |
      t=<ESCAPED_GTE>
      |
      t=<GREATER_THAN>
      |
      t=<ESCAPED_GT>
      |
      t=<LESS_THAN_EQUALS>
      |
      t=<LESS_THAN>
     )
     rhs=RangeExpression
     {
        result = new ComparisonExpression(lhs, rhs, t.toString());
        result.setLocation(template, token_source, lhs, rhs);
     }
   ]
   {
      return result;
   }
;

Expression RangeExpression :
{
   Expression lhs, rhs=null, result;
}
    lhs=AdditiveExpression {result = lhs;}
    [
      <DOT_DOT>
       [ rhs=AdditiveExpression =>|| 
       ]
       {
           Range range = new Range(lhs, rhs);
           if (rhs != null) {
               range.setLocation(template, token_source, lhs, rhs);
           } else {
              range.setLocation(template, token_source, lhs, lhs);
           }
           result = range;
        }
    ]
    {
        return result;
    }
;

Expression AndExpression :
{
   Expression lhs, rhs, result;
}
   lhs=EqualityExpression {result = lhs;}
   [
      <AND>
      rhs=AndExpression
      {
         result = new AndExpression(lhs, rhs);
         result.setLocation(template, token_source, lhs, rhs);
      }
   ]
   {
      return result;
   }
;


Expression OrExpression :
{
   Expression lhs, rhs, result;
}
   lhs=AndExpression {result = lhs;}
   [
      <OR>
      rhs=OrExpression
      {
         result = new OrExpression(lhs, rhs);
         result.setLocation(template, token_source, lhs, rhs);
      }
   ]
   {
      return result;
   }
;

#ListLiteral#(false) :
{
   Expression exp;
   ArrayList<Expression> values = new ArrayList<Expression>();
   Token begin, end;
}
    begin=<OPEN_BRACKET>
    [
      exp=Expression {values.add(exp);}
      (
         <COMMA>
         exp=Expression {values.add(exp);}
      )*
    ]
    end=<CLOSE_BRACKET>
    {
        CURRENT_NODE.setLocation(template, token_source, begin, end);
        CURRENT_NODE.addAll(values);
        return CURRENT_NODE;
    }
;

INJECT ListLiteral :
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  import freemarker.core.Environment;
  import freemarker.core.TemplateNamespace;
  import freemarker.ext.beans.ListModel;
  import freemarker.template.TemplateException;
  import freemarker.template.*;
  import freemarker.core.ast.Expression;
  extends Expression
{
    public List<Expression> getElements() {
        return childrenOfType(Expression.class);
    }
    
    public Object evaluate(Environment env) {
        ListModel list = new ListModel();
        for (Expression exp: getElements()) {
            Object tm = exp.evaluate(env);
            assertIsDefined(tm, exp, env);
            list.add(tm);
        }
        return list;
    }

    // A hacky routine used by VisitNode and RecurseNode
    
    public TemplateSequenceModel evaluateStringsToNamespaces(Environment env) {
        ListModel result = new ListModel();
        for (Expression exp : getElements()) {
            if (exp instanceof StringLiteral) {
                String s = ((StringLiteral) exp).getAsString();
                try {
                    TemplateNamespace ns = env.importLib(s, null);
                    result.add(ns);
                } 
                catch (IOException ioe) {
                    throw new TemplateException("Could not import library '" + s + "', " + ioe.getMessage(), env); 
                }
            }
            else {
                result.add(exp);
            }
        }
        return result;
    }
    
    public Expression _deepClone(String name, Expression subst) {
    	ArrayList<Expression> clonedValues = new ArrayList<Expression>(size());
    	for (Expression exp : getElements()) {
    		clonedValues.add(exp.deepClone(name, subst));
    	}
      ListLiteral ll = new ListLiteral();
      ll.addAll(clonedValues);
      return ll;
    }
}

NumberLiteral# :
   (
      <INTEGER>
      |
      <DECIMAL>
   )
   {
       String s = lastConsumedToken.toString();
       Number n = template != null ? template.getArithmeticEngine().toNumber(s) : new java.math.BigDecimal(s);
       CURRENT_NODE.setValue(n);
   }
;

INJECT NumberLiteral :
  import freemarker.core.Environment;
  import freemarker.core.ast.Expression;
  import freemarker.ext.beans.NumberModel;
  extends Expression
{
    @Property Number value;

    public NumberLiteral() {}

    public NumberLiteral(Number value) {
        this.value = value;
    }
    
    public Object evaluate(Environment env) {
        //return new NumberModel(value);
        return value;
    }
    
    public String getStringValue(Environment env) {
        return env.formatNumber(value);
    }

    public Number getAsNumber() {
        return value;
    }
    
    String getName() {
        return "the number: '" + value + "'";
    }

    public Expression _deepClone(String name, Expression subst) {
        return new NumberLiteral(value);
    }
}

Identifier# :
   <ID> 
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   } 
;

INJECT Identifier :
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.ast.Expression;
    extends Expression
{
    @Property String name;

    public Identifier() {}

    public Identifier(String name) {
        this.name = name;
    }
    
    public Object evaluate(Environment env) {
        try {
            return env.getVariable(name);
        } catch (NullPointerException e) {
            if (env == null) {
                throw new TemplateException("Variables are not available "
                + "(certainly you are in a parse-time executed directive). The name of the variable "
                + "you tried to read: " + name, null);
            } else {
                throw e;
            }
        }
    }

    public String toString() {
        return name;
    }

    public Expression _deepClone(String name, Expression subst) {
        if(this.name.equals(name)) {
        	return subst.deepClone(null, null);
        }
        return new Identifier(this.name);
    }
}

Expression IdentifierOrStringLiteral :
{
   Expression exp;
}
   (
      exp=Identifier
      |
      exp=StringLiteral
   )
   {
      return exp;
   }   
;

BuiltinVariable# :
   <DOT>
   <ID>
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   }
;

INJECT BuiltinVariable :
    import freemarker.template.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ParseException;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.Macro;
    extends Expression
{
    private String name;

    public void setName(String name) {
      this.name = name.intern();
    }
    
    public String getName() {
        return name;
    }

    public Object evaluate(Environment env) {
        switch (name) {
           case "namespace" : return env.getCurrentNamespace();
           case "main" : return env.getMainNamespace();
           case "globals" : return env;
           case "locals" : return env.getCurrentMacroContext();
           case "data_model" : return env.getDataModel();
           case "scope" : return env.getCurrentScope();
           case "vars" : return new VarsHash(env);
           case "locale" : return env.getLocale().toString();
           case "lang" : return env.getLocale().getLanguage();
           case "current_node" :
           case "node" : return env.getCurrentVisitorNode();
           case "pass" : return Macro.DO_NOTHING_MACRO;
           case "name" : return env.getTemplate().getName(); 
           case "version" : return Configuration.getVersionNumber();
           case "output_encoding" : return env.getOutputEncoding();
           case "url_escaping_charset" : return env.getURLEscapingCharset();
           case "error" : return env.getCurrentRecoveredErrorMessage();
        }
        throw new TemplateException("Invalid built-in variable: " + this, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        return this;
    }

    static class VarsHash implements TemplateHashModel {
        
        private final Environment env;
        
        VarsHash(Environment env) {
            this.env = env;
        }
        
        public Object get(String key) {
            return env.getVariable(key);
        }
        
        public boolean isEmpty() {
            return false;
        }
    }
}

DefaultToExpression(Expression exp)# :
{
   Expression rhs = null;
   Token t;
   pushNode(exp);
}
   (
       t=<EXCLAM>
       [
         SCAN {getToken(1).getType() != TokenType.ID || getToken(2).getType() != TokenType.EQUALS}
         => rhs=PrimaryExpression =>|| 
         {
            while (currentNodeScope.size() > 2) currentNodeScope.remove(currentNodeScope.size()-1);
            pushNode(rhs);
         }
       ]
   )
;

INJECT DefaultToExpression : 
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    extends Expression
{
	public Expression getLeft() {
		return (Expression) get(0);
	}
	
	public Expression getRight() {
		return childrenOfType(Expression.class).size() == 2 ?
		(Expression) getLastChild() : null;
	}

	public Object evaluate(Environment env) {
		Object left = null;		
		try {
			left = getLeft().evaluate(env);
		} catch (InvalidReferenceException ire) {
			if (!(getLeft() instanceof ParentheticalExpression)) {
				throw ire;
			}
		}
		if (left != null && left != Constants.JAVA_NULL) return left;
		if (getRight() == null) return Constants.NOTHING;
		return getRight().evaluate(env);
	}

	public Expression _deepClone(String name, Expression subst) {
		DefaultToExpression result = new DefaultToExpression();
		result.add(getLeft().deepClone(name, subst));
		result.add(get(1));
		if (getRight() != null) {
			result.add(getRight().deepClone(name, subst));
		}
		return result;
	}
}

ExistsExpression(Expression exp)# :
{
   pushNode(exp);
}
   <EXISTS>
;

INJECT ExistsExpression :
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.core.parser.ast.ParentheticalExpression;
    import freemarker.core.ast.Expression;
    import static freemarker.template.Constants.JAVA_NULL;
    extends Expression
{
	public Expression getExpression() {
		return (Expression) get(0);
	}

	public Object evaluate(Environment env) {
		Object value = null;
		try {
			value = getExpression().evaluate(env);
		} catch (InvalidReferenceException ire) {
			if (!(getExpression() instanceof ParentheticalExpression)) {
				throw ire;
			}
		}
		return value != null && value != JAVA_NULL;
	}

	public Expression _deepClone(String name, Expression subst) {
		ExistsExpression result = new ExistsExpression();
		result.add(getExpression().deepClone(name, subst));
		return result;
	}
}

BuiltInExpression(Expression exp)# :
{
   Token t=null;
   pushNode(exp);
}
   <BUILT_IN>
   t=<ID>
;

INJECT BuiltInExpression :
import java.util.HashMap;

    import freemarker.core.Environment;
    import freemarker.core.builtins.*;
    import freemarker.template.TemplateDateModel;
    import freemarker.core.ast.Expression;
    extends Expression;
{
    private static final HashMap<String, BuiltIn> knownBuiltins = new HashMap<String, BuiltIn>();
    {
        knownBuiltins.put("c", new cBI());
        knownBuiltins.put("size", new sizeBI());
        knownBuiltins.put("string", new stringBI());
        knownBuiltins.put("eval", new evalBI());
        knownBuiltins.put("new", new newBI());
        knownBuiltins.put("interpret", new interpretBI());
        knownBuiltins.put("resolve", new resolveBI());
        NumericalCast numericalCast = new NumericalCast();
        knownBuiltins.put("byte", numericalCast);
        knownBuiltins.put("double", numericalCast);
        knownBuiltins.put("float", numericalCast);
        knownBuiltins.put("int", numericalCast);
        knownBuiltins.put("long", numericalCast);
        knownBuiltins.put("short", numericalCast);
        knownBuiltins.put("floor", numericalCast);
        knownBuiltins.put("ceiling", numericalCast);
        knownBuiltins.put("round", numericalCast);
        knownBuiltins.put("capitalize", new StringTransformations.Capitalize());
        knownBuiltins.put("lower_case", new StringTransformations.LowerCase());
        knownBuiltins.put("upper_case", new StringTransformations.UpperCase());
        knownBuiltins.put("cap_first", new StringTransformations.CapFirst(true));
        knownBuiltins.put("uncap_first", new StringTransformations.CapFirst(false));
        knownBuiltins.put("j_string", new StringTransformations.Java());
        knownBuiltins.put("js_string", new StringTransformations.JavaScript());
        knownBuiltins.put("chop_linebreak", new StringTransformations.Chomp());
        knownBuiltins.put("trim", new StringTransformations.Trim());
        knownBuiltins.put("html", new StringTransformations.Html());
        knownBuiltins.put("rtf", new StringTransformations.Rtf());
        knownBuiltins.put("xml", new StringTransformations.Xml());
        knownBuiltins.put("xhtml", new StringTransformations.Xhtml());
        knownBuiltins.put("web_safe", knownBuiltins.get("html"));
        TypeChecks typeChecks = new TypeChecks();
        knownBuiltins.put("is_boolean", typeChecks);
        knownBuiltins.put("is_collection", typeChecks);
        knownBuiltins.put("is_date", typeChecks);
        knownBuiltins.put("is_enumerable", typeChecks);
        knownBuiltins.put("is_hash", typeChecks);
        knownBuiltins.put("is_hash_ex", typeChecks);
        knownBuiltins.put("is_indexable", typeChecks);
        knownBuiltins.put("is_directive", typeChecks);
        knownBuiltins.put("is_method", typeChecks);
        knownBuiltins.put("is_null", typeChecks);
        knownBuiltins.put("is_number", typeChecks);
        knownBuiltins.put("is_macro", typeChecks);
        knownBuiltins.put("is_node", typeChecks);
        knownBuiltins.put("is_sequence", typeChecks);
        knownBuiltins.put("is_string", typeChecks);
        knownBuiltins.put("is_transform", typeChecks);
        knownBuiltins.put("index_of", new StringFunctions.IndexOf());
        knownBuiltins.put("last_index_of", new StringFunctions.LastIndexOf());
        knownBuiltins.put("contains", new StringFunctions.Contains());
        knownBuiltins.put("number", new numberBI());
        knownBuiltins.put("left_pad", new StringFunctions.LeftPad());
        knownBuiltins.put("right_pad", new StringFunctions.RightPad());
        knownBuiltins.put("length", new StringFunctions.Length());
        knownBuiltins.put("replace", new StringFunctions.Replace());
        knownBuiltins.put("split", new StringFunctions.Split());
        knownBuiltins.put("groups", new groupsBI());
        knownBuiltins.put("matches", new StringFunctions.Matches());
        knownBuiltins.put("starts_with", new StringFunctions.StartsWith());
        knownBuiltins.put("ends_with", new StringFunctions.EndsWith());
        knownBuiltins.put("substring", new StringFunctions.Substring());
        knownBuiltins.put("word_list", new StringFunctions.WordList());
        knownBuiltins.put("url", new StringFunctions.Url());
        knownBuiltins.put("parent", new NodeFunctions.Parent());
        knownBuiltins.put("children", new NodeFunctions.Children());
        knownBuiltins.put("node_name", new NodeFunctions.NodeName());
        knownBuiltins.put("node_type", new NodeFunctions.NodeType());
        knownBuiltins.put("node_namespace", new NodeFunctions.NodeNamespace());
        knownBuiltins.put("root", new NodeFunctions.Root());
        knownBuiltins.put("ancestors", new NodeFunctions.Ancestors());
        knownBuiltins.put("first", new SequenceFunctions.First());
        knownBuiltins.put("last", new SequenceFunctions.Last());
        knownBuiltins.put("reverse", new SequenceFunctions.Reverse());
        knownBuiltins.put("sort", new SequenceFunctions.Sort());
        knownBuiltins.put("sort_by", new SequenceFunctions.SortBy());
        knownBuiltins.put("chunk", new SequenceFunctions.Chunk());
        knownBuiltins.put("seq_contains", new SequenceContainsBuiltIn());
        knownBuiltins.put("seq_index_of", new SequenceFunctions.IndexOf());
        knownBuiltins.put("seq_last_index_of", new SequenceFunctions.LastIndexOf());
        knownBuiltins.put("scope", new MacroBuiltins.Scope());
        knownBuiltins.put("namespace", new MacroBuiltins.Namespace());
        knownBuiltins.put("keys", new HashBuiltin.Keys());
        knownBuiltins.put("values", new HashBuiltin.Values());
        knownBuiltins.put("date", new DateTime(TemplateDateModel.DATE));
        knownBuiltins.put("time", new DateTime(TemplateDateModel.TIME));
        knownBuiltins.put("datetime", new DateTime(TemplateDateModel.DATETIME));
        knownBuiltins.put("is_defined", new ExistenceBuiltIn.IsDefinedBuiltIn());
        knownBuiltins.put("if_exists", new ExistenceBuiltIn.IfExistsBuiltIn());
        knownBuiltins.put("exists", new ExistenceBuiltIn.ExistsBuiltIn());
        knownBuiltins.put("default", new ExistenceBuiltIn.DefaultBuiltIn());
        knownBuiltins.put("has_content", new ExistenceBuiltIn.HasContentBuiltIn());
        knownBuiltins.put("source", new sourceBI());
    }

    private String key;
    private BuiltIn bi;

    public void close() {
        key = getKeyTok().toString().intern();
        bi = knownBuiltins.get(key);
    }

    public Expression getTarget() {
        return (Expression) get(0);
    }

    public Token getKeyTok() {
        return (Token) firstChildOfType(Token.TokenType.ID);
    }

    public BuiltIn getBuiltIn() {
        return bi;
    }

    public Object evaluate(Environment env) {
        return bi.get(env, this);
    }

    public String getName() {
        return key;
    }

    public Expression _deepClone(String name, Expression subst) {
        BuiltInExpression result = new BuiltInExpression();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        result.add(getKeyTok());
        result.key = key;
        result.bi = bi;
        return result;
    }
}

/**
 * production for when a key is specified by <DOT> + keyname
 */
Expression DotVariable(Expression exp)# :
     {pushNode(exp);}
     <DOT>{token_source.justAfterDot = true;}
     <ID>{token_source.justAfterDot = false;}
     {
         return CURRENT_NODE;
     }
;

INJECT DotVariable : 
    import freemarker.core.Environment;
    import freemarker.core.parser.Token;
    import freemarker.template.TemplateHashModel;
    import freemarker.core.ast.Expression;
    import java.util.Map;
    import static freemarker.ext.beans.ObjectWrapper.wrap;
    extends Expression
{
    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public String getKey() {
    	return get(2).toString();
    }

    public Object evaluate(Environment env) {
        Object leftModel = getTarget().evaluate(env);
        if (leftModel instanceof Map) {
            return wrap(((Map)leftModel).get(getKey()));
        }
        if(leftModel instanceof TemplateHashModel) {
            return wrap(((TemplateHashModel) leftModel).get(getKey()));
        }
        throw invalidTypeException(leftModel, getTarget(), env, "hash");
    }

    public Expression _deepClone(String name, Expression subst) {
        Expression clonedTarget = getTarget().deepClone(name, subst);
        Token op = (Token) get(1);
        Token key = (Token) get(2);
        Expression result = new DotVariable();
        result.add(clonedTarget);
        result.add(op);
        result.add(key);
        return result;
    }

    public boolean onlyHasIdentifiers() {
        Expression target = getTarget();
        return (target instanceof Identifier) 
               || ((target instanceof DotVariable) 
               && ((DotVariable) target).onlyHasIdentifiers());
    }    
}

/**
 * production for when the key is specified
 * in brackets.
 */
DynamicKeyName(Expression exp)# :
{
   pushNode(exp);
   Expression arg;
}
   <OPEN_BRACKET>
   arg=Expression 
   {
     while (currentNodeScope.size() > 2) {
        currentNodeScope.remove(currentNodeScope.size()-1);
     }
     pushNode(arg);
   }
   <CLOSE_BRACKET>
;

INJECT DynamicKeyName :
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Map;
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.ext.beans.ListModel;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.EvaluationUtil;
    import freemarker.core.ast.NonStringException;
    import freemarker.core.ast.Range;
    import static freemarker.ext.beans.ObjectWrapper.*;
    import static freemarker.template.Constants.JAVA_NULL;
    extends Expression
{

    public Expression getNameExpression() {
    	return (Expression) get(2);
    }
    
    public Expression getTarget() {
    	return (Expression) get(0);
    }

    public Object evaluate(Environment env) throws TemplateException
    {
        Object value = getTarget().evaluate(env);
        assertNonNull(value, getTarget(), env);
        if (getNameExpression() instanceof Range) {
            return dealWithRangeKey(value, (Range) getNameExpression(), env);
        }
        Object key = getNameExpression().evaluate(env);
        if(key == null) {
            assertNonNull(key, getNameExpression(), env);
        }
        if (isNumber(key)) {
            int index = asNumber(key).intValue();
            return dealWithNumericalKey(value, index, env);
        }
        if (isString(key)) {
            return dealWithStringKey(value, asString(key), env);
        }
        throw invalidTypeException(key, getNameExpression(), env, "number, range, or string");
    }


    private Object dealWithNumericalKey(Object targetModel, 
                                               int index, 
                                               Environment env)
    {
        if (targetModel instanceof TemplateSequenceModel) {
            TemplateSequenceModel tsm = (TemplateSequenceModel) targetModel;
            int size = Integer.MAX_VALUE;
            try {
                size = tsm.size();
            } catch (Exception e) {}
            return index<size ? tsm.get(index) : null;
        } 
        if (targetModel instanceof List) {
            try {
                return wrap(((List)targetModel).get(index));
            } catch (ArrayIndexOutOfBoundsException ae) {
                return JAVA_NULL;
            }
        }
        try
        {
            String s = getTarget().getStringValue(env);
            try {
               return s.substring(index, index+1);
            } catch (RuntimeException re) {
                throw new TemplateException("", re, env);
            }
        }
        catch(NonStringException e)
        {
            throw invalidTypeException(targetModel, getTarget(), env, "number, sequence, or string");
        }
    }

    private Object dealWithStringKey(Object targetModel, 
                                            String key,
                                            Environment env)
    {
        if (targetModel instanceof Map) {
            return wrap(((Map) targetModel).get(key));
        }
        if(targetModel instanceof TemplateHashModel) {
            return wrap(((TemplateHashModel) targetModel).get(key));
        }
        throw invalidTypeException(targetModel, getTarget(), env, "hash");
    }

    private Object dealWithRangeKey(Object targetModel, 
                                           Range range, 
                                           Environment env)
    {
        int start = EvaluationUtil.getNumber(range.getLeft(), env).intValue();
        int end = 0;
        boolean hasRhs = range.hasRhs();
        if (hasRhs) {
            end = EvaluationUtil.getNumber(range.getRight(), env).intValue();
        }
        if (targetModel instanceof TemplateSequenceModel) {
            TemplateSequenceModel sequence = (TemplateSequenceModel) targetModel;
            if (!hasRhs) end = sequence.size() -1;
            if (start < 0) {
                String msg = range.getRight().getStartLocation() + "\nNegative starting index for range, is " + range;
                throw new TemplateException(msg, env);
            }
            if (end < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative ending index for range, is " + range;
                throw new TemplateException(msg, env);
            }
            if (start >= sequence.size()) {
                String msg = range.getLeft().getStartLocation() 
                            + "\nLeft side index of range out of bounds, is " + start
                            + ", but the sequence has only " + sequence.size() + " element(s) "
                            + "(note that indices are 0 based, and ranges are inclusive).";
                throw new TemplateException(msg, env);
            }
            if (end >= sequence.size()) {
                String msg = range.getRight().getStartLocation() 
                             + "\nRight side index of range out of bounds, is " + end
                             + ", but the sequence has only " + sequence.size() + " element(s)."
                             + "(note that indices are 0 based, and ranges are inclusive).";
                throw new TemplateException(msg, env);
            }
            ArrayList<Object> list = new ArrayList<>(1+Math.abs(start-end));
            if (start>end) {
                for (int i = start; i>=end; i--) {
                    list.add(sequence.get(i));
                }
            }
            else {
                for (int i = start; i<=end; i++) {
                    list.add(sequence.get(i));
                }
            }
            return new ListModel(list);
        }
        
        try
        {
            String s = getTarget().getStringValue(env);
            if (!hasRhs) end = s.length() -1;
            if (start < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative starting index for range " + range + " : " + start;
                throw new TemplateException(msg, env);
            }
            if (end < 0) {
                String msg = range.getLeft().getStartLocation() + "\nNegative ending index for range " + range + " : " + end;
                throw new TemplateException(msg, env);
            }
            if (start > s.length()) {
                String msg = range.getLeft().getStartLocation() 
                            + "\nLeft side of range out of bounds, is: " + start
                            + "\nbut string " + targetModel + " has " + s.length() + " elements.";
                throw new TemplateException(msg, env);
            }
            if (end > s.length()) {
                String msg = range.getRight().getStartLocation() 
                             + "\nRight side of range out of bounds, is: " + end
                             + "\nbut string " + targetModel + " is only " + s.length() + " characters.";
                throw new TemplateException(msg, env);
            }
            try {
                return s.substring(start, end+1);
            } catch (RuntimeException re) {
                String msg = "Error " + getStartLocation();
                throw new TemplateException(msg, re, env);
            }
        }
        catch(NonStringException e)
        {
            throw invalidTypeException(getTarget().evaluate(env), getTarget(), env, "number, scalar, or sequence");
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        DynamicKeyName result = new DynamicKeyName();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        result.add(getNameExpression().deepClone(name, subst));
        result.add(get(3));
        return result;
    }
}

/**
 * production for an arglist part of a method invocation.
 */
MethodCall(Expression exp)# : 
{
     ArgsList args = new PositionalArgsList();
     Token end;
     pushNode(exp);
}
     <OPEN_PAREN>
     [
        args=ArgsList 
        {
            while (currentNodeScope.size() > 2) {
                currentNodeScope.remove(currentNodeScope.size()-1);
            }
            pushNode(args);
        }
     ]
     end=<CLOSE_PAREN>
;

INJECT MethodCall :
    import java.util.ArrayList;
    import java.util.List;
    import java.io.Writer;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ObjectWrapper;
    import freemarker.template.*;
    import java.io.IOException;
    import java.io.StringWriter;
    import freemarker.core.ast.ArgsList;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.Macro;
    extends Expression;
{

    public ArgsList getArgs() {
        return firstChildOfType(ArgsList.class);
    }

    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public Object evaluate(Environment env) throws TemplateException
    {
        Object value = getTarget().evaluate(env);
        if (value instanceof TemplateMethodModel) {
            TemplateMethodModel targetMethod = (TemplateMethodModel)value;
            ArgsList args = getArgs();
            List argumentStrings = new ArrayList();
            if (args !=null) {
                argumentStrings = args.getParameterSequence(targetMethod, env);
            }
            Object result = targetMethod.exec(argumentStrings);
            return ObjectWrapper.wrap(result);
        }
        else if (value instanceof Macro) {
            Macro func = (Macro) value;
            StringWriter sw = null;
            env.setLastReturnValue(null);
            Writer prevOut = env.getOut();
            try {
                env.setOut(Environment.NULL_WRITER);
                if (!func.isFunction()) {
                    sw = new StringWriter();
                    env.setOut(sw);
                 }
                env.render(func, getArgs(), null, null);
            } catch (IOException ioe) {
                throw new InternalError("This should be impossible.");
            } finally {
                env.setOut(prevOut);
            }
            return sw != null ? ObjectWrapper.wrap(sw.getBuffer().toString()) : env.getLastReturnValue();
        }
        else {
            throw invalidTypeException(value, getTarget(), env, "method");
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        MethodCall result = new MethodCall();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        ArgsList args = getArgs();
        if (args != null) {
            result.add(getArgs().deepClone(name, subst));
            result.add(get(3));
        } else {
            result.add(get(2));
        }
        return result;
    }
}

Expression StringLiteral# :
{
  boolean raw = false;
}
   (
     <STRING_LITERAL>
     |
     <RAW_STRING> {raw = true;}
   )
   {
       String s = lastConsumedToken.toString();
       // Get rid of the quotes.
       s = s.substring(1, s.length() -1);
       if (raw) {
           s=s.substring(1);
       }
       else try {
          s = StringUtil.FTLStringLiteralDec(s);
       } catch (ParseException pe) {
       	  InvalidExpression invalid = new InvalidExpression("Malformed string literal: " + pe.getMessage());
       	  invalid.setLocation(template, token_source, lastConsumedToken, lastConsumedToken);
       	  return invalid;
       }
       CURRENT_NODE.setRaw(raw);
       CURRENT_NODE.setValue(s);
       return CURRENT_NODE;
   }
;

INJECT StringLiteral :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.parser.*;
   import freemarker.core.ast.Expression;
   import freemarker.core.ast.TemplateElement;
   import java.io.*;
   extends Expression
{
    private TemplateElement interpolatedOutput;
    private String value;
    private boolean raw;

    public StringLiteral() {}
    
    public StringLiteral(String value, boolean raw) {
        this.value = value;
        this.raw = raw;
    }
    
    public boolean isRaw() {
    	return raw;
    }

    public void setRaw(boolean raw) {
        this.raw = raw;
    }
    
    public String getValue() {
    	return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
    
    public void checkInterpolation() {
    	String src = this.getSource();
        if (src.length() >5 && (src.indexOf("${") >= 0)) {
            FMLexer token_source = new FMLexer("input", value, FMLexer.LexicalState.DEFAULT, getBeginLine(), getBeginColumn() +1);
            token_source.setOnlyTextOutput(true);
            FMParser parser = new FMParser(token_source);
            parser.setTemplate(getTemplate());
            try {
                interpolatedOutput = parser.FreeMarkerText();
            }
            catch(ParseException e) {
                e.setTemplateName(getTemplate().getName());
                throw e;
            }
        }
    }
    
    public Object evaluate(Environment env) {
        return getStringValue(env);
    }

    public String getAsString() {
        return value;
    }
    
    public String getStringValue(Environment env) {
        if (interpolatedOutput == null) {
            return value;
        } 
        else {
            TemplateExceptionHandler teh = env.getTemplateExceptionHandler();
            env.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
            try {
               return env.renderElementToString(interpolatedOutput);
            }
            catch (IOException ioe) {
                throw new TemplateException(ioe, env);
            }
            finally {
                env.setTemplateExceptionHandler(teh);
            }
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        StringLiteral cloned = new StringLiteral(value, raw);
        cloned.interpolatedOutput = this.interpolatedOutput;
        return cloned;
    }
}

BooleanLiteral# :
   <FALSE>
   |
   <TRUE> {CURRENT_NODE.setValue(true);}
;

INJECT BooleanLiteral :
    import freemarker.core.Environment;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    extends Expression
{
    @Property boolean value;

    public BooleanLiteral() {}
    public BooleanLiteral(boolean value) {this.value = value;}

    public boolean isTrue(Environment env) {
        return value;
    }

    public String toString() {
        return value ? "true" : "false";
    }

    public Boolean evaluate(Environment env) {
        return value;
    }

    public Expression _deepClone(String name, Expression subst) {
        BooleanLiteral result = new BooleanLiteral();
        result.setValue(value);
        return result;
    }

}

NullLiteral# :
   <NULL>
;

INJECT NullLiteral : 
   import freemarker.core.Environment;
   import freemarker.template.Constants;
   import freemarker.template.TemplateModel;
   import freemarker.core.ast.Expression;
   extends Expression
{
    public String toString() {
    	return "null";
    }

    public Object evaluate(Environment env) {
        return Constants.JAVA_NULL;
    }

    public Expression _deepClone(String name, Expression subst) {
    	return new NullLiteral();
    }
}

HashLiteral# :
{
   Expression key, value;
   ArrayList<Expression> keys = new ArrayList<>();
   ArrayList<Expression> values = new ArrayList<>();
}
   <OPEN_BRACE>
   [
       key=Expression
       <COLON>
       value=Expression
       {
          keys.add(key);
          values.add(value);
       }
       (
          <COMMA>
           key=Expression
           <COLON>
           value=Expression
           {
               keys.add(key);
               values.add(value);
           }
       )*
   ]
   <CLOSE_BRACE>
   {
      clearNodeScope();
      for (int i = 0; i<keys.size();i++) {
         pushNode(keys.get(i));
         pushNode(values.get(i));
      }
   }
;

INJECT HashLiteral :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.ext.beans.ListModel;
    import freemarker.template.*;
    import freemarker.core.ast.Expression;
    import freemarker.core.ast.CollectionAndSequence;
    extends Expression
{
    private List<Expression> keys = new ArrayList<>();
    private List<Expression> values = new ArrayList<>();
    
    public void close() {
        boolean justSawKey = false;
        for (Expression exp : childrenOfType(Expression.class)) {
            if (justSawKey) values.add(exp);
            else keys.add(exp);
            justSawKey = !justSawKey;
       }
       assert keys.size() == values.size() : getSource();
    }
    
    public Object evaluate(Environment env) {
        return new SequenceHash(env);
    }
    
    public List<Expression> getKeys() {
    	return Collections.unmodifiableList(keys);
    }
    
    public List<Expression> getValues() {
    	return Collections.unmodifiableList(values);
    }

    public Expression _deepClone(String name, Expression subst) {
    	HashLiteral result = new HashLiteral();
        for (int i = 0; i< keys.size(); i++) {
            Expression keyClone = keys.get(i).deepClone(name, subst);
            Expression valueClone = values.get(i).deepClone(name, subst);
            result.keys.add(keyClone);
            result.values.add(valueClone);
        }
        result.close();
        return result;
    }

    private class SequenceHash implements TemplateHashModelEx {

        private HashMap<String, Object> keyMap  = new HashMap<>(); // maps keys to integer offset
        private Iterable<String> keyCollection;
        private Iterable<Object> valueCollection; 

        SequenceHash(Environment env) {
            List<String> keyList = new ArrayList<String>(keys.size());
            List<Object> valueList = new ArrayList<>(keys.size());
            for (int i = 0; i< keys.size(); i++) {
                Expression keyExp = keys.get(i);
                Expression valExp = values.get(i);
                String key = keyExp.getStringValue(env);
                Object value = valExp.evaluate(env);
                assertIsDefined(value, valExp, env);
                keyMap.put(key, value);
                keyList.add(key);
                valueList.add(value);
            }
            keyCollection = keyList;
            valueCollection = valueList;
        }

        public int size() {
            return keys.size();
        }

        public Iterable keys() {
            return keyCollection;
        }

        public Iterable values() {
            return valueCollection;
        }

        public Object get(String key) {
            return keyMap.get(key);
        }

        public boolean isEmpty() {
            return size() == 0;
        }
    }
}

