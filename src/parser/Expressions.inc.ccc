// This file defines the expression
// grammar. It is INCLUDEd from the main template.

#Expression#interface : 
    TernaryExpression 
    {
        return (Expression) peekNode();
    } 
;

INJECT Expression :
   import freemarker.core.variables.*;
   import freemarker.core.Environment;
   import freemarker.core.variables.InvalidReferenceException;
   import freemarker.template.TemplateException;
   import freemarker.template.TemplateDateModel;
   import freemarker.template.TemplateSequenceModel;
   import java.lang.reflect.Array;
   import static freemarker.core.variables.Wrap.*;
{
    public abstract Object evaluate(Environment env);
    
    default String getDescription() {
    	return "the expression: "  + this;
    }

    default boolean isAssignableTo() {
        return false;
    }

    default String getStringValue(Environment env) {
        Object referent = evaluate(env);
        if (referent instanceof Number) {
            return env.formatNumber((Number)referent);
        }
        if (referent instanceof TemplateDateModel) {
            TemplateDateModel dm = (TemplateDateModel) referent;
            return env.formatDate(getDate(dm, this, env), dm.getDateType());
        }
        if (isString(referent)) {
            return asString(referent);
        }
        assertNonNull(referent, env);
        return referent.toString();
/*        String msg = "Error " + getLocation()
                     +"\nExpecting a string, " 
                     + "date or number here, Expression " + this 
                     + " is instead a " 
                     + referent.getClass().getName();
        throw new TemplateException(msg, env);*/
    }
    
    Expression _deepClone(String name, Expression subst);
    
    default Expression deepClone(String name, Expression subst) {
        Expression clone = _deepClone(name, subst);
        clone.copyLocationFrom(this);
        clone.setParent(this.getParent());
        return clone;
    }

    default void assertNonNull(Object value, Environment env) {
        assertIsDefined(value, env);
        if (value == JAVA_NULL) {
            throw new InvalidReferenceException("Expression " + this + " is null " + getLocation() + ".", env);
        }
    }

    default void assertIsDefined(Object value, Environment env) {
        if (value == null) {
            throw new InvalidReferenceException("Expression " + this + " is undefined " + getLocation() + ".", env);
        }
    }

    default boolean isTrue(Environment env) {
        Object referent = evaluate(env);
        assertIsDefined(referent, env);
        if (referent == JAVA_NULL) {
            return false;
        }
        if (isBoolean(referent)) {
            return asBoolean(referent);
        }
        if (referent instanceof Collection) {
            return !((Collection)referent).isEmpty();
        }
        if (referent instanceof Map) {
            return !((Map)referent).isEmpty();
        }
        if (referent.getClass().isArray()) {
            return Array.getLength(referent) > 0;
        }
        if (referent instanceof TemplateSequenceModel) {
            return ((TemplateSequenceModel)referent).size() > 0;
        }
        return referent.toString().length() > 0;
    }
}

TernaryExpression : 
    OrExpression 
    [
        <TERNARY>
        Expression
        <COLON>
        Expression
    ]
; 

INJECT TernaryExpression :
   import freemarker.core.Environment;
   implements Expression
{
    public Object evaluate(Environment env) {
        Expression condition = (Expression) get(0);
        Expression trueChoice= (Expression) get(2);
        Expression falseChoice = (Expression) get(4);
        return condition.isTrue(env) ? trueChoice.evaluate(env) : falseChoice.evaluate(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        TernaryExpression result = new TernaryExpression();
        result.add(((Expression) get(0)).deepClone(name, subst));
        result.add(get(1));
        result.add(((Expression) get(2)).deepClone(name, subst));
        result.add(get(3));
        result.add(((Expression) get(4)).deepClone(name, subst));
        return result;
    }
}

Literal#void :
  <NULL>
  |
  <TRUE>
  |
  <FALSE>
  |
  <NUMBER>
  |
  <STRING_LITERAL>
  |
  <RAW_STRING>
  |
  HashLiteral
  |
  ListLiteral
;

PrimaryExpression(boolean noSpace)#void :
   (
      Literal
      |
      <ID>
      |
      ParentheticalExpression
      |
      BuiltinVariable
  )
  (
    SCAN 1 {!noSpace || getToken(0).getEndOffset() == getToken(1).getBeginOffset()} =>
    (
      (
        <DOT>
        DEACTIVATE_TOKENS IN, AS, USING, TRUE, FALSE, NULL
        (<ID>|<TIMES>|<DOUBLE_STAR>) 
      ) #DotVariable(+1) 
      |
      <OPEN_BRACKET> Expression <CLOSE_BRACKET> #freemarker.core.nodes.DynamicKeyName(4)
      |
      (<OPEN_PAREN> [ArgsList] <CLOSE_PAREN>) #MethodCall(+1)
      |
      <BUILT_IN><ID> #BuiltInExpression(3)
      |
      <EXISTS>#ExistsExpression(2) 
      |
      (
        <EXCLAM>
        [
            SCAN {getToken(1).getType() != TokenType.ID || getToken(2).getType() != TokenType.EQUALS}
            => PrimaryExpression(false) =>||
        ]
      ) #DefaultToExpression(+1)
      |
      <DOUBLE_COLON> <ID> #MethodReference(3)
    )
  )*
;

ParentheticalExpression :
    <OPEN_PAREN> 
    Expression 
    <CLOSE_PAREN>
;

INJECT ParentheticalExpression :
   import freemarker.core.Environment;
   implements Expression
{
   public Expression getNested() {
        return firstChildOfType(Expression.class);
    }

    public boolean isTrue(Environment env) {
        return getNested().isTrue(env);
    }
    
    public Object evaluate(Environment env) {
        return getNested().evaluate(env);
    }

    public boolean isAssignableTo() {
        return getNested().isAssignableTo();
    }

    public Expression _deepClone(String name, Expression subst) {
        ParentheticalExpression result = new ParentheticalExpression();
        result.add(get(0));
        result.add(getNested().deepClone(name, subst));
        result.add(get(2));
        return result;
    }   
}

INJECT DotVariable :
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    import freemarker.core.variables.scope.Scope;
    import freemarker.template.TemplateHashModel;
    import static freemarker.core.variables.Wrap.wrap;
    import static freemarker.core.variables.Wrap.JAVA_NULL;
    implements Expression
{
    public Expression getTarget() {
        return (Expression) get(0);
    }

    public String getKey() {
        return get(2).toString();
    }

    public boolean isAssignableTo() {
        return true;
    }

    public Object evaluate(Environment env) {
        Object lhs = getTarget().evaluate(env);
        assertNonNull(lhs, env);
        if (lhs instanceof Map) {
            Object key = getKey();
            Object value = ((Map)lhs).get(key);
            if (value == null) {
                return ((Map)lhs).containsKey(key) ? JAVA_NULL : null;
            } 
            return wrap(value);
        }
        if (lhs instanceof TemplateHashModel) {
            return wrap(((TemplateHashModel) lhs).get(getKey()));
        }
        return ReflectionCode.getProperty(lhs, getKey(), getTemplate().legacySyntax());
    }

    public Expression _deepClone(String name, Expression subst) {
        Expression clonedTarget = getTarget().deepClone(name, subst);
        Token op = (Token) get(1);
        Token key = (Token) get(2);
        Expression result = new DotVariable();
        result.add(clonedTarget);
        result.add(op);
        result.add(key);
        return result;
    }    
}

/**
 * A primary expression preceded (optionally)
 * by a unary operator
 */
UnaryExpression#void :
   UnaryPlusMinusExpression
   |
   NotExpression 
   |
   PrimaryExpression(false) 
;

NotExpression :
   <EXCLAM>
   (
      PrimaryExpression(false) 
      |
      NotExpression 
   )
;

INJECT NotExpression :
    import freemarker.core.Environment;
    implements Expression
{
    public Expression getTarget() {
        return (Expression) get(1);
    }

    public Object evaluate(Environment env) {
        return isTrue(env);
    }

    public boolean isTrue(Environment env) {
        return (!getTarget().isTrue(env));
    }

    public Expression _deepClone(String name, Expression subst) {
        NotExpression result = new NotExpression();
    	result.add(getTarget().deepClone(name, subst));
        return result;
    }
}

UnaryPlusMinusExpression :
   (
      <PLUS>
      |
      <MINUS>
   )
   (
      UnaryPlusMinusExpression
      |
      PrimaryExpression(false)
   )
;

INJECT UnaryPlusMinusExpression : 
    import freemarker.core.Environment;
    import freemarker.core.ArithmeticEngine;
    import freemarker.core.variables.*;
    import freemarker.template.TemplateException;
    implements Expression
{
    private static final Integer MINUS_ONE = Integer.valueOf(-1); 

    public Expression getTarget() {
    	return firstChildOfType(Expression.class);
    }
    
    public boolean isMinus() {
    	return get(0).getType()==MINUS;
    }
    
    public Object evaluate(Environment env) {
        Number value = null;
        try {
            value = (Number)getTarget().evaluate(env);
        } catch (ClassCastException cce) {
            String msg = "Error " + getLocation();
            msg += "\nExpression " + getTarget() + " is not numerical.";
            throw new TemplateException(msg, env);
        }
        if (!isMinus()) {
            return value;
        }
        return ArithmeticEngine.CONSERVATIVE_ENGINE.multiply(MINUS_ONE, value);
    }

    public Expression _deepClone(String name, Expression subst) {
        UnaryPlusMinusExpression result = new UnaryPlusMinusExpression();
        result.add(get(0));
        result.add(getTarget().deepClone(name,subst));
        return result;
    }
}

AdditiveExpression :
   MultiplicativeExpression 
   [
      (
         <PLUS> 
         |
         <MINUS>
      )
      AdditiveExpression
   ]
;

INJECT AdditiveExpression : 
    import freemarker.template.TemplateException;
    import freemarker.core.ArithmeticEngine;
    import freemarker.core.Environment;
    import static freemarker.core.variables.Wrap.*;
    implements Expression;
{
    public boolean isPlus() {
        return get(1).getType() == PLUS;
    }

    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        Object left = getLeft().evaluate(env);
        Object right = getRight().evaluate(env);
        ArithmeticEngine ae = env != null ? env.getArithmeticEngine() : getTemplate().getArithmeticEngine();
        if (!isPlus()) {
            Number first = getNumber(left, getLeft(), env);
            Number second = getNumber(right, getRight(), env);
            return ae.subtract(first, second);
        }
        if (left instanceof Number && right instanceof Number) {
            return ae.add((Number) left, (Number) right);
        }
        if (isList(left) && isList(right)) {
            List leftList = asList(left);
            List rightList = asList(right);
            List result = new ArrayList();
            result.addAll(leftList);
            result.addAll(rightList);
            return result;
        }
        if (isMap(left) && isMap(right)) {
            Map leftMap = (Map) unwrap(left);
            Map rightMap = (Map) unwrap(right);
            Map result = new LinkedHashMap(leftMap);
            for (Object key : rightMap.keySet()) {
                result.put(key, rightMap.get(key));
            }
            return result;
        }
        return getLeft().getStringValue(env) + getRight().getStringValue(env);
        //String msg = this.getLocation() + ": Cannot add or concatenate";
        //throw new TemplateException(msg, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        AdditiveExpression result = new AdditiveExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

MultiplicativeExpression :
   UnaryExpression 
   [
      (
         <TIMES>
         |
         <DIVIDE>
         |
         <PERCENT>
      )
      MultiplicativeExpression
   ]
;

INJECT MultiplicativeExpression :
   import freemarker.template.TemplateException;
   import freemarker.core.Environment;
   import freemarker.core.ArithmeticEngine;
   import static freemarker.core.variables.Wrap.getNumber;
   implements Expression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }
    
    public TokenType getOperation() {
        return (TokenType) get(1).getType();
    }

    public Object evaluate(Environment env) {
        Object leftSide = getLeft().evaluate(env);
        Object rightSide = getRight().evaluate(env);
        boolean leftIsNumber = leftSide instanceof Number;
        boolean rightIsNumber = rightSide instanceof Number;
        boolean bothNumbers = leftIsNumber && rightIsNumber;
        if (!bothNumbers) {
            String msg = "Error " + getLocation();
            if (!leftIsNumber) {
                msg += "\nExpression " + getLeft() + " is not numerical";
            }
            if (!rightIsNumber) {
                msg += "\nExpression " + getRight() + " is not numerical";
            }
            throw new TemplateException(msg, env);
        }
        Number first = getNumber(leftSide, getLeft(), env);
        Number second = getNumber(rightSide, getRight(), env);
        ArithmeticEngine ae = 
            env != null 
                ? env.getArithmeticEngine()
                : getTemplate().getArithmeticEngine();
        switch (getOperation()) {
            case TIMES :
                return ae.multiply(first, second);
            case DIVIDE :
                return ae.divide(first, second);
            case PERCENT :
                return ae.modulus(first, second);
            default:
                throw new TemplateException("unknown operation : " + getOperation(), env);
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        MultiplicativeExpression result = new MultiplicativeExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

EqualityExpression :
   RelationalExpression
   [
     (
      <NOT_EQUALS> 
      |
      <EQUALS> 
      |
      <DOUBLE_EQUALS>
     )
     RelationalExpression
   ]
;

INJECT EqualityExpression :
    import freemarker.core.Environment;
    import freemarker.core.ArithmeticEngine;
    import static freemarker.core.variables.Wrap.*;
    implements Expression
{
    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        return isTrue(env);
    }

    public boolean isTrue(Environment env) {
        TokenType operation = (TokenType) get(1).getType();
        Object left = getLeft().evaluate(env);
        Object right = getRight().evaluate(env);
        getLeft().assertNonNull(left, env);
        getRight().assertNonNull(right, env);
        if (left instanceof Number && right instanceof Number) {
            ArithmeticEngine ae = env != null ? env.getArithmeticEngine() : getTemplate().getArithmeticEngine();
            int comp = ae.compareNumbers((Number)left, (Number)right);
            return operation == NOT_EQUALS ? comp !=0 : comp == 0;
        }
        left = unwrap(left);
        right = unwrap(right);
        return operation == NOT_EQUALS ? !left.equals(right) : left.equals(right);
    }

    private boolean dealWithNumbers(Number left, Number right, TokenType operation, Environment env) {
        ArithmeticEngine ae = env != null ? env.getArithmeticEngine() : getTemplate().getArithmeticEngine();
        int comp = ae.compareNumbers(left, right);
        return operation == NOT_EQUALS ? comp !=0 : comp == 0;
    }

    public Expression _deepClone(String name, Expression subst) {
        EqualityExpression result = new EqualityExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

RelationalExpression :
   RangeExpression 
   [
     (
      <GREATER_THAN_EQUALS>
      |
      <ESCAPED_GTE>
      |
      <GREATER_THAN>
      |
      <ESCAPED_GT>
      |
      <LESS_THAN_EQUALS>
      |
      <LESS_THAN>
     )
     RangeExpression
   ]
;

INJECT RelationalExpression :
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.ArithmeticEngine;
    import static freemarker.core.variables.Wrap.*;
    implements Expression;
{
    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        return isTrue(env);
    }

    public boolean isTrue(Environment env) {
        TokenType operation = (TokenType) get(1).getType();
        Object left = getLeft().evaluate(env);
        Object right = getRight().evaluate(env);
        getLeft().assertNonNull(left, env);
        getRight().assertNonNull(right, env);
        if (!(left instanceof Number && right instanceof Number)) {
            throw new TemplateException("Can only compare numbers", env);
        }
        ArithmeticEngine ae = env != null ? env.getArithmeticEngine() : getTemplate().getArithmeticEngine();
        int comp = ae.compareNumbers((Number)left, (Number)right);
        switch(operation) {
            case LESS_THAN : 
                return comp < 0;
            case GREATER_THAN : case ESCAPED_GT : 
                return comp > 0;
            case LESS_THAN_EQUALS : 
                return comp <= 0;
            case GREATER_THAN_EQUALS : case ESCAPED_GTE : 
                return comp >= 0;
            default : throw new InternalError();
        }
    }

    public Expression _deepClone(String name, Expression subst) {
        RelationalExpression result = new RelationalExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

RangeExpression :
   AdditiveExpression
   [
    <DOT_DOT>
    [
       AdditiveExpression
    ]
   ]
;

INJECT RangeExpression :
   import freemarker.core.variables.*;
   import freemarker.core.Environment;
   import freemarker.template.TemplateException;
   import static freemarker.core.variables.Wrap.getNumber;
   implements Expression
{
    public Expression getLeft() {
        return (Expression) get(0);
    }

    public Expression getRight() {
        return hasRhs() ? (Expression) get(2) : null;
    }

    public boolean hasRhs() {
        return size()==3;
    }
    
    public Object evaluate(Environment env) {
        int min = getNumber(getLeft(), env).intValue();
        int max = 0;
        if (hasRhs()) {
            max = getNumber(getRight(), env).intValue();
            return new NumericalRange(min, max);
        }
        return new NumericalRange(min);
    }
    
    public boolean isTrue(Environment env) {
        String msg = "Error " + getLocation() + ". " 
                    + "\nExpecting a boolean here."
                    + " Expression " + this + " is a range.";
        throw new TemplateException(msg, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        RangeExpression result = new RangeExpression();
        result.add(getLeft().deepClone(name, subst));
        result.add(get(1));
        if (hasRhs()) result.add(getRight().deepClone(name, subst));
        return result;
    }

    private class NumericalRange extends AbstractList<Integer> {
        private int lower, upper;
        private boolean descending, norhs; // if norhs is true, then we have a half-range, like n..
        
        /**
        * Constructor for half-range, i.e. n..
        */
        public NumericalRange(int lower) {
            this.norhs = true;
            this.lower = lower;
        }

        public NumericalRange(int left, int right) {
            lower = Math.min(left, right);
            upper = Math.max(left, right);
            descending = (left != lower);
        }

        public Integer get(int i) {
            int index = descending ? (upper -i) : (lower + i);
            if ((norhs && index > upper) || index <lower) {
                throw new EvaluationException("out of bounds of range");
            }
            return index;
        }

        public int size() {
            return 1 + upper - lower;
        }
    }
}

AndExpression :
   EqualityExpression 
   [
      <AND>
      AndExpression
   ]
;

INJECT AndExpression :
    import freemarker.core.Environment;
    implements Expression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        return isTrue(env);
    }

    public boolean isTrue(Environment env) {
        return getLeft().isTrue(env) && getRight().isTrue(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        AndExpression result = new AndExpression();
        result.add(getLeft().deepClone(name,subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

OrExpression :
   AndExpression
   [
      <OR>
      OrExpression
   ]
;

INJECT OrExpression :
    import freemarker.core.Environment;
    implements Expression
{
    public Expression getLeft() {
    	return (Expression) get(0);
    }
    
    public Expression getRight() {
    	return (Expression) get(2);
    }

    public Object evaluate(Environment env) {
        return isTrue(env);
    }

    public boolean isTrue(Environment env) {
        return getLeft().isTrue(env) || getRight().isTrue(env);
    }

    public Expression _deepClone(String name, Expression subst) {
        OrExpression result = new OrExpression();
        result.add(getLeft().deepClone(name,subst));
        result.add(get(1));
        result.add(getRight().deepClone(name, subst));
        return result;
    }
}

ListLiteral :
    <OPEN_BRACKET>
    [
      Expression 
      (
         <COMMA>
         Expression 
      )*
    ]
    <CLOSE_BRACKET>
;

INJECT ListLiteral :
  import java.io.IOException;
  import java.util.ArrayList;
  import java.util.List;
  import freemarker.core.Environment;
  import freemarker.template.TemplateException;
  import freemarker.core.variables.scope.Scope;
  implements Expression
{
    public List<Expression> getElements() {
        return childrenOfType(Expression.class);
    }

    public Object evaluate(Environment env) {
        List<Object> result = new ArrayList<>();
        for (Expression exp : getElements()) {
            Object tm = exp.evaluate(env);
            assertIsDefined(tm, env);
            result.add(tm);
        }
        return result;
    }

    // A hacky routine used by VisitNode and RecurseNode
   public List evaluateStringsToNamespaces(Environment env) {
        List result = new ArrayList();
        for (Expression exp : getElements()) {
            if (exp instanceof StringLiteral) {
                String s = ((StringLiteral) exp).getAsString();
                try {
                    Scope ns = env.importLib(s, null);
                    result.add(ns);
                } catch (IOException ioe) {
                    throw new TemplateException("Could not import library '" + s + "', " + ioe.getMessage(), env);
                }
            } else {
                result.add(exp);
            }
        }
        return result;
    }    

    public Expression _deepClone(String name, Expression subst) {
        ListLiteral result = new ListLiteral();
        for (Node node : this) {
            if (node instanceof Expression) {
                node = ((Expression) node).deepClone(name, subst);
            }
            result.add(node);
        }
        return result;
    }
}

BuiltinVariable :
   <DOT>
   <ID>
   {
      CURRENT_NODE.setName(lastConsumedToken.toString());
   }
;

INJECT BuiltinVariable :
    import freemarker.core.variables.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ParseException;
    import freemarker.template.Configuration;
    import freemarker.template.TemplateException;
    import freemarker.template.TemplateHashModel;
    implements Expression
{
    private String name;

    public void setName(String name) {
      this.name = name.intern();
    }
    
    public String getName() {
        return name;
    }

    public Object evaluate(Environment env) {
        switch (name) {
           case "namespace" : return env.getCurrentNamespace();
           case "main" : return env.getMainNamespace();
           case "globals" : return env;
           case "locals" : return env.getCurrentMacroContext();
           case "data_model" : return env.getDataModel();
           case "scope" : return env.getCurrentScope();
           case "vars" : return new VarsHash(env);
           case "locale" : return env.getLocale().toString();
           case "lang" : return env.getLocale().getLanguage();
           case "current_node" :
           case "node" : return env.getCurrentVisitorNode();
           case "pass" : return Macro.DO_NOTHING_MACRO;
           case "name" : return env.getTemplate().getName(); 
           case "version" : return Configuration.getVersionNumber();
           case "output_encoding" : return env.getOutputEncoding();
           case "url_escaping_charset" : return env.getURLEscapingCharset();
           case "error" : return env.getCurrentRecoveredErrorMessage();
        }
        throw new TemplateException("Invalid built-in variable: " + this, env);
    }

    public Expression _deepClone(String name, Expression subst) {
        return this;
    }

    static class VarsHash implements TemplateHashModel {
        
        private final Environment env;
        
        VarsHash(Environment env) {
            this.env = env;
        }
        
        public Object get(String key) {
            return env.getVariable(key);
        }
        
        public boolean isEmpty() {
            return false;
        }
    }
}

INJECT DefaultToExpression : 
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    import static freemarker.core.variables.Wrap.NOTHING;
    import static freemarker.core.variables.Wrap.JAVA_NULL;
    implements Expression
{
	public Expression getLeft() {
		return (Expression) get(0);
	}
	
	public Expression getRight() {
		return childrenOfType(Expression.class).size() == 2 ?
		(Expression) getLastChild() : null;
	}

	public Object evaluate(Environment env) {
		Object left = null;		
		try {
			left = getLeft().evaluate(env);
		} catch (InvalidReferenceException ire) {
			if (!(getLeft() instanceof ParentheticalExpression)) {
				throw ire;
			}
		}
		if (left != null && left != JAVA_NULL) return left;
		if (getRight() == null) return NOTHING;
		return getRight().evaluate(env);
	}

	public Expression _deepClone(String name, Expression subst) {
		DefaultToExpression result = new DefaultToExpression();
		result.add(getLeft().deepClone(name, subst));
		result.add(get(1));
		if (getRight() != null) {
			result.add(getRight().deepClone(name, subst));
		}
		return result;
	}
}

INJECT ExistsExpression :
    import freemarker.core.Environment;
    import freemarker.core.variables.InvalidReferenceException;
    import static freemarker.core.variables.Wrap.JAVA_NULL;
    implements Expression
{
	public Expression getExpression() {
		return (Expression) get(0);
	}

	public Object evaluate(Environment env) {
		Object value = null;
		try {
			value = getExpression().evaluate(env);
		} catch (InvalidReferenceException ire) {
			if (!(getExpression() instanceof ParentheticalExpression)) {
				throw ire;
			}
		}
		return value != null && value != JAVA_NULL;
	}

	public Expression _deepClone(String name, Expression subst) {
		ExistsExpression result = new ExistsExpression();
		result.add(getExpression().deepClone(name, subst));
		return result;
	}
}

INJECT BuiltInExpression :
    import java.util.HashMap;
    import freemarker.core.Environment;
    import freemarker.builtins.*;
    import freemarker.template.TemplateDateModel;
    import freemarker.template.TemplateHashModel;
    implements Expression;
{
    private static final HashMap<String, BuiltIn> knownBuiltins = new HashMap<String, BuiltIn>();
    {
//        knownBuiltins.put("new", new newBI());
//        knownBuiltins.put("sort_by", new SequenceFunctions.SortBy());
//        knownBuiltins.put("seq_index_of", new SequenceFunctions.IndexOf());
//        knownBuiltins.put("seq_last_index_of", new SequenceFunctions.LastIndexOf());
//        knownBuiltins.put("if_exists", new ExistenceBuiltIn.IfExistsBuiltIn());
        knownBuiltins.put("instanceof", new instanceofBI());
        knownBuiltins.put("exists", new ExistenceBuiltIn.ExistsBuiltIn());
        knownBuiltins.put("c", new cBI());
        knownBuiltins.put("size", new sizeBI());
        knownBuiltins.put("string", new stringBI());
        knownBuiltins.put("eval", new evalBI());
        knownBuiltins.put("interpret", new interpretBI());
        knownBuiltins.put("resolve", new resolveBI());
        NumericalCast numericalCast = new NumericalCast();
        knownBuiltins.put("byte", numericalCast);
        knownBuiltins.put("double", numericalCast);
        knownBuiltins.put("float", numericalCast);
        knownBuiltins.put("int", numericalCast);
        knownBuiltins.put("long", numericalCast);
        knownBuiltins.put("short", numericalCast);
        knownBuiltins.put("floor", numericalCast);
        knownBuiltins.put("ceiling", numericalCast);
        knownBuiltins.put("round", numericalCast);
        knownBuiltins.put("capitalize", new StringTransformations.Capitalize());
        knownBuiltins.put("lower_case", new StringTransformations.LowerCase());
        knownBuiltins.put("upper_case", new StringTransformations.UpperCase());
        knownBuiltins.put("cap_first", new StringTransformations.CapFirst(true));
        knownBuiltins.put("uncap_first", new StringTransformations.CapFirst(false));
        knownBuiltins.put("j_string", new StringTransformations.Java());
        knownBuiltins.put("js_string", new StringTransformations.JavaScript());
        knownBuiltins.put("chop_linebreak", new StringTransformations.Chomp());
        knownBuiltins.put("trim", new StringTransformations.Trim());
        knownBuiltins.put("html", new StringTransformations.Html());
        knownBuiltins.put("rtf", new StringTransformations.Rtf());
        knownBuiltins.put("xml", new StringTransformations.Xml());
        knownBuiltins.put("xhtml", new StringTransformations.Xhtml());
        knownBuiltins.put("web_safe", knownBuiltins.get("html"));
        TypeChecks typeChecks = new TypeChecks();
        knownBuiltins.put("is_boolean", typeChecks);
        knownBuiltins.put("is_collection", typeChecks);
        knownBuiltins.put("is_date", typeChecks);
        knownBuiltins.put("is_enumerable", typeChecks);
        knownBuiltins.put("is_hash", typeChecks);
        knownBuiltins.put("is_hash_ex", typeChecks);
        knownBuiltins.put("is_indexable", typeChecks);
        knownBuiltins.put("is_directive", typeChecks);
        knownBuiltins.put("is_method", typeChecks);
        knownBuiltins.put("is_null", typeChecks);
        knownBuiltins.put("is_number", typeChecks);
        knownBuiltins.put("is_macro", typeChecks);
        knownBuiltins.put("is_node", typeChecks);
        knownBuiltins.put("is_sequence", typeChecks);
        knownBuiltins.put("is_string", typeChecks);
        knownBuiltins.put("is_transform", typeChecks);
        knownBuiltins.put("join", new StringFunctions.Join());
        knownBuiltins.put("index_of", new StringFunctions.IndexOf());
        knownBuiltins.put("last_index_of", new StringFunctions.LastIndexOf());
        knownBuiltins.put("contains", new StringFunctions.Contains());
        knownBuiltins.put("number", new numberBI());
        knownBuiltins.put("left_pad", new StringFunctions.LeftPad());
        knownBuiltins.put("right_pad", new StringFunctions.RightPad());
        knownBuiltins.put("length", new StringFunctions.Length());
        knownBuiltins.put("replace", new StringFunctions.Replace());
        knownBuiltins.put("split", new StringFunctions.Split());
        knownBuiltins.put("groups", new groupsBI());
        knownBuiltins.put("matches", new StringFunctions.Matches());
        knownBuiltins.put("starts_with", new StringFunctions.StartsWith());
        knownBuiltins.put("ends_with", new StringFunctions.EndsWith());
        knownBuiltins.put("substring", new StringFunctions.Substring());
        knownBuiltins.put("word_list", new StringFunctions.WordList());
        knownBuiltins.put("url", new StringFunctions.Url());
        knownBuiltins.put("parent", new NodeFunctions.Parent());
        knownBuiltins.put("children", new NodeFunctions.Children());
        knownBuiltins.put("node_name", new NodeFunctions.NodeName());
        knownBuiltins.put("node_type", new NodeFunctions.NodeType());
        knownBuiltins.put("node_namespace", new NodeFunctions.NodeNamespace());
        knownBuiltins.put("root", new NodeFunctions.Root());
        knownBuiltins.put("ancestors", new NodeFunctions.Ancestors());
        knownBuiltins.put("first", new SequenceFunctions.First());
        knownBuiltins.put("last", new SequenceFunctions.Last());
        knownBuiltins.put("reverse", new SequenceFunctions.Reverse());
        knownBuiltins.put("sort", new SequenceFunctions.Sort());
        knownBuiltins.put("chunk", new SequenceFunctions.Chunk());
        knownBuiltins.put("seq_contains", new SequenceContainsBuiltIn());
        knownBuiltins.put("scope", new MacroBuiltins.Scope());
        knownBuiltins.put("namespace", new MacroBuiltins.Namespace());
        knownBuiltins.put("keys", new HashBuiltin.Keys());
        knownBuiltins.put("values", new HashBuiltin.Values());
        knownBuiltins.put("date", new DateTime(TemplateDateModel.DATE));
        knownBuiltins.put("time", new DateTime(TemplateDateModel.TIME));
        knownBuiltins.put("datetime", new DateTime(TemplateDateModel.DATETIME));
        knownBuiltins.put("is_defined", new ExistenceBuiltIn.IsDefinedBuiltIn());
        knownBuiltins.put("default", new ExistenceBuiltIn.DefaultBuiltIn());
        knownBuiltins.put("has_content", new ExistenceBuiltIn.HasContentBuiltIn());
        knownBuiltins.put("source", new sourceBI());
    }

    private String key;
    private BuiltIn bi;

    public void close() {
        key = getKeyTok().toString().intern();
        bi = knownBuiltins.get(key);
    }

    public Expression getTarget() {
        return (Expression) get(0);
    }

    public Token getKeyTok() {
        return (Token) get(2);
    }

    public BuiltIn getBuiltIn() {
        return bi;
    }

    public Object evaluate(Environment env) {
        return bi.get(env, this);
    }

    public String getName() {
        return key;
    }

    public Expression _deepClone(String name, Expression subst) {
        BuiltInExpression result = new BuiltInExpression();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        result.add(getKeyTok());
        result.key = key;
        result.bi = bi;
        return result;
    }
}

INJECT MethodCall :
    import java.util.ArrayList;
    import java.util.List;
    import java.io.Writer;
    import java.io.IOException;
    import java.io.StringWriter;
    import java.util.function.BiFunction;
    import java.util.function.Function;
    import java.util.function.Supplier;
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    import static freemarker.core.variables.Wrap.wrap;
    import static freemarker.core.variables.Wrap.unwrap;
    implements Expression;
{

    public ArgsList getArgs() {
        return firstChildOfType(ArgsList.class);
    }

    public Expression getTarget() {
    	return (Expression) get(0);
    }
    
    public Object evaluate(Environment env) {
        Object value = getTarget().evaluate(env);
        if (value instanceof Callable) {
            Callable targetMethod = (Callable)value;
            ArgsList args = getArgs();
            List<Object> argumentList;
            if (args !=null) {
                argumentList = args.getParameterSequence(targetMethod, env);
            } else {
                argumentList = new ArrayList<>();
            }
            Object result = targetMethod.call(argumentList.toArray(new Object[argumentList.size()]));
            return wrap(result);
        }
        else if (value instanceof Supplier) {
            ArgsList argsList = getArgs();
            if (argsList != null && argsList.firstChildOfType(Expression.class) !=null) {
                throw new EvaluationException("The method " + getTarget() + " takes no arguments.");
            }
            Object result = ((Supplier)value).get();
            return wrap(result);
        }
        else if (value instanceof Function) {
            ArgsList args = getArgs();
            if (args == null || args.childrenOfType(Expression.class).size() != 1) {
                throw new EvaluationException("The method " + getTarget() + " takes exactly one argument.");
            }
            Expression argExp = (Expression)getArgs().get(0);
            Object arg = unwrap(argExp.evaluate(env));
            Object result = ((Function)value).apply(arg);
            return wrap(result);
        }
        else if (value instanceof BiFunction) {
            ArgsList args = getArgs();
            List<Expression> argExpressions = args == null ? new ArrayList<>() : args.childrenOfType(Expression.class);
            if (argExpressions.size() != 2) {
                throw new EvaluationException("The method " + getTarget() + " takes exactly two arguments.");
            }
            Object firstArg = argExpressions.get(0).evaluate(env);
            Object secondArg = argExpressions.get(1).evaluate(env);
            Object result = ((BiFunction)value).apply(firstArg, secondArg);
            return wrap(result);
        }
        else if (value instanceof TriFunction) {
            ArgsList args = getArgs();
            List<Expression> argExpressions = args == null ? new ArrayList<>() : args.childrenOfType(Expression.class);
            if (argExpressions.size() != 3) {
                throw new EvaluationException("The method " + getTarget() + " takes exactly three arguments.");
            }
            Object firstArg = argExpressions.get(0).evaluate(env);
            Object secondArg = argExpressions.get(1).evaluate(env);
            Object thirdArg = argExpressions.get(2).evaluate(env);
            Object result = ((TriFunction)value).apply(firstArg, secondArg, thirdArg);
            return wrap(result);
        }
        else if (value instanceof QuadFunction) {
            ArgsList args = getArgs();
            List<Expression> argExpressions = args == null ? new ArrayList<>() : args.childrenOfType(Expression.class);
            if (argExpressions.size() != 4) {
                throw new EvaluationException("The method " + getTarget() + " takes exactly four arguments.");
            }
            Object firstArg = argExpressions.get(0).evaluate(env);
            Object secondArg = argExpressions.get(1).evaluate(env);
            Object thirdArg = argExpressions.get(2).evaluate(env);
            Object fourthArg = argExpressions.get(3).evaluate(env);
            Object result = ((QuadFunction)value).apply(firstArg, secondArg, thirdArg, fourthArg);
            return wrap(result);
        }
        else if (value instanceof Macro) {
            Macro func = (Macro) value;
            StringWriter sw = null;
            env.setLastReturnValue(null);
            Writer prevOut = env.getOut();
            try {
                env.setOut(Environment.NULL_WRITER);
                if (!func.isFunction()) {
                    sw = new StringWriter();
                    env.setOut(sw);
                 }
                env.render(func, getArgs(), null, null);
            } catch (IOException ioe) {
                throw new InternalError("This should be impossible.");
            } finally {
                env.setOut(prevOut);
            }
            return sw != null ? sw.getBuffer().toString() : env.getLastReturnValue();
        }
        throw invalidTypeException(value, getTarget(), env, "method");
    }

    public Expression _deepClone(String name, Expression subst) {
        MethodCall result = new MethodCall();
        result.add(getTarget().deepClone(name, subst));
        result.add(get(1));
        ArgsList args = getArgs();
        if (args != null) {
            result.add(getArgs().deepClone(name, subst));
            result.add(get(3));
        } else {
            result.add(get(2));
        }
        return result;
    }
}

PositionalArgsList# : 
	Expression 
	(
	   [<COMMA>]
	   Expression 
	)*
;

INJECT PositionalArgsList :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    import freemarker.template.utility.UndeclaredThrowableException;
    import freemarker.core.nodes.ParameterList;
    extends ArgsList
{
   public List getParameterSequence(Object target, Environment env) {
        ParameterList annotatedParameterList = getParameterList(target);
        if (annotatedParameterList == null) {
            List<Object> result = new ArrayList<>();
            for (Expression exp : childrenOfType(Expression.class)) {
               result.add(exp.evaluate(env));
            }
            return result;
        }
        return annotatedParameterList.getParameterSequence(this, env);
    }

    public Map<String, Object> getParameterMap(Object target, Environment env)
    {
        Map<String, Object> result = new HashMap<String, Object>();
        ParameterList annotatedParameterList = getParameterList(target);
        if (annotatedParameterList == null) {
            if (firstChildOfType(Expression.class) != null) {
                throw new EvaluationException("Cannot pass positional arguments to this UserDirective");
            }
        }
        else {
            result = annotatedParameterList.getParameterMap(this, env, false);
        }
        return result;
    }

    public Object getValueAt(int i, Environment env) {
        Expression exp = childrenOfType(Expression.class).get(i);
        Object value = exp.evaluate(env);
        exp.assertIsDefined(value, env);
        return value;
    }

    public PositionalArgsList deepClone(String name, Expression subst) {
        PositionalArgsList result = new PositionalArgsList();
        for (Node node : this) {
            if (node instanceof Expression) {
                node = ((Expression)node).deepClone(name, subst);
            }
            result.add(node);
        }
        return result;
    }    
}

NamedArgsList :
{
    String param;
	Expression arg;
}
	<ID> {param = lastConsumedToken.toString();}
	<EQUALS> 
	arg=Expression  
	{
		CURRENT_NODE.addNamedArg(param, arg);
	}
	(
	   [<COMMA>]
	   <ID> {param = lastConsumedToken.toString();}
	   <EQUALS>
	   arg=Expression
	   {CURRENT_NODE.addNamedArg(param, arg);}
	)*
;

INJECT NamedArgsList :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.nodes.ParameterList;
    import freemarker.core.parser.ParseException;
    import freemarker.template.*;
    extends ArgsList;
{

    private LinkedHashMap<String,Expression> namedArgs = 
        new LinkedHashMap<String, Expression>();

    public void addNamedArg(String name, Expression exp) throws ParseException{
        if (namedArgs.containsKey(name)) throw new ParseException(
                "Error at: " + exp.getLocation() + "\nArgument " + name + " was already specified.");
        namedArgs.put(name, exp);
        exp.setParent(this);
    }

    public Map<String, Expression> getArgs() {
        return namedArgs;
    }

    public int size() {
        return namedArgs.size();
    }

    public Map<String,Expression> getCopyOfMap() {
        return (Map<String,Expression>)namedArgs.clone();
    }

    public Map<String, Object> getParameterMap(Object tm, Environment env) {
        Map<String, Object> result = null; 
        ParameterList annotatedParameterList = ArgsList.getParameterList(tm);
        if (annotatedParameterList == null) {
            result = new HashMap<String, Object>();
            for (String paramName : namedArgs.keySet()) {
                Expression exp = namedArgs.get(paramName);
                Object value = exp.evaluate(env);
                exp.assertIsDefined(value, env);
                result.put(paramName, value);
            }
        }
        else {
            result = annotatedParameterList.getParameterMap(this, env);
        }
        return result;
    }

    public List<Object> getParameterSequence(Object target, Environment env) {
        ParameterList annotatedParameterList = getParameterList(target);
        if (annotatedParameterList == null) {
            String msg = "Error at: " + getLocation() 
            + "\nCannot invoke method " + target + " with a key=value parameter list because it is not annotated.";
            throw new TemplateException(msg, env);
        }
        return annotatedParameterList.getParameterSequence(this, env);
    }

    public ArgsList deepClone(String name, Expression subst) {
        NamedArgsList result = new NamedArgsList();
        for (Map.Entry<String, Expression> entry : namedArgs.entrySet()) {
            try {
                result.addNamedArg(entry.getKey(), entry.getValue());
            } catch (ParseException pe) {} // This can't happen anyway, since we already checked for repeats
        }
        return result;
    }
}

ArgsList#abstract :
	(
	   SCAN <ID><EQUALS> =>
       NamedArgsList
       |
       PositionalArgsList
    )
;

INJECT ArgsList :
    import java.util.*;
    import java.util.concurrent.ConcurrentHashMap;
    import java.lang.reflect.*;

    import freemarker.annotations.Parameters;
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    import freemarker.core.parser.*;
    import freemarker.core.parser.FMLexer.LexicalState;
    import freemarker.core.nodes.ParameterList;
    import freemarker.template.TemplateException;
    import freemarker.template.TemplateMethodModel;
{
	/**
	 * Cache the retrieved annotation information, since it seems like 
	 * this operation could be a bit expensive.
	 */
	private static Map<String, ParameterList> parameterListCache = new ConcurrentHashMap<String, ParameterList>();
   // Placeholder for null - ConcurrentHashMap doesn't tolerate null values
	private static final ParameterList NO_PARAM_LIST = new ParameterList();
        
	/**
	 * The target will be either a TemplateTranformModel or a TemplateMethodModel.
	 * This returns a key-value map of the arguments to be passed to the target.
	 * A TemplateException will be thrown if the target's parameters do not match
	 * this ArgList in some way.
	 */
	public abstract Map<String, Object> getParameterMap(Object target, Environment env);
	
	public abstract List<Object> getParameterSequence(Object target, Environment env);
	
	public static ParameterList getParameterList(Object target) {
            String keyName = target.getClass().getName();
            ParameterList result = parameterListCache.get(keyName);
            if(result == NO_PARAM_LIST) {
                return null;
            }
            if(result != null) {
                return result;
            }
            Parameters params = getAnnotatedParameters(target);
            if (params != null) {
                String paramString = params.value();
                if("".equals(paramString)) {
                    result = new ParameterList();
                }
                else try {
                    result = getParameterList(paramString);
                } catch (Exception pe) {
                    throw new TemplateException("Can't parse parameter list [" + paramString + "] on " + target, pe, Environment.getCurrentEnvironment());
                }
                parameterListCache.put(keyName, result);
                return result;
            } else {
                parameterListCache.put(keyName, NO_PARAM_LIST);
                return null;
            }
	}
	
	private static ParameterList getParameterList(String s) {
		FMLexer token_source = new FMLexer(s);
		token_source.switchTo(LexicalState.EXPRESSION);
		FMParser parser = new FMParser(token_source);
		return parser.ParameterList();
	}

    @SuppressWarnings("deprecation")
    private static Parameters getAnnotatedParameters(Object target) {
        Parameters params = null;
        Method keyMethod = null;
        if (target instanceof TemplateMethodModel) {
            try {
                keyMethod = target.getClass().getMethod("exec", new Class[] {List.class});
            } catch (Exception e) {
                // This condition should be impossible. If something is
                // a TemplateMethodModel, it must implement this method.
                throw new InternalError(e.getMessage());
            }
        }
        else if (target instanceof Callable) {
            try {
                keyMethod = target.getClass().getMethod("call", new Class[] {new Object[0].getClass()});
            } catch (Exception e) {
                // Again, this condition should be impossible. If something is
                // a Callable, it must implement this method.
                throw new InternalError(e.getMessage());
            }
        }
        if (keyMethod != null) {
            params = keyMethod.getAnnotation(Parameters.class);
        }
        if (params == null) {
            // Check if the class is annotated now
            params = target.getClass().getAnnotation(Parameters.class);
        }
        return params;
    }
	
	public abstract ArgsList deepClone(String name, Expression subst);
}

HashLiteral :
   <OPEN_BRACE>
   [
       Expression
       <COLON>
       Expression
       (
          <COMMA>
           Expression
           <COLON>
           Expression
       )*
   ]
   <CLOSE_BRACE>
;

INJECT HashLiteral :
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    import freemarker.core.ast.CollectionAndSequence;
    implements Expression
{
    private List<Expression> keys = new ArrayList<>();
    private List<Expression> values = new ArrayList<>();
    
    public void close() {
        boolean justSawKey = false;
        for (Expression exp : childrenOfType(Expression.class)) {
            if (justSawKey) values.add(exp);
            else keys.add(exp);
            justSawKey = !justSawKey;
       }
       assert keys.size() == values.size() : getSource();
    }
    
    public Object evaluate(Environment env) {
        Map<Object,Object> result = new LinkedHashMap<>();
        for (int i = 0; i < keys.size(); i++) {
            Object key = keys.get(i).evaluate(env);
            Object value = values.get(i).evaluate(env);
            result.put(key, value);
        }
        return result;
    }
    
    public List<Expression> getKeys() {
    	return Collections.unmodifiableList(keys);
    }
    
    public List<Expression> getValues() {
    	return Collections.unmodifiableList(values);
    }

    public Expression _deepClone(String name, Expression subst) {
    	HashLiteral result = new HashLiteral();
        for (int i = 0; i< keys.size(); i++) {
            Expression keyClone = keys.get(i).deepClone(name, subst);
            Expression valueClone = values.get(i).deepClone(name, subst);
            result.keys.add(keyClone);
            result.values.add(valueClone);
        }
        result.close();
        return result;
    }
}

INJECT MethodReference :
    import freemarker.core.Environment;
    import freemarker.core.variables.JavaMethodCall;
    implements Expression
{
    public Expression getTarget() {
        return (Expression) get(0);
    }

    public Object evaluate(Environment env) {
        Object target = getTarget().evaluate(env);
        String methodName = get(2).toString();
        return new JavaMethodCall(target, methodName);
    }

    public Expression _deepClone(String name, Expression subst) {
        Expression clonedTarget = getTarget().deepClone(name, subst);
        Token op = (Token) get(1);
        Token key = (Token) get(2);
        Expression result = new MethodReference();
        result.add(clonedTarget);
        result.add(op);
        result.add(key);
        return result;
    }
}