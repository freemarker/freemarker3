BASE_SRC_DIR="..";
PARSER_PACKAGE="freemarker.core.parser";
BASE_NODE_CLASS=TemplateNode;
PRESERVE_TABS;
DEACTIVATE_TOKENS=EOL;

INCLUDE "FMLexer.ccc"
INCLUDE "Expressions.inc.ccc"
INCLUDE "Directives.inc.ccc"

INJECT Node : 
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.InvalidReferenceException;
   import freemarker.core.EvaluationUtil;
   import freemarker.core.parser.ast.Expression;
   import static freemarker.template.Constants.JAVA_NULL;
   import static freemarker.ext.beans.ObjectWrapper.*;
{
    void setTemplate(Template template);
    
    Template getTemplate();

    default String getLocation() {
        String templateName = getTemplate() != null ? getTemplate().getName() : getInputSource();
        return "on line " 
              + getBeginLine() 
              + ", column " 
              + getBeginColumn()
              + " in "
              + templateName;
    }

    default void copyLocationFrom(Node from)
    {
        setBeginOffset(from.getBeginOffset());
        setEndOffset(from.getEndOffset());
    }

}

INJECT BASE_NODE_CLASS :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.parser.Token;
   import freemarker.core.parser.ast.Expression;
{
	@Property Template template;
	
	public String getDescription() {
		return getClass().getSimpleName();
	}

    static public TemplateException invalidTypeException(Object model, Expression exp, Environment env, String expected)
    {
        exp.assertNonNull(model, env);
        return new TemplateException(
            "Expected " + expected + ". " + 
            exp + " evaluated instead to " + 
            model.getClass().getName() + " " +
            exp.getLocation() + ".", env);
    }
    
}

INJECT Token :
    import freemarker.template.Template;
{
    @Property Template template;
}


INJECT PARSER_CLASS : 
    import freemarker.core.ast.TextBlock;
    import freemarker.template.*;
    import freemarker.template.utility.StringUtil;
    import java.util.HashSet;
    import java.util.List;
    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.Set;
    import java.util.StringTokenizer;
{
    // Necessary for adding macros and setting location info.
    @Property Template template;
    private String templateName;
    private boolean stripText;

    void OPEN_NODE_HOOK(Node n) {
         n.setTemplate(template);
         n.setTokenSource(token_source);
    }

    /**
    * Create an FM expression parser using a string.
    */
    static public FMParser createExpressionParser(String s) {
        FMLexer lexer;
        try {
            lexer = new FMLexer(s);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        lexer.switchTo(LexicalState.EXPRESSION);
        return new FMParser(lexer);
    }

    /**
    * Constructs a new parser object.
    * @param template The template associated with this parser.
    * @param path The character stream to use as input
    */
    public FMParser(Template template, Path path) throws IOException {
        this(path);
        this.template = template;
        this.templateName = template != null ? template.getName() : "";
        token_source.templateName = templateName;
        template.setTokenSource(token_source);
    }

    public FMParser(Template template, CharSequence input) {
        this (input);
        this.template = template;
        this.templateName = template != null ? template.getName() : "";
        template.setTokenSource(token_source);
    }

    private String getErrorStart(Token t) {
        return "Error in template: " + template.getName() + "\non line " + t.getBeginLine() + ", column " + t.getBeginColumn();
    }
}
 
INJECT ParseException  : 
    import java.util.*;
    import freemarker.core.parser.ast.TemplateNode;
{
    int lineNumber, columnNumber;
    String templateName;
    public List<ParsingProblem> problems;

    public ParseException(String message, int lineNumber, int columnNumber) {
        super(message);
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }

    public ParseException(String message, TemplateNode tobj) {
        super(message);
        this.lineNumber = tobj.getBeginLine();
        this.columnNumber = tobj.getBeginColumn();
        problems = new ArrayList<ParsingProblem>();
        problems.add(new ParsingProblem(message, tobj));
    }

    public ParseException(List<ParsingProblem> problems) {
        this.problems = problems;
    }

    public void setTemplateName(String templateName) {
        this.templateName = templateName;
    }
}
