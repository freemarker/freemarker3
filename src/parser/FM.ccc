BASE_SRC_DIR="..";
PARSER_PACKAGE="freemarker.core.parser";
BASE_NODE_CLASS=TemplateNode;
NODE_DEFAULT_VOID;
PRESERVE_LINE_ENDINGS;
PRESERVE_TABS;
//TOKENS_ARE_NODES=false;
//NODE_PREFIX="AST";

INCLUDE "FMLexer.ccc"
INCLUDE "Expressions.inc.ccc"
INCLUDE "Directives.inc.ccc"

INJECT BASE_NODE_CLASS :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.InvalidReferenceException;
   import freemarker.core.helpers.DefaultReferenceChecker;
   import freemarker.core.helpers.DefaultTreeDumper;
   import freemarker.core.parser.Token;
   import freemarker.core.parser.ast.Expression;
{
	@Property Template template;
	
	static public int TAB_SIZE = 8;
	
	public String getDescription() {
		return "";
	}
	
    public int getEndLine() {
      TokenSource tokenSource = getTokenSource();
      return tokenSource == null ? 0 : tokenSource.getLineFromOffset(getEndOffset());
	}
	
	public int getEndColumn() {
      TokenSource tokenSource = getTokenSource();
      return tokenSource == null ? 0 : tokenSource.getCodePointColumnFromOffset(getEndOffset());
	}
	
    /**
     * Returns a string that indicates
     * where in the template source, this object is.
     */
    public String getStartLocation() {
        String templateName = template != null ? template.getName() : getInputSource();
        return "on line " 
              + getBeginLine() 
              + ", column " 
              + getBeginColumn()
              + " in "
              + templateName;
    }

    public void copyLocationFrom(TemplateNode from)
    {
        beginOffset = from.getBeginOffset();
        endOffset = from.getEndOffset();
    }


	static private DefaultReferenceChecker referenceChecker = DefaultReferenceChecker.instance;
	static private DefaultTreeDumper canonicalTreeRenderer = new DefaultTreeDumper(false);

    public String toString() {
    	return getSource();
    }
    
    static public TemplateException invalidTypeException(Object model, Expression exp, Environment env, String expected)
    {
        assertNonNull(model, exp, env);
        return new TemplateException(
            "Expected " + expected + ". " + 
            exp + " evaluated instead to " + 
            model.getClass().getName() + " " +
            exp.getStartLocation() + ".", env);
    }
    
    static public void assertNonNull(Object model, Expression exp, Environment env) throws InvalidReferenceException {
    	referenceChecker.assertNonNull(model, exp, env);
    }
    
    static public void assertIsDefined(Object model, Expression exp, Environment env) throws InvalidReferenceException {
    	referenceChecker.assertIsDefined(model, exp, env);
    }
}

INJECT Node : 
   import freemarker.template.Template;
{
    default void setTemplate(Template template) {}

    default void setLocation(Template template, TokenSource tokenSource, Node begin, Node end) {
        setTemplate(template);
        setTokenSource(tokenSource);
        setBeginOffset(begin.getBeginOffset());
        setEndOffset(end.getEndOffset());
    }

	default int getOffset(int line, int column) {
		return getTokenSource().getLineStartOffset(line) + column -1;
	}
}

INJECT PARSER_CLASS : 
    import freemarker.core.ast.TextBlock;
    import freemarker.template.*;
    import freemarker.template.utility.StringUtil;
    import java.util.HashSet;
    import java.util.List;
    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.Set;
    import java.util.StringTokenizer;
{
    // Necessary for adding macros and setting location info.
    @Property Template template;
    private String templateName;
    private boolean stripText;

    void OPEN_NODE_HOOK(Node n) {
         n.setTemplate(template);
         n.setTokenSource(token_source);
    }

    /**
    * Create an FM expression parser using a string.
    */
    static public FMParser createExpressionParser(String s) {
        FMLexer lexer;
        try {
            lexer = new FMLexer(s);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        lexer.switchTo(LexicalState.EXPRESSION);
        return new FMParser(lexer);
    }

    /**
    * Constructs a new parser object.
    * @param template The template associated with this parser.
    * @param path The character stream to use as input
    */
    public FMParser(Template template, Path path) throws IOException {
        this(path);
        this.template = template;
        this.templateName = template != null ? template.getName() : "";
        token_source.templateName = templateName;
        template.setTokenSource(token_source);
    }

    public FMParser(Template template, Path path, int syntaxSetting) throws IOException {
        this(template, path);
        if (syntaxSetting != Configuration.AUTO_DETECT_TAG_SYNTAX) {
            token_source.setAltDirectiveSyntax(syntaxSetting == Configuration.SQUARE_BRACKET_TAG_SYNTAX);
        }
    }

    public FMParser(Template template, CharSequence input, int syntaxSetting) {
        this (input);
        this.template = template;
        this.templateName = template != null ? template.getName() : "";
         if (syntaxSetting != Configuration.AUTO_DETECT_TAG_SYNTAX) {
            token_source.setAltDirectiveSyntax(syntaxSetting == Configuration.SQUARE_BRACKET_TAG_SYNTAX);
        }
        template.setTokenSource(token_source);
    }

    private String getErrorStart(Token t) {
        return "Error in template: " + template.getName() + "\non line " + t.getBeginLine() + ", column " + t.getBeginColumn();
    }

    public boolean isSyntaxSet() {
        return token_source.directiveSyntaxEstablished;
    }

    public boolean isAltDirectiveSyntax() {
        return token_source.altDirectiveSyntax;
    }
}
 
INJECT ParseException  : 
    import java.util.*;
    import freemarker.core.parser.ast.TemplateNode;
{
    int lineNumber, columnNumber;
    String templateName;
    public List<ParsingProblem> problems;

    public ParseException(String message, int lineNumber, int columnNumber) {
        super(message);
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }

    public ParseException(String message, TemplateNode tobj) {
        super(message);
        this.lineNumber = tobj.getBeginLine();
        this.columnNumber = tobj.getBeginColumn();
        problems = new ArrayList<ParsingProblem>();
        problems.add(new ParsingProblem(message, tobj));
    }

    public ParseException(List<ParsingProblem> problems) {
        this.problems = problems;
    }

    public void setTemplateName(String templateName) {
        this.templateName = templateName;
    }

}
