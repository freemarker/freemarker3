BASE_SRC_DIR="..";
PARSER_PACKAGE="freemarker.core.parser";
BASE_NODE_CLASS=TemplateNode;
PRESERVE_TABS;

INCLUDE "FMLexer.ccc"
INCLUDE "Expressions.inc.ccc"
INCLUDE "Directives.inc.ccc"

INJECT Node : 
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.InvalidReferenceException;
   import freemarker.core.EvaluationUtil;
   import freemarker.core.parser.ast.Expression;
   import static freemarker.template.Constants.JAVA_NULL;
   import static freemarker.ext.beans.ObjectWrapper.*;
{
    void setTemplate(Template template);
    
    Template getTemplate();

    default String getStartLocation() {
        String templateName = getTemplate() != null ? getTemplate().getName() : getInputSource();
        return "on line " 
              + getBeginLine() 
              + ", column " 
              + getBeginColumn()
              + " in "
              + templateName;
    }

    default void copyLocationFrom(Node from)
    {
        setBeginOffset(from.getBeginOffset());
        setEndOffset(from.getEndOffset());
    }

    static void assertNonNull(Object model, Expression exp, Environment env) {
        assertIsDefined(model, exp, env);
        if (model == JAVA_NULL) {
            throw new InvalidReferenceException(
                "Expression " + exp + " is null " +
                exp.getStartLocation() + ".", env);
        }
    }
    
    static void assertIsDefined(Object model, Expression exp, Environment env) {
        if (model == null) {
            throw new InvalidReferenceException(
                "Expression " + exp + " is undefined " +
                exp.getStartLocation() + ".", env);
        }
    }

    static boolean isDisplayableAsString(Object tm) {
    	return isString(tm)
    	     || isNumber(tm)
    	     || tm instanceof TemplateDateModel;
    }
    
    static String getStringValue(Object referent, Expression exp, Environment env)
    {
        if (isNumber(referent)) {
            return env.formatNumber(asNumber(referent));
        }
        if (referent instanceof TemplateDateModel) {
            TemplateDateModel dm = (TemplateDateModel) referent;
            return env.formatDate(EvaluationUtil.getDate(dm, exp, env), dm.getDateType());
        }
        if (isString(referent)) {
            return asString(referent);
        }
        Node.assertNonNull(referent, exp, env);
        String msg = "Error " + exp.getStartLocation()
                     +"\nExpecting a string, " 
                     + "date or number here, Expression " + exp 
                     + " is instead a " 
                     + referent.getClass().getName();
        throw new TemplateException(msg, env);
    }
}

INJECT BASE_NODE_CLASS :
   import freemarker.template.*;
   import freemarker.core.Environment;
   import freemarker.core.helpers.DefaultTreeDumper;
   import freemarker.core.parser.Token;
   import freemarker.core.parser.ast.Expression;
{
	@Property Template template;
	
	static public int TAB_SIZE = 8;
	
	public String getDescription() {
		return "";
	}
    
    /**
     * Returns a string that indicates
     * where in the template source, this object is.
     *//*
    public String getStartLocation() {
        String templateName = template != null ? template.getName() : getInputSource();
        return "on line " 
              + getBeginLine() 
              + ", column " 
              + getBeginColumn()
              + " in "
              + templateName;
    }*/


    public String toString() {
    	return getSource();
    }
    
    static public TemplateException invalidTypeException(Object model, Expression exp, Environment env, String expected)
    {
        Node.assertNonNull(model, exp, env);
        return new TemplateException(
            "Expected " + expected + ". " + 
            exp + " evaluated instead to " + 
            model.getClass().getName() + " " +
            exp.getStartLocation() + ".", env);
    }
    
}

INJECT Token :
    import freemarker.template.Template;
{
    @Property Template template;
}


INJECT PARSER_CLASS : 
    import freemarker.core.ast.TextBlock;
    import freemarker.template.*;
    import freemarker.template.utility.StringUtil;
    import java.util.HashSet;
    import java.util.List;
    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.Set;
    import java.util.StringTokenizer;
{
    // Necessary for adding macros and setting location info.
    @Property Template template;
    private String templateName;
    private boolean stripText;

    void OPEN_NODE_HOOK(Node n) {
         n.setTemplate(template);
         n.setTokenSource(token_source);
    }

    /**
    * Create an FM expression parser using a string.
    */
    static public FMParser createExpressionParser(String s) {
        FMLexer lexer;
        try {
            lexer = new FMLexer(s);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        lexer.switchTo(LexicalState.EXPRESSION);
        return new FMParser(lexer);
    }

    /**
    * Constructs a new parser object.
    * @param template The template associated with this parser.
    * @param path The character stream to use as input
    */
    public FMParser(Template template, Path path) throws IOException {
        this(path);
        this.template = template;
        this.templateName = template != null ? template.getName() : "";
        token_source.templateName = templateName;
        template.setTokenSource(token_source);
    }

    public FMParser(Template template, CharSequence input) {
        this (input);
        this.template = template;
        this.templateName = template != null ? template.getName() : "";
        template.setTokenSource(token_source);
    }

    private String getErrorStart(Token t) {
        return "Error in template: " + template.getName() + "\non line " + t.getBeginLine() + ", column " + t.getBeginColumn();
    }
}
 
INJECT ParseException  : 
    import java.util.*;
    import freemarker.core.parser.ast.TemplateNode;
{
    int lineNumber, columnNumber;
    String templateName;
    public List<ParsingProblem> problems;

    public ParseException(String message, int lineNumber, int columnNumber) {
        super(message);
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }

    public ParseException(String message, TemplateNode tobj) {
        super(message);
        this.lineNumber = tobj.getBeginLine();
        this.columnNumber = tobj.getBeginColumn();
        problems = new ArrayList<ParsingProblem>();
        problems.add(new ParsingProblem(message, tobj));
    }

    public ParseException(List<ParsingProblem> problems) {
        this.problems = problems;
    }

    public void setTemplateName(String templateName) {
        this.templateName = templateName;
    }
}
