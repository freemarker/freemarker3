// This file defines the various 
// template elements. It is INCLUDEd
// from the main template.

/**
 * A production representing the ${...}
 * that outputs a variable.
 */
TemplateElement StringOutput :
{
   Expression exp;
   Token begin, end;
   boolean unclosed = false;
}
   begin=<OUTPUT_ESCAPE> 
   exp=Expression
	end=<CLOSE_BRACE>
   {
   	TemplateElement result = new Interpolation(exp);
      result.setLocation(template, token_source, begin, end);
      return result;
   }
;

TemplateElement If :
{
    Token start, end, t;
    Expression condition;
    TemplateElement block;
    IfBlock ifBlock;
    ConditionalBlock cblock;
}
   start=<IF>
   condition=Expression
   <DIRECTIVE_END>
   block=OptionalBlock
   {
      cblock = new ConditionalBlock(condition, block, true);
      cblock.setLocation(template, token_source, start, block);
      ifBlock = new IfBlock(cblock);
   }
   (
       t=<ELSE_IF>
       condition=Expression
       LooseDirectiveEnd
       block=OptionalBlock
       {
          cblock = new ConditionalBlock(condition, block, false);
          cblock.setLocation(template, token_source, t, block);
          ifBlock.addBlock(cblock);
       }
   )*
   [
         t=<ELSE>
         block=OptionalBlock
         {
            cblock = new ConditionalBlock(null, block, false);
            cblock.setLocation(template, token_source, t, block);
            ifBlock.addBlock(cblock);
         }
   ]
   end=CloseDirectiveBlock("if")
   {
       ifBlock.setLocation(template, token_source, start, end);
       return ifBlock;
   }
;

AttemptBlock Attempt :
{
   Token start, end;
   TemplateElement block=null, recoveryBlock;
   ParseException problem = null;
}
   start=<_ATTEMPT>
   block=OptionalBlock
   recoveryBlock=Recover
   end=CloseDirectiveBlock("attempt, recover")
   {
      AttemptBlock result = new AttemptBlock(block, recoveryBlock);
      result.setLocation(template, token_source, start, end);
      if (problem != null) {
      	ParsingProblem pp = new ParsingProblem(problem.getMessage(), result);
      	result.addParsingProblem(pp);
      }
      return result;
   }
;

RecoveryBlock Recover : 
{
   Token start;
   TemplateElement block;
}
   start=<_RECOVER>
   block=OptionalBlock
   {
      RecoveryBlock result = new RecoveryBlock(block);
      result.setLocation(template, token_source, start, block);
      return result;
   }
;

TemplateElement List :
{
    Expression exp;
    Token index, start, end, as=null, directiveEnd=null;
    TemplateElement block;
}
   start=<LIST> 
   exp=Expression
   <AS>
   index=<ID>
   <DIRECTIVE_END>
   block=OptionalBlock
   end=CloseDirectiveBlock("list")
   {
     IteratorBlock result = new IteratorBlock(exp,
                                              index.toString(),
                                              block,
                                              false);
     result.setLocation(template, token_source, start, end);
     return result;
   }
;

IteratorBlock ForEach :
{
     Expression exp;
     Token index, start, end;
     TemplateElement block;
}
   start=<FOREACH> 
   index=<ID>
   <IN>
   exp=Expression
   <DIRECTIVE_END>
   block=OptionalBlock
   end=CloseDirectiveBlock("foreach")
   {
     IteratorBlock result = new IteratorBlock(exp,
                                              index.toString(),
                                              block,
                                              true);
     result.setLocation(template, token_source, start, end);
     return result;
   }
;

VisitNode Visit :
{
   Token start, end;
   Expression targetNode, namespaces=null;
}
   start=<VISIT>
   targetNode=Expression
   [
       <USING>
       namespaces=Expression
   ]
   end=LooseDirectiveEnd
   {
       VisitNode result = new VisitNode(targetNode, namespaces);
       result.setLocation(template, token_source, start, end);
       return result;
   }
;

RecurseNode Recurse :
{
   Token start, end = null;
   Expression node=null, namespaces=null;
}
   (
      start=<SIMPLE_RECURSE>
      |
      (
         start=<RECURSE>
         [
            node=Expression
         ]
         [
            <USING>
            namespaces=Expression
         ]
         end=LooseDirectiveEnd
      )
   )
   {
       if (end == null) end = start;
       RecurseNode result = new RecurseNode(node, namespaces);
       result.setLocation(template, token_source, start, end);
       return result;
   }
;

FallbackInstruction FallBack :
{
   Token tok;
}
   tok=<FALLBACK>
   {
      FallbackInstruction result = new FallbackInstruction();
      result.setLocation(template, token_source, tok, tok);
      return result;
   }
;

/**
 * Production used to break out of a loop or a switch block.
 */
BreakInstruction Break :
{
   Token start;
}
    start=<BREAK>
    {
       BreakInstruction result = new BreakInstruction();
       result.setLocation(template, token_source, start, start);
       return result;
    }
;

/**
 * Production used to jump out of a macro.
 * The stop instruction terminates the rendering of the template.
 */
ReturnInstruction Return :
{
   Token start, end=null;
   Expression exp = null;
}
   (
      start=<SIMPLE_RETURN>{end = start;}
      |
      start=<RETURN> 
      exp=Expression 
      end=LooseDirectiveEnd
   )
   {
      ReturnInstruction result = new ReturnInstruction(exp);
      result.setLocation(template, token_source, start, end);
      return result;
   }
;

StopInstruction Stop :
{
   Token start = null;
   Expression exp = null;
}
    (
      start=<HALT>
      |
      start=<STOP> exp=Expression LooseDirectiveEnd
    )
    {
       StopInstruction result = new StopInstruction(exp);
       result.setLocation(template, token_source, start, start);
       return result;
    }
;

TemplateElement Nested :
{
  Token t, end;
  PositionalArgsList args=null;
  BodyInstruction result = null;
}
   (
      (
         t=<SIMPLE_NESTED>
         {
            result = new BodyInstruction(null);
            result.setLocation(template, token_source, t, t);
         }
      )
      |
      (
          t=<NESTED>
          args=PositionalArgsList
          end=LooseDirectiveEnd
          {
             result = new BodyInstruction(args);
             result.setLocation(template, token_source, t, end);
          }
      )
   )
   {
       return result;
   }
;

TemplateElement Flush :
{
  Token t;
}
   t=<FLUSH>
   {
       FlushInstruction result = new FlushInstruction();
       result.setLocation(template, token_source, t, t);
       return result;
   }
;

TemplateElement Trim :
{
  Token t;
  TrimInstruction result=null;
}
   (
     t=<TRIM> {result = new TrimInstruction(true, true);}
     |
     t=<LTRIM> {result = new TrimInstruction(true, false);}
     |
     t=<RTRIM> {result = new TrimInstruction(false, true);}
     |
     t=<NOTRIM> {result = new TrimInstruction(false, false);}
   )
   {
       result.setLocation(template, token_source, t, t);
       return result;
   }
;

TemplateElement Assign :
{
   Token start, end;
   int type;
   Token id=null;
   Expression nameExp, exp, nsExp=null;
   String varName;
   TemplateElement block;
   Map<String, Expression> assignments = new LinkedHashMap<>();
   String assignmentType;
   AssignmentInstruction result;
}
    (
      start=<ASSIGN> {type = AssignmentInstruction.NAMESPACE; assignmentType="assign";}
      |
      start=<GLOBALASSIGN>{type = AssignmentInstruction.GLOBAL; assignmentType = "global";}
      |
      start=<LOCALASSIGN> {type = AssignmentInstruction.LOCAL; assignmentType = "local";}
      |
      start=<SET> {type = AssignmentInstruction.SET; assignmentType = "set";}
    )
    {result = new AssignmentInstruction(type);}
    nameExp=IdentifierOrStringLiteral
    {
       varName = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
    }
    ((
       <EQUALS>
       exp=Expression {assignments.put(varName, exp);}
       (
   //      SCAN [<COMMA>](<ID>|<STRING_LITERAL>)<EQUALS> =>
            [<COMMA>]
            nameExp=IdentifierOrStringLiteral
            {
               varName = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
            }
            <EQUALS> =>||
            exp=Expression
            {
            	assignments.put(varName, exp);
            } 
       )*
       [
          id=<IN>
          nsExp=Expression {if (type != AssignmentInstruction.SET && type != AssignmentInstruction.NAMESPACE) {
          	   ParsingProblem problem = new ParsingProblem("Can only assign to namespace with #set or #assign.", result);
          	   template.addParsingProblem(problem);
            } 
          }
       ]
       end=LooseDirectiveEnd
       {
           result.setNamespaceExp(nsExp);
		   for (Map.Entry<String,Expression> entry : assignments.entrySet()) {
           	    result.addAssignment(entry.getKey(), entry.getValue());
           }
           result.setLocation(template, token_source, start, end);
           return result;
       }
    )
    |
    (
       [
          id=<IN>
          nsExp=Expression {if (type != AssignmentInstruction.NAMESPACE && type != AssignmentInstruction.SET) throw new ParseException(getErrorStart(id) + "\nCannot assign to namespace here.", id.getBeginLine(), id.getBeginColumn());}
       ]
       <DIRECTIVE_END>
       block=OptionalBlock
       end=CloseDirectiveBlock(assignmentType)
       {
       	  String name = end.toString().substring(3, end.toString().length() -1);
       	  switch (type) {
       	   	   case AssignmentInstruction.LOCAL : if (name.length() >0 && !name.equals("local")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	   	   case AssignmentInstruction.NAMESPACE : if (name.length() >0 && !name.equals("assign")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	   	   case AssignmentInstruction.GLOBAL : if (name.length() >0 && !name.equals("global")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	   	   case AssignmentInstruction.SET : if (name.length() >0 && !name.equals("set")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	  }
          BlockAssignment ba = new BlockAssignment(block, varName, type, nsExp);
          ba.setLocation(template, token_source, start, end);
          return ba;
       }
    ))
;
#Include :
{
   Token att, start, end;
   Expression nameExp, exp, parseExp = null, encodingExp = null;
   boolean freshNamespace;
}
    (
        start=<_INCLUDE> {freshNamespace = false;}
        |
        start=<EMBED> {freshNamespace=true;}
    )
    nameExp=Expression
    [<SEMICOLON>]
    (
	  att=<ID>
	  <EQUALS>
	  exp=Expression
	  {
	     String attString = att.toString();
	     if (attString.equalsIgnoreCase("parse")) {
	        if (parseExp != null) {
	           String msg = getErrorStart(att)
	                 + "\nparse may not be specified more than once.";
	           throw new ParseException(msg, att.getBeginLine(), att.getBeginColumn());
	        }
	        parseExp = exp;
	     }
	     else if (attString.equalsIgnoreCase("encoding")) {
	        if (encodingExp != null) {
	           String msg = getErrorStart(att)
	                 + "\nencoding may not be specified more than once.";
	           throw new ParseException(msg, att.getBeginLine(), att.getBeginColumn());
	        }
	        encodingExp = exp;
	     }
	     else {
	         String msg = getErrorStart(att)
	               + "\nexpecting parse= or encoding= to be specified.";
	         throw new ParseException(msg, att.getBeginLine(), att.getBeginColumn());
	     }
	  }
	)*
    end=LooseDirectiveEnd
    {
       Include result = new Include(template, nameExp, freshNamespace, encodingExp, parseExp);
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

LibraryLoad Import :
{
   Token start, end, ns;
   Expression nameExp;
}
   start=<IMPORT>
   nameExp=Expression
   <AS>
   ns=<ID>
   end=LooseDirectiveEnd
   {
       LibraryLoad result = new LibraryLoad(template, nameExp, ns.toString());
       result.setLocation(template, token_source, start, end);
       if (template != null) template.addImport(result);
       return result;
   }
;

#ParameterList# :
{
	Token arg=null, firstArg=null, ellipsis = null;
	Expression defValue = null;
	String catchAll = null;
	boolean isCatchAll = false, hasDefaults = false;
	Set<String> paramNames = new HashSet<String>();
}
    (
          arg=<ID> 
          {
          	if (firstArg == null) firstArg = arg;
          	defValue = null;
          	if (paramNames.contains(arg.toString())) {
          		throw new ParseException(getErrorStart(arg) + "\nThe parameter " + arg.toString() + " cannot be repeated.");
          	}
          	paramNames.add(arg.toString());
          }
          [
             ellipsis=<ELLIPSIS> { isCatchAll = true; }
          ]
          [
            <EQUALS>
          	defValue=Expression
            {
		      hasDefaults = true;
            }
          ]
          [<COMMA>]
	  {
          if (catchAll != null) {
              throw new ParseException(getErrorStart(arg)
                + "\nThere may only be one \"catch-all\" parameter in a macro declaration, "
                + "and it must be the last parameter.", arg.getBeginLine(), arg.getEndLine());
          }
          if (isCatchAll) {
              if (defValue != null) {
                  throw new ParseException(getErrorStart(arg)
                    + "\n\"Catch-all\" macro parameter may not have a default value.",
                    arg.getBeginLine(), arg.getEndLine());
              }
              CURRENT_NODE.setCatchAll(arg.toString());
          } 
          else if (defValue == null) {
             if (hasDefaults) {
                  throw new ParseException(getErrorStart(arg)
                    + "\nIn a macro declaration, parameters without a default value "
                    + "must all occur before the parameters with default values.",
                    arg.getBeginLine(), arg.getEndLine());
             }
          	 CURRENT_NODE.addParam(arg.toString());
          }
          else {
              CURRENT_NODE.addParam(arg.toString(), defValue);
          	  hasDefaults = true;
          }
	  }
    )*
	{
		return CURRENT_NODE;
	}
;

INJECT ParameterList :
   import java.io.IOException;
   import java.util.*;
   import freemarker.core.Environment;
   import freemarker.core.InvalidReferenceException;
   import freemarker.core.Scope;
   import freemarker.core.TemplateRunnable;
   import freemarker.core.helpers.NamedParameterListScope;
   import freemarker.core.helpers.NamedParameterMapScope;
   import freemarker.core.ast.NamedArgsList;
   import freemarker.core.ast.PositionalArgsList;
   import freemarker.ext.beans.SimpleMapModel;
   import freemarker.template.TemplateException;
   import freemarker.template.TemplateModelException;
{
    private List<String> params = new ArrayList<String>();
    private Map<String, Expression> defaults;
    private String catchall;

    public void addParam(String paramName) {
        params.add(paramName);
    }

    public List<String> getParams() {
      return params;
    }

    public List<String> getParamNames() {
        List<String> result = new ArrayList<String>(params);
        if (catchall != null) result.add(catchall);
        return result;
    }


    boolean containsParam(String name) {
        return params.contains(name);
    }

    public void addParam(String paramName, Expression defaultExp) {
        if (defaults == null) defaults = new HashMap<String, Expression>();
        defaults.put(paramName, defaultExp);
        addParam(paramName);
    }

    public void setCatchAll(String varname) {
        this.catchall = varname;
    }

    public String getCatchAll() {
        return catchall;
    }

    private boolean hasDefaultExpressions() {
        return defaults != null && !defaults.isEmpty();
    }
    
    public Expression getDefaultExpression(String paramName) {
        return defaults == null ? null : defaults.get(paramName);
    }

    public Expression getDefaultExpression(int paramIndex) {
        if(params == null || paramIndex >= params.size()) {
            return null;
        }
        return getDefaultExpression(params.get(paramIndex));
    }

    private void fillInDefaults(final Environment env, final Scope scope, final Collection<String> paramNames) 
    {
        try {
            env.runInScope(scope, new TemplateRunnable<Object>() {
                public Object run() throws IOException {
                    fillInDefaultsInternal(env, scope, paramNames);
                    return null;
                }
            });
        }
        catch(IOException e) {
            throw new TemplateException(e, env);
        }
    }
    private void fillInDefaultsInternal(Environment env, Scope scope, Collection<String> paramNames) {
        
        boolean resolvedAnArg, hasUnresolvedArg;
        Expression firstUnresolvedExpression;
        InvalidReferenceException firstReferenceException;
        do {
            firstUnresolvedExpression = null;
            firstReferenceException = null;
            resolvedAnArg = hasUnresolvedArg = false;
            for (String paramName : paramNames) {
                Object arg = scope.get(paramName);
                if (arg == null) {
                    Expression defaultExp = getDefaultExpression(paramName);
                    if (defaultExp != null) {
                        try {
                            Object value = defaultExp.evaluate(env);
                            if(value == null) {
                                if(!hasUnresolvedArg) {
                                    firstUnresolvedExpression = defaultExp;
                                    hasUnresolvedArg = true;
                                }
                            }
                            else {
                                scope.put(paramName, value);
                                resolvedAnArg = true;
                            }
                        }
                        catch(InvalidReferenceException e) {
                            if(!hasUnresolvedArg) {
                                hasUnresolvedArg = true;
                                firstReferenceException = e;
                            }
                        }
                    }
                    else if (arg == null) {
                        throw new TemplateModelException("Missing required parameter " + paramName);
                    }
                }
            }
        }
        while(resolvedAnArg && hasUnresolvedArg);
        if(hasUnresolvedArg) {
            if(firstReferenceException != null) {
                throw firstReferenceException;
            }
            else {
                assert firstUnresolvedExpression != null;
                assertNonNull(null, firstUnresolvedExpression, scope.getEnvironment());
            }
        }
    }

    /**
     * Given a positional list of argument expressions, create a positional 
     * list of template models. Used to pass positional arguments to a template
     * method model.
     */
    public List<Object> getParameterSequence(final PositionalArgsList args, 
            final Environment env) 
    {
        final List<Object> result = new ArrayList<>(params.size());
        int argsSize = args.size();
        int paramsSize = params.size();
        int commonSize = Math.min(argsSize, paramsSize);
        // Set formal args that have matching actual args
        for(int i = 0; i < commonSize; ++i) {
            result.add(args.getValueAt(i, env));
        }
        if(commonSize < argsSize) {
            // More actual args than formal args -- use catchall if present
            if (catchall == null) {
                throw new TemplateException("Extraneous parameters provided; expected " + 
                        paramsSize + ", got " + argsSize, env);
            }
            for (int i = commonSize; i < argsSize; i++) {
                result.add(args.getValueAt(i, env));
            }
        }
        else if(commonSize < paramsSize) {
            // More formal args than actual args -- fill in defaults

            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterListScope(env.getCurrentScope(), 
                    params, result, false);
                fillInDefaults(env, scope, params.subList(args.size(), params.size()));
        }
        return result;
    }
    
    /**
     * Given a named list of argument expressions, create a positional 
     * list of template models. Used to pass named arguments to a template
     * method model.
     */
    public List<Object> getParameterSequence(final NamedArgsList args, 
            final Environment env) 
    {
        int argsSize = args.size();
        int paramsSize = params.size();
        if(argsSize > paramsSize) {
            Collection<String> l = new LinkedHashSet<String>(args.getArgs().keySet());
            l.removeAll(params);
            throw new TemplateException("Extraneous parameters " + l, env);
        }
        final List<Object> result = new ArrayList<>();
        List<String> unresolvedParamNames = null;
        Map<String, Expression> argsMap = args.getCopyOfMap();
        for (String paramName : params) {
            Expression argExp = argsMap.remove(paramName);
            if (argExp != null) {
                Object argModel = argExp.evaluate(env);
                assertIsDefined(argModel, argExp, env);
                result.add(argModel);
            } else {
                if(unresolvedParamNames == null) {
                    unresolvedParamNames = new LinkedList<String>();
                }
                unresolvedParamNames.add(paramName);
            }
        }
        if(unresolvedParamNames != null) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            final Scope scope = new NamedParameterListScope(
                    env.getCurrentScope(), params, result, false);
            fillInDefaults(env, scope, unresolvedParamNames);
        }
        return result;
    }

    /**
     * Given a positional args list, creates a map of key-value pairs based
     * on the named parameter info encapsulated in this object. 
     */
    public Map<String, Object> getParameterMap(final PositionalArgsList args, 
            final Environment env, boolean ignoreExtraParams) 
    {
        final int argsSize = args.size();
        final int paramsSize = params.size();
        final Map<String, Object> result = new HashMap<>();
        if (catchall == null && argsSize > paramsSize && !ignoreExtraParams) {
            throw new TemplateException("Expecting exactly " + paramsSize + 
                    " arguments, received " + argsSize + ".", env);
        }
        int min = Math.min(paramsSize, argsSize);
        for (int i=0; i < min; i++) {
            result.put(params.get(i), args.getValueAt(i, env));
        }
        if(hasDefaultExpressions() && argsSize < paramsSize) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterMapScope(env.getCurrentScope(), 
                    result);
            fillInDefaults(env, scope, params.subList(argsSize, paramsSize));
        }
        if(catchall != null) {
            List<Object> catchAllVars = new ArrayList<>();
            result.put(catchall, catchAllVars);
            for (int i = paramsSize; i < argsSize; i++) {
                catchAllVars.add(args.getValueAt(i, env));
            }
        }
        return result;
    }
    
    public Map<String, Object> getParameterMap(NamedArgsList args, Environment env) 
    {
        Map<String, Object> result = new HashMap<>();
        Collection<String> unresolvedParamNames = null;
        Map<String, Expression> argsMap = args.getCopyOfMap();
        for (String paramName : params) {
            Expression argExp = argsMap.remove(paramName);
            if (argExp != null) {
                Object value = argExp.evaluate(env);
                TemplateNode.assertIsDefined(value, argExp, env);
                result.put(paramName, value);
            }
            else if(defaults != null && defaults.containsKey(paramName)) {
                if(unresolvedParamNames == null) {
                    unresolvedParamNames = new LinkedList<String>();
                }
                unresolvedParamNames.add(paramName);
            }
            else {
                throw new TemplateException("Missing required parameter " + paramName, env);
            }
        }
        if(unresolvedParamNames != null) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterMapScope(env.getCurrentScope(), result);
            fillInDefaults(env, scope, unresolvedParamNames);
        }
        SimpleMapModel catchAllMap = null;
        if (catchall != null) {
            catchAllMap = new SimpleMapModel();
            result.put(catchall, catchAllMap);
        }
        if (!argsMap.isEmpty()) {
            if(catchall != null) {
                for (Map.Entry<String, Expression> entry : argsMap.entrySet()) {
                    Expression exp = entry.getValue();
                    Object val = exp.evaluate(env);
                    assertIsDefined(val, exp, env);
                    catchAllMap.put(entry.getKey(), val);
                }
            } else {
                throw new TemplateException("Extraneous parameters " + 
                        argsMap.keySet() + " provided.", env);
            }
        }
        return result;
    }

    public Map<String, Object> getParameterMap(ArgsList args, Environment env) {
        if (args instanceof NamedArgsList) {
            return getParameterMap((NamedArgsList) args, env);
        } 
        if(args instanceof PositionalArgsList) {
            return getParameterMap((PositionalArgsList) args, env, false);
        }
        throw new AssertionError();
    }
}

#Macro :
{
   Macro result = new Macro();
   Token arg, start, end;
   Expression nameExp;
   String name;
   TemplateElement block;
   ParameterList params;
   String functionOrMacro;
}
    (
        start=<MACRO> {functionOrMacro = "macro";}
        |
        start=<FUNCTION> {result.setFunction(true); functionOrMacro = "function";}
    )
    nameExp=IdentifierOrStringLiteral
    {
       name = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
       result.setName(name);
    }
    [<OPEN_PAREN>]
    params=ParameterList {result.setParams(params);}
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    block=OptionalBlock
    end=CloseDirectiveBlock(functionOrMacro)
    {
	   result.setName(name);
	   result.add(block);
      result.setLocation(template, token_source, start, end);
      return result;
    }
;


CompressedBlock Compress :
{
   TemplateElement block;
   Token start, end;
}
    start=<COMPRESS>
    block=OptionalBlock
    end=CloseDirectiveBlock("compress")
    {
       CompressedBlock cb = new CompressedBlock(block);
       cb.setLocation(template, token_source, start, end);
       return cb;
    }
;



TemplateElement UnifiedMacroTransform :
{
   Token start=null, end, t;
   Map<String, Expression> namedArgs = null;
   ArrayList<Expression> positionalArgs = null;
   String directiveName = null;
   TemplateElement nestedBlock = null;
   Expression exp;
   UnifiedCall result = new UnifiedCall();
   ArgsList args = null;
   ParameterList bodyParameters = null;
}
    start=<UNIFIED_CALL>
    exp=Expression
    {
        if (exp instanceof Identifier || (exp instanceof DotVariable && ((DotVariable) exp).onlyHasIdentifiers())) {
           //directiveName = exp.getCanonicalForm();
           directiveName = exp.toString(); // REVISIT. Deal with whitespace diffs in dot-separated names
	    }
	    result.setNameExp(exp);
    }
    [<TERMINATING_WHITESPACE>]
    [args=ArgsList]
    {
        if(args == null)
        {
            args = new PositionalArgsList();
        }
        result.setArgs(args);
    }
    [
       <SEMICOLON>[<TERMINATING_WHITESPACE>]
       bodyParameters=ParameterList
       {
           result.setBodyParameters(bodyParameters);
       }
    ]
    (
      end=<EMPTY_DIRECTIVE_END>
      |
      (
        <DIRECTIVE_END>
		nestedBlock=OptionalBlock
		end=<UNIFIED_CALL_END>
		{
           String s=end.toString().substring(2);;
           if (s.charAt(0) == '@') {
              s = s.substring(1);
           }
	       s = s.substring(0, s.length() -1).trim();
           if (s.length() >0 && !s.equals(directiveName)) {
           String msg = getErrorStart(end);
           if (directiveName == null) {
                throw new ParseException(msg + "\nExpecting </@>", end.getBeginLine(), end.getBeginColumn());
	       }
	       else {
	           throw new ParseException(msg + "\nExpecting </@> or </@" + directiveName + ">", end.getBeginLine(), end.getBeginColumn());
	       }
	    }
	    result.add(nestedBlock);
	  }
      )
    )
    {
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

TemplateElement Call :
{
   Token start, end;
   Identifier id;
   String macroName= null;
   UnifiedCall result = new UnifiedCall();
   ArgsList args = null;
}
    start=<CALL>
    id=Identifier {result.setNameExp(id);}
    [
	    <OPEN_PAREN>
	]
    args=ArgsList {result.setArgs(args);}
    [<CLOSE_PAREN>]
    end=LooseDirectiveEnd
    {
       result.setLocation(template, token_source, start, end);
       args.setLocationInfoIfAbsent(result);
       return result;
    }
;

Map<String, Expression> NamedArgs :
{
    Map<String, Expression> result = new LinkedHashMap<String, Expression>();
    Token t;
    Expression exp;
}
  (
     t=<ID>
     <EQUALS>
     exp=Expression
     {
        if (result.containsKey(t.toString())) {
           throw new ParseException(getErrorStart(t)
              + "\nValue of named parameter '" + t.toString()
              + "' may only be specified once.", t.getBeginLine(), t.getEndLine());
        }
        result.put(t.toString(), exp);
     }
  )+
  {
     return result;
  }
;

Comment TerseComment :
{
	Token start, end, t;
	StringBuilder buf = new StringBuilder();
}
	start=<TERSE_COMMENT>
	(
	   t=<PRINTABLE_CHARS> {buf.append(t.toString());}
	)*
	end=<TERSE_COMMENT_END>
	{
		Comment result = new Comment(buf.toString());
		result.setLocation(template, token_source, start, end);
		return result;
	}
;
#Comment :
{
   Token start, end, t;
   StringBuilder buf = new StringBuilder();
}
    start=<COMMENT>
    (
       t=<PRINTABLE_CHARS> {buf.append(t.toString());}
    )*
    end=<COMMENT_END>
    {
       Comment result = new Comment(buf.toString());
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

NoParseBlock NoParse :
{
   Token start, end, t;
   StringBuilder buf = new StringBuilder();
}
    start=<NOPARSE>
    (
       t=<PRINTABLE_CHARS> {buf.append(t.toString());}
    )*
    end=<NOPARSE_END>
    {
    	int beginColumn = start.getBeginColumn();
    	int beginLine = start.getBeginLine();
    	char lastChar = 0;
    	for (char c : start.toString().toCharArray()) {
    		switch (c) {
    			case '\n' : if (lastChar == '\r') break;
    			case '\r' : beginColumn = 1; beginLine++; break;   
    			default : ++beginColumn;
    		}
    		lastChar = c;
    	}
      List<TextBlock> text = TextBlock.breakIntoBlocks(buf.toString(), template, beginColumn, beginLine);
      NoParseBlock result = new NoParseBlock(start.toString(), end.toString(), text);
      result.setLocation(template, token_source, start, end);
      return result;
    }
;


TransformBlock Transform :
{
   Token start, end, argName;
   Expression exp, argExp;
   TemplateElement content = null;
   HashMap<String, Expression> args = null;
}
    start=<TRANSFORM>
    exp=Expression
    [<SEMICOLON>]
    (
       argName=<ID>
       <EQUALS>
       argExp=Expression
       {
           if (args == null) args = new HashMap<String, Expression>();
           args.put(argName.toString(), argExp);
       }
    )*
    (
       end=<EMPTY_DIRECTIVE_END>
       |
       (
          <DIRECTIVE_END>
          content=OptionalBlock
          end=CloseDirectiveBlock("transform")
       )
    )
    {
       TransformBlock result = new TransformBlock(exp, args, content);
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

SwitchBlock Switch :
{
    SwitchBlock switchBlock;
    Case caseIns;
    Expression switchExp;
    Token start, end;
    boolean defaultFound = false;
}
   start=<SWITCH>
   switchExp=Expression
   <DIRECTIVE_END>
   (<WHITESPACE>|Comment)*   
   {
      switchBlock = new SwitchBlock(switchExp);
   }
   (
     SCAN 2 => caseIns=Case
     {
       if (caseIns.isDefault()) {
	   if (defaultFound) {
                String msg = getErrorStart(start)
                            + "\nYou can only have one default case in a switch statement";
                throw new ParseException(msg, start.getBeginLine(), start.getBeginColumn());
	   }
	   defaultFound = true;
	}
        switchBlock.addCase(caseIns);
     }
   )*
   end=CloseDirectiveBlock("switch")
   {
      switchBlock.setLocation(template, token_source, start, end);
      return switchBlock;
   }
;
#Case :
{
    Expression exp = null;
    TemplateElement block;
    boolean isDefault = false;
    Token start;
}
   (
      start=<CASE> 
      exp=Expression 
      <DIRECTIVE_END>
      |
      start=<DEFAUL>{isDefault = true;}
   )
   block=OptionalBlock
   {
       Case result = new Case(exp, block, isDefault);
       result.setLocation(template, token_source, start, block);
       return result;
   }
;
#TrimBlock :
{
	Token start, end;
	TemplateElement content;
	boolean left = false, right = false;
	String closeTag = null;
}
	(
	   start=<BLOCKTRIM> {closeTag = "t_lines"; left = right = true;}
	   |
	   start=<BLOCKTRIML> {closeTag = "lt_lines"; left = true;}
	   |
	   start=<BLOCKTRIMR> {closeTag = "rt_lines"; right = true;}
	   |
	   start=<BLOCKNOTRIM> {closeTag = "nt_lines";}
	) 
	{trimBlockNesting++;}
	content=OptionalBlock
	end=CloseDirectiveBlock(closeTag)
	{
		TrimBlock result = new TrimBlock(content, left, right);
		result.setLocation(template, token_source, start, end);
		trimBlockNesting--;
		return result;
	}
;
	

EscapeBlock Escape :
{
    Token variable, start, end;
    Expression escapeExpr;
    TemplateElement content;
}
    start=<ESCAPE>
    variable=<ID>
    <AS>
    escapeExpr=Expression
    <DIRECTIVE_END>
    {
        EscapeBlock result = new EscapeBlock(variable.toString(), escapeExpr);
    }
    content=OptionalBlock
    {
        result.setContent(content);
    }
    end=CloseDirectiveBlock("escape")
    {
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

NoEscapeBlock NoEscape :
{
    Token start, end;
    TemplateElement content;
}
    start=<NOESCAPE>
    content=OptionalBlock
    end=CloseDirectiveBlock("noescape")
    {
       NoEscapeBlock result = new NoEscapeBlock(content);
       result.setLocation(template, token_source, start, end);
       return result;
    }
;


Token CloseDirectiveBlock(String expectedTags) :
{
	Token t;
}
    t=<CLOSE_DIRECTIVE_BLOCK>
	{
		String name = t.toString();
		name = name.substring(3, name.length() -1);
		if (name.length()>0) {
			StringTokenizer st = new StringTokenizer(expectedTags, ", ");
			boolean found = false;
			while (st.hasMoreTokens()) {
				if (st.nextToken().equals(name.trim())) found = true;
			}
			if (!found) {
				throw new ParseException(getErrorStart(t) + " Expecting " + t.toString().substring(0,3) + expectedTags + t.toString().charAt(t.toString().length() -1));
			}
		}
		return t;
	}
;


/**
 * Production to terminate potentially empty elements. Either a ">" or "/>"
 */

Token LooseDirectiveEnd :
{
    Token t;
}
   (
      t=<DIRECTIVE_END>
      |
      t=<EMPTY_DIRECTIVE_END>
   )
   {
      return t;
   }
;

PropertySetting Setting :
{
   Token start, end, key;
   Expression value;
}
   start=<SETTING>
   key=<ID>
   <EQUALS>
   value=Expression
   end=LooseDirectiveEnd
   {
      PropertySetting result = new PropertySetting(key.toString(), value);
      result.setLocation(template, token_source, start, end);
      return result;
   }
;

VarDirective Var :
{
    Token start, end;
    Expression var, valueExp = null;
    VarDirective result = new VarDirective();
}
   start=<VAR>
   (
     var=IdentifierOrStringLiteral
     [
       <EQUALS>
       valueExp=Expression
     ]
   )
   {
      result.addVar(var, valueExp);
      valueExp = null;
   }
   (
      (
        [<COMMA>]
        var=IdentifierOrStringLiteral
        [
           <EQUALS>
           valueExp=Expression
        ]
      )
      {
         result.addVar(var, valueExp);
         valueExp = null;
      }
   )*
   end=LooseDirectiveEnd
   {
      result.setLocation(template, token_source, start, end);
      return result;
   }
;

/**
 * A production for FreeMarker directives.
 */
TemplateElement FreemarkerDirective :
{
   TemplateElement tp;
}
   (
     tp=If
     |
     tp=List
     |
     tp=ForEach
     |
     tp=Assign
     |
     tp=Include
     |
     tp=Import
     |
     tp=Macro
     |
     tp=Compress
     |
     tp=UnifiedMacroTransform
     |
     tp=Call
     |
     tp=TerseComment
     |
     tp=Comment
     |
     tp=NoParse
     |
     tp=Transform
     |
     tp=Switch
     |
     tp=Setting
     |
     tp=Var
     |
     tp=Break
     |
     tp=Return
     |
     tp=Stop
     |
     tp=Flush
     |
     tp=Trim
     |
     tp=Nested
     |
     tp=Escape
     |
     tp=NoEscape
     |
     tp=TrimBlock
     |
     tp=Visit
     |
     tp=Recurse
     |
     tp=FallBack
     |
     tp=Attempt
   )
   {
      return tp;
   }
;

/**
 * Production for a block of raw text
 * i.e. text that contains no
 * FreeMarker directives.
 */

List<TextBlock> PCData :
{
    StringBuilder buf = new StringBuilder();
    Token t=null, start=null, prevToken = null;
    List<TextBlock> result = new ArrayList<TextBlock>();
}
    (
      SCAN <WHITESPACE>|<PRINTABLE_CHARS> =>
      (
         {prevToken = t;}         
         t=<PRINTABLE_CHARS> 
         |
         t=<WHITESPACE> 
      )
      {
         buf.append(t.toString());
         if (start == null) start = t;
         //if (prevToken != null) prevToken.setNext(null);
         if (prevToken != null) token_source.uncacheTokens(prevToken);
      }
    )+
    {
         if (stripText && contentNesting == 1) {
             result.add(TextBlock.EMPTY_BLOCK);
             return result;
         }
    	 if (trimBlockNesting>0) {
    		result = TextBlock.breakIntoBlocksLineByLine(buf.toString(), template, start.getBeginColumn(), start.getBeginLine()); 
    	 } else {
            result = TextBlock.breakIntoBlocks(buf.toString(), template, start.getBeginColumn(), start.getBeginLine());
    	 }
         return result;
    }
;

/**
 * Production for dealing with unparsed content,
 * i.e. what is inside a comment or noparse tag.
 * It returns the ending token. The content
 * of the tag is put in buf.
 */

TemplateElement Content :
{
    MixedContent nodes = new MixedContent();
    TemplateElement elem=null, begin=null;
    contentNesting++;
    List<TextBlock> text = null;
}
    (
      (
         text=PCData {elem = null;}
         |
         elem=StringOutput
         |
         elem=FreemarkerDirective
      )
      {
            if (begin == null) {
               begin = elem == null ? text.get(0) : elem;
            }
            if (elem == null) {
            	for (TextBlock tb : text) nodes.add(tb);
            } else {
            	nodes.add(elem);
            }
      }
    )+
    {
        contentNesting--;
        if (elem == null) elem = text.get(text.size() -1);
        nodes.setLocation(template, token_source, begin, elem);
	     return nodes;
    }
;

/**
 * A production freemarker text that may contain
 * ${...} but no directives.
 */

TemplateElement FreeMarkerText :
{
     MixedContent nodes = new MixedContent();
     TemplateElement elem = null, begin = null;
     List<TextBlock> text = null;
}
    (
      (
        text=PCData {elem = null;}
        |
        elem=StringOutput
      )
      {
         if (begin == null) {
            begin = (elem == null) ? text.get(0) : elem;
         }
         if (elem != null) {
         	nodes.add(elem);
         } else {
         	for (TextBlock tb : text) nodes.add(tb);
         }
      }
    )+
    {
       if (elem == null) elem = text.get(text.size() -1);
       nodes.setLocation(template, token_source, begin, elem);
       return nodes;
    }
;

/**
 * A production for a block of optional content.
 * Returns an empty Text block if there is no
 * content.
 */

TemplateElement OptionalBlock :
{
   TemplateElement tp = TextBlock.EMPTY_BLOCK;
}
   [
         tp=Content
   ]
   {
      return tp;
   }
;


TemplateHeaderElement HeaderElement : 
{
	Token key, start, end;
	Expression exp;
	Map<String,Expression> params = new LinkedHashMap<String,Expression>();
}
   [<WHITESPACE>]
   (
     start=<TRIVIAL_FTL_HEADER> {end=start;}
     |
     (
       start=<FTL_HEADER>
       (
          key=<ID>
          <EQUALS>
          exp=Expression {params.put(key.toString().toLowerCase(), exp);}
       )*
       end=LooseDirectiveEnd
     )
   )
   {
   	   TemplateHeaderElement header = new TemplateHeaderElement(params);
   	   header.setLocation(template, token_source, start, end);
   	   return header;
   }
;

Map<String,Expression> ParamList :
{
   Identifier id;
   Expression exp;
   Map<String,Expression> result = new HashMap<String,Expression>();
}
   (
      id=Identifier
      <EQUALS>
      exp=Expression {result.put(id.toString(), exp);}
      [<COMMA>]
   )+
   {
       return result;
   }
;


/**
 * Root production to be used when parsing
 * an entire file.
 */
TemplateElement Root :
{
   TemplateHeaderElement header;
   TemplateElement doc;
}
   [
      SCAN [<WHITESPACE>](<TRIVIAL_FTL_HEADER>|<FTL_HEADER>) =>
       header=HeaderElement
       {
       	   template.setHeaderElement(header);
       	   String templateEncoding = template.getEncoding();
       	   if (templateEncoding != null && header.hasParameter("encoding")) {
       	   	  String encoding = null;
       	   	  try {
       	   	     encoding = header.getStringParameter("encoding");
       	   	  } catch (Exception e) {}
       	   	  if (encoding != null && !encoding.equals(templateEncoding)) {
       	   	  	throw new Template.WrongEncodingException(encoding);
       	   	  }
       	   }
       	   if (header.hasParameter("strip_text")) {
       	   	  try {
       	   	  	 this.stripText = header.getBooleanParameter("strip_text");
       	   	  } catch (Exception e) {
       	   	  	throw new ParseException(e.getMessage());
       	   	  }
       	   }
       	   	
       }
   ]
   doc=OptionalBlock
   <EOF>
   {
       return doc;
   }
   ;