// This file defines the various 
// template elements. It is INCLUDEd
// from the main template.

/**
 * A production representing the ${...}
 * that outputs a variable.
 */
Interpolation :
   <OUTPUT_ESCAPE> 
   Expression
   <CLOSE_BRACE>
;

INJECT Interpolation :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    private Expression escapedExpression; // This will be the same as the expression if we are not within an escape block.

    public void setEscapedExpression(Expression escapedExpression) {
    	this.escapedExpression = escapedExpression;
    }
    
    public Expression getEscapedExpression() {
      if (escapedExpression==null) return getExpression();
    	return this.escapedExpression;
    }
    
    public Expression getExpression() {
    	return firstChildOfType(Expression.class);
    }

    /**
     * Outputs the string value of the enclosed expression.
     */
    public void execute(Environment env) throws TemplateException, IOException {
        env.getOut().write(getEscapedExpression().getStringValue(env));
    }

    public String getDescription() {
        return this.getSource()  +
        (escapedExpression == null 
            ? "" 
            : " escaped ${" + escapedExpression.getDescription() + "}");
    }
}

IfBlock :
  (
    <IF>
    Expression
    <DIRECTIVE_END>
    Content
  )#ConditionalBlock
  (
    (
        <ELSE_IF>
        Expression
        <DIRECTIVE_END>
        Content
    )#ConditionalBlock
  )*
  [
    (
        <ELSE>
        Content
    )#ConditionalBlock
  ]
  CloseDirectiveBlock("if")
;

INJECT IfBlock :
    import java.util.*;
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        for (ConditionalBlock cblock : childrenOfType(ConditionalBlock.class)) {
            Expression condition = cblock.getCondition();
            if (condition == null || condition.isTrue(env)) {
                if (cblock.firstChildOfType(TemplateElement.class) != null) {
                    env.render(cblock);
                }
                return;
            }
        }
    }

    public String getDescription() {
        return "if-else ";
    }
}

INJECT ConditionalBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public Expression getCondition() {
    	return firstChildOfType(Expression.class);
    }
    
    public void execute(Environment env) throws IOException {
        env.render(firstChildOfType(TemplateElement.class));
    }

    public String getDescription() {
        return get(0).toString() + " block";
    }
}

AttemptBlock :
   <_ATTEMPT>
   Content
   RecoveryBlock
   CloseDirectiveBlock("attempt, recover")
;

INJECT AttemptBlock :
    import java.io.IOException;
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    public TemplateElement getAttemptBlock() {
        return childrenOfType(TemplateElement.class).get(0);
    }
    
    public TemplateElement getRecoverBlock() {
        return childrenOfType(TemplateElement.class).get(1);
    }

    public void execute(Environment env) throws IOException 
    {
        env.render(getAttemptBlock(), getRecoverBlock());
    }

    public String getDescription() {
        return "attempt block";
    }
}

RecoveryBlock : 
   <_RECOVER>
   Content
;

INJECT RecoveryBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    public void execute(Environment env) throws TemplateException, IOException 
    {
    	if (firstChildOfType(TemplateElement.class) != null) {
    		env.render(firstChildOfType(TemplateElement.class));
    	}
    }

    public String getDescription() {
        return "recover block";
    }
}

ListBlock#IteratorBlock :
   <LIST> 
   Expression
   <AS>
   <ID>
   <DIRECTIVE_END>
   Content
   CloseDirectiveBlock("list")
;

ForEachBlock#IteratorBlock :
   <FOREACH> 
   <ID>
   <IN>
   Expression
   <DIRECTIVE_END>
   Content
   CloseDirectiveBlock("foreach")
;

INJECT IteratorBlock :
    import java.io.IOException;
    import freemarker.template.*;
    import freemarker.core.*;
    extends TemplateElement
{
    public boolean isForeach() {
        return get(0).getType() == FOREACH;
    }

    public String getIndexName() {
        return isForeach() ? get(1).toString() : get(3).toString();
    }
    
    public Expression getListExpression() {
        return isForeach() ? (Expression) get(3) : (Expression) get(1);
    }

    public void execute(Environment env) throws TemplateException, IOException 
    {
        Object baseModel = getListExpression().evaluate(env);
        assertNonNull(baseModel, getListExpression(), env);
        env.process(new LoopContext(this, env.getCurrentScope(), baseModel)); // REVISIT
    }

    public String getDescription() {
        return isForeach() ?
            "foreach " + getIndexName() + " in " + getListExpression() 
            :
            "list " + getListExpression() + " as " + getIndexName();
    }
}

VisitNode :
   <VISIT>
   Expression
   [
      <USING>
      Expression
   ]
   LooseDirectiveEnd
;

INJECT VisitNode :
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;
    import freemarker.core.Environment;
    import freemarker.core.Scope;
    import freemarker.core.TemplateNamespace;
    import freemarker.template.*;
    import static freemarker.ext.beans.ObjectWrapper.*;
    extends TemplateElement
{
    public Expression getTargetNode() {
    	return (Expression) get(1);
    }
    
    public Expression getNamespaces() {
        if (firstChildOfType(USING) == null) return null;
        return (Expression) get(3);
    }

    public void execute(Environment env) throws IOException, TemplateException {
        Expression targetNode = getTargetNode();
        Expression namespaces = getNamespaces();
        Object node = targetNode.evaluate(env);
        assertNonNull(node, targetNode, env);
        if (!(node instanceof TemplateNodeModel)) {
            throw new TemplateException("Expecting an XML node here", env);
        }
        Object nss = namespaces == null ? null : namespaces.evaluate(env);
        if (namespaces instanceof StringLiteral) {
            nss = env.importLib(asString(nss), null);
        }
        else if (namespaces instanceof ListLiteral) {
            nss = ((ListLiteral) namespaces).evaluateStringsToNamespaces(env);
        }
        if (nss != null) {
            if (nss instanceof TemplateNamespace) {
                List<Scope> ss = new ArrayList<>();
                ss.add((Scope)nss);
                nss = ss;
            }
            else if (!isList(nss)) {
                throw new TemplateException("Expecting a sequence of namespaces after 'using'", env);
            }
        }
        env.render((TemplateNodeModel) node, (List<Scope>)nss);
    }

    public String getDescription() {
        return "visit instruction";
    }
}

RecurseNode# :
   <SIMPLE_RECURSE>
   |
   (
      <RECURSE>
      [Expression]
      <USING>
      [Expression]
      LooseDirectiveEnd
   )
;

INJECT RecurseNode : 
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;
    import freemarker.core.Environment;
    import freemarker.core.Scope;
    import freemarker.template.*;
    import static freemarker.ext.beans.ObjectWrapper.isList;
    import static freemarker.ext.beans.ObjectWrapper.asString;
    extends TemplateElement
{
    public Expression getTargetNode() {
        if (get(1) instanceof Expression) {
            return (Expression) get(1);
        }
        return null;
    }
    
    public Expression getNamespaces() {
        Node using = firstChildOfType(USING);
        if (using == null) return null;
        if (using.nextSibling() instanceof Expression) {
            return (Expression) using.nextSibling();
        }
        return null;
    }

    public void execute(Environment env) throws IOException {
        Expression targetNode = getTargetNode();
        Expression namespaces = getNamespaces();
        Object node = targetNode == null ? null : targetNode.evaluate(env);
        Object nss = namespaces == null ? null : namespaces.evaluate(env);
        if (namespaces instanceof StringLiteral) {
                nss = env.importLib(asString(nss), null);
        }
        else if (namespaces instanceof ListLiteral) {
            nss = ((ListLiteral) namespaces).evaluateStringsToNamespaces(env);
        }
        if (node != null && !(node instanceof TemplateNodeModel)) {
            throw new TemplateException("Expecting an XML node here, for expression: " + targetNode + ", found a: " + node.getClass().getName(), env);
        }
        if (nss != null) {
            if (nss instanceof TemplateHashModel) {
                List<Scope> ss = new ArrayList<>();
                ss.add((Scope)nss);
                nss = ss;
            }
            else if (!isList(nss)) {
                throw new TemplateException("Expecting a sequence of namespaces after 'using'", env);
            }
        }
        env.process((TemplateNodeModel) node, (List<Scope>)nss);
    }

    public String getDescription() {
        return "recurse instruction";
    }
}

FallbackInstruction# :
   <FALLBACK>
;

INJECT FallbackInstruction :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement;
{
    public void execute(Environment env) throws IOException {
        env.fallback();
    }

    public String getDescription() {
        return "fallback instruction";
    }
}

/**
 * Production used to break out of a loop or a switch block.
 */
BreakInstruction# :
    <BREAK>
;

INJECT BreakInstruction :
    import freemarker.core.Environment;
    import freemarker.core.BreakException;
    extends TemplateElement
{
    public void execute(Environment env) {
        throw BreakException.INSTANCE;
    }

    public String getDescription() {
        return "break" + " [" + getStartLocation() + "]";
    }
}

/**
 * Production used to jump out of a macro.
 */
ReturnInstruction# :
   <SIMPLE_RETURN>
   | 
   <RETURN> Expression LooseDirectiveEnd
;

INJECT ReturnInstruction :
    import freemarker.core.Environment;
    import freemarker.core.ReturnException;
    import freemarker.core.parser.ast.Macro;
    extends TemplateElement
{
    public Object getReturnValue(Environment env) {
        if (size()==1) return null;
        return ((Expression)get(1)).evaluate(env);
    }
    
    public void execute(Environment env) {
        env.setLastReturnValue(getReturnValue(env));
        if (nextSibling() != null) {
            // We need to jump out using an exception.
            throw ReturnException.INSTANCE;
        }
        if (!(getParent() instanceof Macro || getParent().getParent() instanceof Macro)) {
            // Here also, we need to jump out using an exception.
            throw ReturnException.INSTANCE;
        }
    }

    public String getDescription() {
        return "return" + " [" + getStartLocation() + "]";
    }
}

StopInstruction# :
   <HALT>
   |
   <STOP> Expression LooseDirectiveEnd
;

INJECT StopInstruction :
   import freemarker.core.Environment;
   import freemarker.core.StopException;
   extends TemplateElement
{
   public String getMessage(Environment env) {
      if (size()==1) return "";
      return ((Expression)get(1)).getStringValue(env);
   }

    public void execute(Environment env) {
        throw new StopException(env, getMessage(env));
    }

    public String getDescription() {
        return "stop" + " [" + getStartLocation() + "]";
    }
}

NestedInstruction# :
    <SIMPLE_NESTED>
    |
    (
        <NESTED>
        PositionalArgsList
        LooseDirectiveEnd
    )
;

INJECT NestedInstruction :
    import java.io.IOException;
    import freemarker.core.*;
    import freemarker.template.*;
    extends TemplateElement
{
    public ArgsList getArgs() {
    	return firstChildOfType(ArgsList.class);
    }
    
    /**
     * There is actually a subtle but essential point in the code below.
     * A macro operates in the context in which it is defined. However, 
     * a nested block within a macro instruction is defined in the 
     * context in which the macro was invoked. So, we actually need to
     * temporarily switch the namespace and macro context back to
     * what it was before macro invocation to implement this properly.
     * I (JR) realized this thanks to some incisive comments from Daniel Dekany.
     */
    public void execute(Environment env) throws IOException {
        MacroInvocationBodyContext bodyContext = new MacroInvocationBodyContext(env, (PositionalArgsList) getArgs());
        env.render(bodyContext);
    }

    public String getDescription() {
        return "nested macro content";
    }
}

FlushInstruction# :
   <FLUSH>
;

INJECT FlushInstruction :
   import java.io.IOException;
   import freemarker.core.Environment;
   extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        env.getOut().flush();
    }

    public String getDescription() {
        return "flush instruction";
    }
}

TrimInstruction# : <TRIM>|<LTRIM>|<RTRIM>;

INJECT TrimInstruction :
   import freemarker.core.Environment;
   extends TemplateElement
{
    public boolean isLeft() {
    	return get(0).getType() != RTRIM;
    }
    
    public boolean isRight() {
    	return get(0).getType() != LTRIM;
    }

    public void execute(Environment env) {
        // This instruction does nothing at render-time, only parse-time.
    }

    public String getDescription() {
        String type = "";
        if (!isRight()) type = "left ";
        if (!isLeft()) type = "right ";
        return type + "trim instruction";
    }

    public boolean isIgnorable() {
        return true;
    }
}

BlockAssignment :
{String assignmentType = "set";}
   (
    <ASSIGN>{assignmentType = "assign";}
    |
    <GLOBALASSIGN>{assignmentType="global";}
    |
    <LOCALASSIGN>{assignmentType="local";}
    |
    <SET>
   )
   IdentifierOrStringLiteral
   [ 
      <IN>
      Expression
   ]
   <DIRECTIVE_END> =>||
   Content
   CloseDirectiveBlock(assignmentType)   
;

INJECT BlockAssignment :
    import java.io.IOException;
    import java.io.StringWriter;
    import java.io.Writer;
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.core.Scope;
    import freemarker.template.TemplateDirectiveBody;
    import freemarker.template.TemplateDirectiveModel;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    public String getVarName() {
        if (get(1) instanceof StringLiteral) {
            return ((StringLiteral)get(1)).getAsString();
        }
        return get(1).toString();
    }

    public Expression getNamespaceExp() {
        Node inToken = firstChildOfType(IN);
        if (inToken != null) {
            return (Expression) inToken.nextSibling();
        }
        return null;
    }

    public void execute(Environment env) throws IOException {
    	Scope scope = null;
        Expression namespaceExp = getNamespaceExp();
    	if (namespaceExp != null) {
    		try {
    			scope = (Scope) namespaceExp.evaluate(env); 
    		} catch (ClassCastException cce) {
                throw new InvalidReferenceException(getStartLocation() + "\nInvalid reference to namespace: " + namespaceExp, env);
    		}
    	}
    	else {
    		if (get(0).getType() == ASSIGN) {
    			scope = env.getCurrentNamespace();
    		} else if (get(0).getType() == LOCALASSIGN) {
    			scope = env.getCurrentMacroContext();
    		} else if (get(0).getType() == GLOBALASSIGN) {
    			scope = env.getGlobalNamespace();
    		} 
    	}
    	CaptureOutput filter = new CaptureOutput();
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class), filter, null, null);
        }
        String text = filter.capturedText;
    	if (scope != null) {
    		scope.put(getVarName(), text);
    	} else {
    		env.unqualifiedSet(getVarName(), text);
    	}
    }
    
    private static class CaptureOutput implements TemplateDirectiveModel {
        String capturedText = ""; 

        public void execute(Environment env, Map<String, Object> args, Object[] bodyVars, TemplateDirectiveBody body) throws IOException {
        	body.render(getWriter(env.getOut(), args));
        }

        public Writer getWriter(Writer out, Map<String, Object> args) {
            return new StringWriter() {
                public void flush() {
                	capturedText = this.toString();
                }
            };
        }
    }
    
    public String getDescription() {
        return "block assignment to variable: " + getVarName();
    }
}

AssignmentInstruction :
   (<ASSIGN>|<GLOBALASSIGN>|<LOCALASSIGN>|<SET>)
   IdentifierOrStringLiteral
   <EQUALS> =>||
   Expression
   (
     [<COMMA>]
     IdentifierOrStringLiteral
     <EQUALS>
     Expression
   )*
   [
      <IN>
      Expression     
   ]
   LooseDirectiveEnd
;

INJECT AssignmentInstruction :
    import java.io.IOException;
    import java.util.*;
    import freemarker.template.TemplateException;
    import freemarker.core.*;
    extends TemplateElement
{
    public List<String> getVarNames() {
        List<String> result = new ArrayList<>();
        List<Node> equalsToks = childrenOfType(EQUALS);
        for (Node tok : equalsToks) {
            Node varExp = tok.previousSibling();
            if (varExp instanceof StringLiteral) {
                result.add(((StringLiteral)varExp).getAsString());
            }
            else {
                result.add(varExp.toString());
            }
        }
        return result;
    }

    public List<Expression> getValues() {
        List<Expression> result = new ArrayList<>();
        List<Node> equalsToks = childrenOfType(EQUALS);
        for (Node tok : equalsToks) {
            result.add((Expression)tok.nextSibling());
        }
        return result;
    }
    
    public Expression getNamespaceExp() {
        Node inToken = firstChildOfType(IN);
        if (inToken != null) {
            return (Expression) inToken.nextSibling();
        }
        return null;
    }

    public void execute(Environment env) throws TemplateException, IOException {
    	Scope scope = null;
        Expression namespaceExp = getNamespaceExp();
    	if (namespaceExp != null) {
    		try {
    			scope = (Scope) namespaceExp.evaluate(env); 
    		} catch (ClassCastException cce) {
                throw new InvalidReferenceException(getStartLocation() + "\nInvalid reference to namespace: " + namespaceExp, env);
    		}
    	}
    	else {
    		if (get(0).getType() == ASSIGN) {
    			scope = env.getCurrentNamespace();
    		} else if (get(0).getType() == LOCALASSIGN) {
    			scope = env.getCurrentMacroContext();
    		} else if (get(0).getType() == GLOBALASSIGN) {
    			scope = env.getGlobalNamespace();
    		}
    	}
        List<String> varNames = getVarNames();
        List<Expression> values = getValues();
    	for (int i=0; i< varNames.size(); i++) {
    		String varname = varNames.get(i);
    		Expression valueExp = values.get(i);
    		Object value = valueExp.evaluate(env);
    		assertIsDefined(value, valueExp, env);
    		if (scope != null) {
    			scope.put(varname, value);
    		} else {
    			env.unqualifiedSet(varname, value);
    		}
    	}
    }
    
    public String getDescription() {
    	return "assignment instruction";
    }
}

IncludeInstruction :
{
    CURRENT_NODE.setTemplate(template);
}
   (<_INCLUDE>|<EMBED>)
   Expression
   (
    <ID><EQUALS>Expression
   )*
   LooseDirectiveEnd
;

INJECT IncludeInstruction :
    import java.io.IOException;
    import java.io.IOException;
    import freemarker.cache.TemplateCache;
    import freemarker.template.*;
    import freemarker.template.utility.StringUtil;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.core.parser.ParseException;
    import static freemarker.ext.beans.ObjectWrapper.*;
    extends TemplateElement
{
    @Property Template template;

    public boolean useFreshNamespace() {
        return get(0).getType() == EMBED;
    }

    public Expression getParamByName(String name) {
        for (Node n : this) {
            if (n instanceof ID && n.toString().equalsIgnoreCase(name)) {
                return (Expression) n.nextSibling().nextSibling();
            }
        }
        return null;
    }

    public void execute(Environment env) throws IOException {
        String templateNameString = ((Expression) get(1)).getStringValue(env);
        if( templateNameString == null ) {
            String msg = "Error " + getStartLocation()
                        + "The expression " + get(1)  + " is undefined.";
            throw new InvalidReferenceException(msg, env);
        }
        String encoding = null;
        Expression encodingExp = getParamByName("encoding");
        if (encodingExp!=null) {
            encoding = encodingExp.getStringValue(env);
        }
        boolean parse = true;
        Expression parseExp = getParamByName("parse");
        if (parseExp != null) {
            Object tm = parseExp.evaluate(env);
            assertNonNull(tm, parseExp, env);
            if (isString(tm)) {
                parse = StringUtil.getYesNo(asString(tm));
            }
            else {
                parse = parseExp.isTrue(env);
            }
        }
        Template includedTemplate;
        String templatePath = "";
    	if (template != null) {
    		String templatePath1 = template.getName();
    		int lastSlash = templatePath1.lastIndexOf('/');
    		templatePath = lastSlash == -1 ? "" : templatePath1.substring(0, lastSlash + 1);
    	}
        try {
            //REVISIT
            templateNameString = TemplateCache.getFullTemplatePath(env, templatePath, templateNameString);
            includedTemplate = env.getTemplateForInclusion(templateNameString, encoding, parse);
        }
        catch (ParseException pe) {
            String msg = "Error parsing included template "
                        + templateNameString + "\n" + pe.getMessage();
            throw new TemplateException(msg, pe, env);
        }
        catch (IOException ioe) {
            String msg = "Error reading included file "
                        + templateNameString;
            throw new TemplateException(msg, ioe, env);
        }
        env.include(includedTemplate, useFreshNamespace());
    }
}

ImportDeclaration :
   <IMPORT>
   Expression
   <AS>
   <ID>
   LooseDirectiveEnd
   {
       CURRENT_NODE.setTemplate(template);
   }
;

INJECT ImportDeclaration :
    import java.io.IOException;
    import freemarker.template.Template;
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.log.Logger;
    extends TemplateElement
{
    private String templatePath="";
    @Property Template template;

    public String getNamespace() {
    	return get(3).toString();
    }
    
    public Expression getTemplateNameExpression() {
    	return (Expression) get(1);
    }

    public void execute(Environment env) throws IOException {
        String templateNameString = getTemplateNameExpression().getStringValue(env);
        if( templateNameString == null ) {
            String msg = "Error " + getStartLocation()
                        + "The expression " + getTemplateNameExpression() + " is undefined.";
            throw new InvalidReferenceException(msg, env);
        }
        Template importedTemplate;
        try {
            if (templateNameString.indexOf("://") >0) {
                ;
            }
            else if(templateNameString.length() > 0 && templateNameString.charAt(0) == '/')  {
                int protIndex = templatePath.indexOf("://");
                if (protIndex >0) {
                    templateNameString = templatePath.substring(0, protIndex + 2) + templateNameString;
                } else {
                    templateNameString = templateNameString.substring(1);
                }
            }
            else {
                templateNameString = templatePath + templateNameString;
            }
            importedTemplate = env.getTemplateForImporting(templateNameString);
        }
        catch (ParseException pe) {
            String msg = "Error parsing imported template "
                        + templateNameString;
            Logger.getLogger("freemarker.runtime").error(msg, pe);
            throw new TemplateException(msg, pe, env);
        }
        catch (IOException ioe) {
            String msg = "Error reading imported file "
                        + templateNameString;
            throw new TemplateException(msg, ioe, env);
        }
        env.importLib(importedTemplate, getNamespace(), false);
    }

    public String getDescription() {
        return "import " + getTemplateNameExpression() + " as " + getNamespace();
    }

    public String getTemplateName() {
        return getTemplateNameExpression().toString();
    }    

    public void close() {
        if (template != null) {
        	String templatePath1 = template.getName();
        	int lastSlash = templatePath1.lastIndexOf('/');
        	templatePath = lastSlash == -1 ? "" : templatePath1.substring(0, lastSlash + 1);
            template.addImport(this);
        }
    }
}

#ParameterList#(true) :
{
	Token arg=null, firstArg=null, ellipsis = null;
	Expression defValue = null;
	String catchAll = null;
	boolean isCatchAll = false, hasDefaults = false;
	Set<String> paramNames = new HashSet<String>();
}
    (
          arg=<ID> 
          {
          	if (firstArg == null) firstArg = arg;
          	defValue = null;
          	if (paramNames.contains(arg.toString())) {
          		throw new ParseException(getErrorStart(arg) + "\nThe parameter " + arg.toString() + " cannot be repeated.");
          	}
          	paramNames.add(arg.toString());
          }
          [
             ellipsis=<ELLIPSIS> { isCatchAll = true; }
          ]
          [
            <EQUALS>
          	defValue=Expression
            {
		      hasDefaults = true;
            }
          ]
          [<COMMA>]
	  {
          if (catchAll != null) {
              throw new ParseException(getErrorStart(arg)
                + "\nThere may only be one \"catch-all\" parameter in a macro declaration, "
                + "and it must be the last parameter.", arg.getBeginLine(), arg.getEndLine());
          }
          if (isCatchAll) {
              if (defValue != null) {
                  throw new ParseException(getErrorStart(arg)
                    + "\n\"Catch-all\" macro parameter may not have a default value.",
                    arg.getBeginLine(), arg.getEndLine());
              }
              CURRENT_NODE.setCatchAll(arg.toString());
          } 
          else if (defValue == null) {
             if (hasDefaults) {
                  throw new ParseException(getErrorStart(arg)
                    + "\nIn a macro declaration, parameters without a default value "
                    + "must all occur before the parameters with default values.",
                    arg.getBeginLine(), arg.getEndLine());
             }
          	 CURRENT_NODE.addParam(arg.toString());
          }
          else {
              CURRENT_NODE.addParam(arg.toString(), defValue);
          	  hasDefaults = true;
          }
	  }
    )*
	{
		return CURRENT_NODE;
	}
;

INJECT ParameterList :
   import java.io.IOException;
   import java.util.*;
   import freemarker.core.Environment;
   import freemarker.core.InvalidReferenceException;
   import freemarker.core.Scope;
   import freemarker.core.TemplateRunnable;
   import freemarker.core.helpers.NamedParameterListScope;
   import freemarker.core.helpers.NamedParameterMapScope;
   import freemarker.ext.beans.SimpleMapModel;
   import freemarker.template.TemplateException;
   import freemarker.template.TemplateModelException;
{
    private List<String> params = new ArrayList<String>();
    private Map<String, Expression> defaults;
    private String catchall;

    public void addParam(String paramName) {
        params.add(paramName);
    }

    public List<String> getParams() {
      return params;
    }

    public List<String> getParamNames() {
        List<String> result = new ArrayList<String>(params);
        if (catchall != null) result.add(catchall);
        return result;
    }


    boolean containsParam(String name) {
        return params.contains(name);
    }

    public void addParam(String paramName, Expression defaultExp) {
        if (defaults == null) defaults = new HashMap<String, Expression>();
        defaults.put(paramName, defaultExp);
        addParam(paramName);
    }

    public void setCatchAll(String varname) {
        this.catchall = varname;
    }

    public String getCatchAll() {
        return catchall;
    }

    private boolean hasDefaultExpressions() {
        return defaults != null && !defaults.isEmpty();
    }
    
    public Expression getDefaultExpression(String paramName) {
        return defaults == null ? null : defaults.get(paramName);
    }

    public Expression getDefaultExpression(int paramIndex) {
        if(params == null || paramIndex >= params.size()) {
            return null;
        }
        return getDefaultExpression(params.get(paramIndex));
    }

    private void fillInDefaults(final Environment env, final Scope scope, final Collection<String> paramNames) 
    {
        try {
            env.runInScope(scope, new TemplateRunnable<Object>() {
                public Object run() throws IOException {
                    fillInDefaultsInternal(env, scope, paramNames);
                    return null;
                }
            });
        }
        catch(IOException e) {
            throw new TemplateException(e, env);
        }
    }
    private void fillInDefaultsInternal(Environment env, Scope scope, Collection<String> paramNames) {
        
        boolean resolvedAnArg, hasUnresolvedArg;
        Expression firstUnresolvedExpression;
        InvalidReferenceException firstReferenceException;
        do {
            firstUnresolvedExpression = null;
            firstReferenceException = null;
            resolvedAnArg = hasUnresolvedArg = false;
            for (String paramName : paramNames) {
                Object arg = scope.get(paramName);
                if (arg == null) {
                    Expression defaultExp = getDefaultExpression(paramName);
                    if (defaultExp != null) {
                        try {
                            Object value = defaultExp.evaluate(env);
                            if(value == null) {
                                if(!hasUnresolvedArg) {
                                    firstUnresolvedExpression = defaultExp;
                                    hasUnresolvedArg = true;
                                }
                            }
                            else {
                                scope.put(paramName, value);
                                resolvedAnArg = true;
                            }
                        }
                        catch(InvalidReferenceException e) {
                            if(!hasUnresolvedArg) {
                                hasUnresolvedArg = true;
                                firstReferenceException = e;
                            }
                        }
                    }
                    else if (arg == null) {
                        throw new TemplateModelException("Missing required parameter " + paramName);
                    }
                }
            }
        }
        while(resolvedAnArg && hasUnresolvedArg);
        if(hasUnresolvedArg) {
            if(firstReferenceException != null) {
                throw firstReferenceException;
            }
            else {
                assert firstUnresolvedExpression != null;
                assertNonNull(null, firstUnresolvedExpression, scope.getEnvironment());
            }
        }
    }

    /**
     * Given a positional list of argument expressions, create a positional 
     * list of template models. Used to pass positional arguments to a template
     * method model.
     */
    public List<Object> getParameterSequence(final PositionalArgsList args, 
            final Environment env) 
    {
        final List<Object> result = new ArrayList<>(params.size());
        int argsSize = args.size();
        int paramsSize = params.size();
        int commonSize = Math.min(argsSize, paramsSize);
        // Set formal args that have matching actual args
        for(int i = 0; i < commonSize; ++i) {
            result.add(args.getValueAt(i, env));
        }
        if(commonSize < argsSize) {
            // More actual args than formal args -- use catchall if present
            if (catchall == null) {
                throw new TemplateException("Extraneous parameters provided; expected " + 
                        paramsSize + ", got " + argsSize, env);
            }
            for (int i = commonSize; i < argsSize; i++) {
                result.add(args.getValueAt(i, env));
            }
        }
        else if(commonSize < paramsSize) {
            // More formal args than actual args -- fill in defaults

            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterListScope(env.getCurrentScope(), 
                    params, result, false);
                fillInDefaults(env, scope, params.subList(args.size(), params.size()));
        }
        return result;
    }
    
    /**
     * Given a named list of argument expressions, create a positional 
     * list of template models. Used to pass named arguments to a template
     * method model.
     */
    public List<Object> getParameterSequence(final NamedArgsList args, 
            final Environment env) 
    {
        int argsSize = args.size();
        int paramsSize = params.size();
        if(argsSize > paramsSize) {
            Collection<String> l = new LinkedHashSet<String>(args.getArgs().keySet());
            l.removeAll(params);
            throw new TemplateException("Extraneous parameters " + l, env);
        }
        final List<Object> result = new ArrayList<>();
        List<String> unresolvedParamNames = null;
        Map<String, Expression> argsMap = args.getCopyOfMap();
        for (String paramName : params) {
            Expression argExp = argsMap.remove(paramName);
            if (argExp != null) {
                Object argModel = argExp.evaluate(env);
                assertIsDefined(argModel, argExp, env);
                result.add(argModel);
            } else {
                if(unresolvedParamNames == null) {
                    unresolvedParamNames = new LinkedList<String>();
                }
                unresolvedParamNames.add(paramName);
            }
        }
        if(unresolvedParamNames != null) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            final Scope scope = new NamedParameterListScope(
                    env.getCurrentScope(), params, result, false);
            fillInDefaults(env, scope, unresolvedParamNames);
        }
        return result;
    }

    /**
     * Given a positional args list, creates a map of key-value pairs based
     * on the named parameter info encapsulated in this object. 
     */
    public Map<String, Object> getParameterMap(final PositionalArgsList args, 
            final Environment env, boolean ignoreExtraParams) 
    {
        final int argsSize = args.childrenOfType(Expression.class).size();
        final int paramsSize = params.size();
        final Map<String, Object> result = new HashMap<>();
        if (catchall == null && argsSize > paramsSize && !ignoreExtraParams) {
            throw new TemplateException("Expecting exactly " + paramsSize + 
                    " arguments, received " + argsSize + ".", env);
        }
        int min = Math.min(paramsSize, argsSize);
        for (int i=0; i < min; i++) {
            result.put(params.get(i), args.getValueAt(i, env));
        }
        if(hasDefaultExpressions() && argsSize < paramsSize) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterMapScope(env.getCurrentScope(), 
                    result);
            fillInDefaults(env, scope, params.subList(argsSize, paramsSize));
        }
        if(catchall != null) {
            List<Object> catchAllVars = new ArrayList<>();
            result.put(catchall, catchAllVars);
            for (int i = paramsSize; i < argsSize; i++) {
                catchAllVars.add(args.getValueAt(i, env));
            }
        }
        return result;
    }
    
    public Map<String, Object> getParameterMap(NamedArgsList args, Environment env) 
    {
        Map<String, Object> result = new HashMap<>();
        Collection<String> unresolvedParamNames = null;
        Map<String, Expression> argsMap = args.getCopyOfMap();
        for (String paramName : params) {
            Expression argExp = argsMap.remove(paramName);
            if (argExp != null) {
                Object value = argExp.evaluate(env);
                TemplateNode.assertIsDefined(value, argExp, env);
                result.put(paramName, value);
            }
            else if(defaults != null && defaults.containsKey(paramName)) {
                if(unresolvedParamNames == null) {
                    unresolvedParamNames = new LinkedList<String>();
                }
                unresolvedParamNames.add(paramName);
            }
            else {
                throw new TemplateException("Missing required parameter " + paramName, env);
            }
        }
        if(unresolvedParamNames != null) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterMapScope(env.getCurrentScope(), result);
            fillInDefaults(env, scope, unresolvedParamNames);
        }
        SimpleMapModel catchAllMap = null;
        if (catchall != null) {
            catchAllMap = new SimpleMapModel();
            result.put(catchall, catchAllMap);
        }
        if (!argsMap.isEmpty()) {
            if(catchall != null) {
                for (Map.Entry<String, Expression> entry : argsMap.entrySet()) {
                    Expression exp = entry.getValue();
                    Object val = exp.evaluate(env);
                    assertIsDefined(val, exp, env);
                    catchAllMap.put(entry.getKey(), val);
                }
            } else {
                throw new TemplateException("Extraneous parameters " + 
                        argsMap.keySet() + " provided.", env);
            }
        }
        return result;
    }

    public Map<String, Object> getParameterMap(ArgsList args, Environment env) {
        if (args instanceof NamedArgsList) {
            return getParameterMap((NamedArgsList) args, env);
        } 
        if(args instanceof PositionalArgsList) {
            return getParameterMap((PositionalArgsList) args, env, false);
        }
        throw new AssertionError();
    }
}

Macro :
    <MACRO>
    IdentifierOrStringLiteral
    [<OPEN_PAREN>]
    ParameterList
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    Content
    CloseDirectiveBlock("macro")
;

Function#Macro :
    <FUNCTION>
    IdentifierOrStringLiteral
    [<OPEN_PAREN>]
    ParameterList
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    Content
    CloseDirectiveBlock("function")
;

INJECT Macro :
    import freemarker.template.*;
    import freemarker.core.Environment;
    import freemarker.core.ast.TextBlock;
    extends TemplateElement implements TemplateModel
{
    static public final Macro DO_NOTHING_MACRO = new Macro();
    static {
    	DO_NOTHING_MACRO.add((TemplateElement) TextBlock.EMPTY_BLOCK);
    }

    public boolean isFunction() {
    	return get(0).getType() == FUNCTION;
    }

    public String getName() {
        if (this == DO_NOTHING_MACRO) {
            return ".pass";
        }
        if (get(1) instanceof Identifier) {
            return get(1).toString();
        }
        return ((StringLiteral) get(1)).getAsString();
    }

    public ParameterList getParams() {
        return firstChildOfType(ParameterList.class);
    }

    public void close() {
    	ParameterList params = getParams();
    	for (String paramName : params.getParams()) {
    		declareVariable(paramName);
    	}
    	String catchallVar = params.getCatchAll();
    	if (catchallVar != null) {
    		declareVariable(catchallVar);
    	}
    }
    


    public void execute(Environment env) {
        env.visitMacroDef(this);
    }

    public String getDescription() {
        return (isFunction() ? "function " : "macro ") + getName();
    }
}

UnifiedCall :
   <UNIFIED_CALL>
   Expression
   [<TERMINATING_WHITESPACE>]
   [ArgsList]
   [
       <SEMICOLON>[<TERMINATING_WHITESPACE>]
       ParameterList
   ] 
   (
      <EMPTY_DIRECTIVE_END>
      |
      <DIRECTIVE_END>
      Content
      <UNIFIED_CALL_END>      
   )  
;

INJECT UnifiedCall :
    import java.io.IOException;
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.parser.ast.Macro;
    import freemarker.template.TemplateDirectiveModel;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    public Expression getNameExp() {
        return (Expression) get(1);
    }

    public ArgsList getArgs() {
        ArgsList result = firstChildOfType(ArgsList.class);
        if (result == null) result = new PositionalArgsList();
        return result;
    }

    public ParameterList getBodyParameters() {
        return firstChildOfType(ParameterList.class);
    }

    public void close() {
    	ParameterList bodyParameters = getBodyParameters();
    	if (bodyParameters != null) {
    		for (String paramName : bodyParameters.getParams()) {
    			declareVariable(paramName);
    		}
    		String catchallParam = bodyParameters.getCatchAll();
    		if (catchallParam != null) {
    			declareVariable(catchallParam);
    		}
    	}
    }

    public void execute(Environment env) throws IOException {
        Expression nameExp = getNameExp();
        Object tm = nameExp.evaluate(env);
        ArgsList args = getArgs();
        ParameterList bodyParameters = getBodyParameters();
        if (tm == Macro.DO_NOTHING_MACRO) return; // shortcut here.
        if (tm instanceof Macro) {
            Macro macro = (Macro) tm;
            if (macro.isFunction()) {
                throw new TemplateException("Routine " + macro.getName() 
                        + " is a function. A function can only be called " +
                        "within the evaluation of an expression.", env);
            }    
            env.render(macro, args, bodyParameters, firstChildOfType(TemplateElement.class));
        }
        else if (tm instanceof TemplateDirectiveModel) {
            Map<String, Object> argMap
                    = args != null
                            ? args.getParameterMap(tm, env)
                            : new HashMap<String, Object>();
            List<String> paramNames;
            if(bodyParameters == null) {
                paramNames = Collections.emptyList();
            }
            else {
                paramNames = bodyParameters.getParamNames();
            }
            env.render(firstChildOfType(TemplateElement.class), (TemplateDirectiveModel) tm, argMap, paramNames);
        }
        else {
            assertNonNull(tm, nameExp, env);
            throw new TemplateException(getStartLocation() + ": " + getNameExp() + 
                    " is not a user-defined directive.", env);
        }
    }
    
    public String getDescription() {
        return "user-directive " + getNameExp();
    }
}

Map<String, Expression> NamedArgs#void :
{
    Map<String, Expression> result = new LinkedHashMap<String, Expression>();
    Token t;
    Expression exp;
}
  (
     t=<ID>
     <EQUALS>
     exp=Expression
     {
        if (result.containsKey(t.toString())) {
           throw new ParseException(getErrorStart(t)
              + "\nValue of named parameter '" + t.toString()
              + "' may only be specified once.", t.getBeginLine(), t.getEndLine());
        }
        result.put(t.toString(), exp);
     }
  )+
  {
     return result;
  }
;

TerseComment#Comment :
	<TERSE_COMMENT>
	(
	   <PRINTABLE_CHARS> 
	)*
	<TERSE_COMMENT_END>
;

INJECT Comment :
    import freemarker.core.Environment;
    extends TemplateElement
{
    public String getText() {
      StringBuffer buf = new StringBuffer();
      for (Node n: childrenOfType(PRINTABLE_CHARS)) {
         buf.append(n.toString());
      }
    	return buf.toString();
    }

    public void execute(Environment env) {
    // do nothing, skip the body
    }

    public String getDescription() {
        String s = getText().trim();
        if (s.length() > 20) {
            s = s.substring(0, 20) + "...";
        }
        return "comment (" + s + ")";
    }   
}

NoParseBlock :
    <NOPARSE>
    (
       <PRINTABLE_CHARS> 
    )*
    <NOPARSE_END>
;

INJECT NoParseBlock : extends freemarker.core.parser.ast.MixedContent

SwitchBlock :
   <SWITCH>
   Expression
   <DIRECTIVE_END>
   (<WHITESPACE>)*   
   (
     (
      <CASE>
      Expression
      <DIRECTIVE_END>
      Content
     )#CaseBlock
   )*
   [
     (
      <DEFAUL>
      Content
     )#CaseBlock
   ]
   CloseDirectiveBlock("switch")
;

INJECT SwitchBlock : 
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.core.BreakException;
    import freemarker.template.TemplateException;
    import static freemarker.ext.beans.ObjectWrapper.*;
    extends TemplateElement  
{
    public void execute(Environment env) throws IOException {
        boolean foundMatch = false;
        Object testValue = firstChildOfType(Expression.class).evaluate(env);
        try {
            for (CaseBlock cb : childrenOfType(CaseBlock.class)) {
                if (foundMatch) {
                    cb.execute(env);
                }
                else {
                    Expression testExp = cb.getExpression();
                    foundMatch = testExp == null || equals(env, testValue, cb.getExpression().evaluate(env));
                    if (foundMatch) cb.execute(env);
                }
            }
        } catch (BreakException be) {}
    }

    private boolean equals(Environment env, Object first, Object second) {
        if (isNumber(first) && isNumber(second)) {
            return asNumber(first).equals(asNumber(second));
        }
        if (isString(first) && isString(second)) {
            return asString(first).equals(asString(second));
        }
        throw new TemplateException("Can only compare numbers and strings", env);
    }
}

INJECT CaseBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement  
{
    public Expression getExpression() {
        return firstChildOfType(Expression.class);
    }

    public void execute(Environment env) throws IOException {
        env.render(firstChildOfType(TemplateElement.class));
    }

    public String getDescription() {
        return get(0).toString() + " block";
    }
}

EscapeBlock :
    <ESCAPE>
    <ID>
    <AS>
    Expression
    <DIRECTIVE_END>
    Content
    CloseDirectiveBlock("escape")
;

INJECT EscapeBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    private Expression escapedExpression;

    public Expression getExpression() {
    	return (Expression) get(3);
    }
    
    public String getVariable() {
    	return get(1).toString();
    }
    
    public Expression getEscapedExpression() {
    	return escapedExpression == null ? getExpression() : escapedExpression;
    }
    
    /**
     * This is only used internally.
     */
    public void setEscapedExpression(Expression escapedExpression) {
    	this.escapedExpression = escapedExpression;
    }

    public void setContent(TemplateElement nestedBlock) {
        this.add(nestedBlock);
    }

    public void execute(Environment env) throws TemplateException, IOException {
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class));
        }
    }

    public Expression doEscape(Expression subst) {
        return getEscapedExpression().deepClone(getVariable(), subst);
    }

    public String getDescription() {
        return "escape " + getVariable() + " as " + getEscapedExpression().toString();
    }
}

NoEscapeBlock :
    <NOESCAPE>
    Content
    CloseDirectiveBlock("noescape")
;

INJECT NoEscapeBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class));
        }
    }

    public String getDescription() {
        return "noescape block";
    }
}


Token CloseDirectiveBlock(String expectedTags) :
{
	Token t;
}
    t=<CLOSE_DIRECTIVE_BLOCK>
	{
		String name = t.toString();
		name = name.substring(3, name.length() -1);
		if (name.length()>0) {
			StringTokenizer st = new StringTokenizer(expectedTags, ", ");
			boolean found = false;
			while (st.hasMoreTokens()) {
				if (st.nextToken().equals(name.trim())) found = true;
			}
			if (!found) {
				throw new ParseException(getErrorStart(t) + " Expecting " + t.toString().substring(0,3) + expectedTags + t.toString().charAt(t.toString().length() -1));
			}
		}
		return t;
	}
;


/**
 * Production to terminate potentially empty elements. Either a ">" or "/>"
 */

Token LooseDirectiveEnd#void :
{
    Token t;
}
   (
      t=<DIRECTIVE_END>
      |
      t=<EMPTY_DIRECTIVE_END>
   )
   {
      return t;
   }
;

PropertySetting :
   <SETTING>
   <ID>
   <EQUALS>
   Expression
   LooseDirectiveEnd
;

INJECT PropertySetting :
    import freemarker.core.Environment;
    import static freemarker.ext.beans.ObjectWrapper.*;
    extends TemplateElement
{
    public String getKey() {
    	return firstChildOfType(ID).toString();
    }
    
    public Expression getValue() {
    	return firstChildOfType(Expression.class);
    }

    public void execute(Environment env) {
        Object mval = getValue().evaluate(env);
        String strval;
        if (isString(mval)) {
            strval = asString(mval);
        } else if (isBoolean(mval)) {
            strval = asBoolean(mval) ? "true" : "false";
        } else if (isNumber(mval)) {
            strval = asNumber(mval).toString();
        } else {
            strval = getValue().getStringValue(env);
        }
        env.setSetting(getKey(), strval);
    }

    public String getDescription() {
        return "setting " + getKey() + " set to " + "\"" + getValue() + "\" "
	    + "[" + getStartLocation() + "]";
    }    
}

VarDirective :
{
    Expression var, valueExp = null;
}
   <VAR>
   (
     var=IdentifierOrStringLiteral
     [
       <EQUALS>
       valueExp=Expression
     ]
   )
   {
      CURRENT_NODE.addVar(var, valueExp);
      valueExp = null;
   }
   (
      (
        [<COMMA>]
        var=IdentifierOrStringLiteral
        [
           <EQUALS>
           valueExp=Expression
        ]
      )
      {
         CURRENT_NODE.addVar(var, valueExp);
         valueExp = null;
      }
   )*
   LooseDirectiveEnd
;

INJECT VarDirective :
   import java.util.*;
   import freemarker.template.*;
   import freemarker.core.*;
   extends TemplateElement
{
    private Map<String, Expression> vars = new LinkedHashMap<String, Expression>();

    public void execute(Environment env) {
        for (Map.Entry<String, Expression> entry : vars.entrySet()) {
            String varname = entry.getKey();
            Expression exp = entry.getValue();
            Scope scope = env.getCurrentScope();
            if (exp == null) {
                if (scope.get(varname) == null) {
                    scope.put(varname, Constants.JAVA_NULL);
                }
            } 
            else {
                Object tm = exp.evaluate(env);
                assertIsDefined(tm, exp, env);
                scope.put(varname, tm);
            }
        }
    }

    public Map<String, Expression> getVariables() {
        return Collections.unmodifiableMap(vars);
    }

    public void addVar(Expression name, Expression value) {
        String varname = name.toString();
        if (name instanceof StringLiteral) {
            varname = ((StringLiteral) name).getAsString();
        }
        vars.put(varname, value);
    }
    
    public void addVar(String name) {
        vars.put(name, null);
    }

    public String getDescription() {
        return "variable declaration";
    }
}

/**
 * A production for FreeMarker directives.
 */
TemplateElement#abstract :
     IfBlock
     |
     ListBlock
     |
     ForEachBlock
     |
     AssignmentInstruction
     |
     BlockAssignment
     |
     IncludeInstruction
     |
     ImportDeclaration
     |
     Macro
     |
     Function
     |
     UnifiedCall
     |
     TerseComment
     |
     NoParseBlock
     |
     SwitchBlock
     |
     PropertySetting
     |
     VarDirective
     |
     BreakInstruction
     |
     ReturnInstruction
     |
     StopInstruction
     |
     FlushInstruction
     |
     TrimInstruction
     |
     SCAN 1 \...\Macro =>
     NestedInstruction
     |
     SCAN 1 \...\Macro =>
     FallbackInstruction
     |
     EscapeBlock
     |
     SCAN 1 \...\EscapeBlock =>
     NoEscapeBlock
     |
     VisitNode
     |
     RecurseNode
     |
     AttemptBlock
;

INJECT TemplateElement :
   import java.util.*;
   import java.io.IOException;
   import freemarker.core.Environment;
{
    /**
     * Processes the contents of this <tt>TemplateElement</tt> and
     * outputs the resulting text
     *
     * @param env The runtime environment
     */
    abstract public void execute(Environment env) throws IOException;

    // The scoped variables defined in this element.
    private HashSet<String> declaredVariables;

    public Set<String> declaredVariables() {
        return declaredVariables;
    }

    public boolean declaresVariable(String name) {
    	return declaredVariables != null && declaredVariables.contains(name);
    }
    
    public void declareVariable(String varName) {
    	if (declaredVariables == null) declaredVariables = new HashSet<String>();
    	declaredVariables.add(varName);
    }
    
    public boolean isIgnorable() {
        return false;
    }

    public final boolean createsScope() {
    	return declaredVariables != null && !declaredVariables.isEmpty();
    }
}

/**
 * Production for a block of raw text
 * i.e. text that contains no
 * FreeMarker directives.
 */
List<TextBlock> PCData#void :
{
    StringBuilder buf = new StringBuilder();
    Token start=null;
    List<TextBlock> result = new ArrayList<TextBlock>();
}
    (
      (
         <PRINTABLE_CHARS> 
         |
         <WHITESPACE> 
      )
      {
         popNode();
         buf.append(lastConsumedToken.toString());
         if (start == null) start = lastConsumedToken;
      }
    )+
    {
        return TextBlock.breakIntoBlocks(buf.toString(), template, start.getBeginColumn(), start.getBeginLine());
    }
;

TemplateElement Content#MixedContent(false) :
{
    MixedContent nodes = new MixedContent();
    TemplateElement elem=null;
    List<TextBlock> text;
}
    (
      (
         text=PCData 
         {
            for (TextBlock tb : text) nodes.add(tb);
            for (TextBlock tb : text) pushNode(tb);
         }
         |
         elem=Interpolation {nodes.add(elem);}
         |
         elem=TemplateElement {nodes.add(elem);}
      )
    )*
    {
        clearNodeScope();
        pushNode(nodes);
	    return nodes;
    }
;

INJECT MixedContent :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException 
    {
        for (TemplateElement element : childrenOfType(TemplateElement.class)) {
            env.render(element);
        }
    }

    public String getDescription() {
        if (getParent() == null) {
            return "root element";
        }
        return "content"; // MixedContent is uninteresting in a stack trace.
    }
}


/**
 * A production freemarker text that may contain
 * ${...} but no directives.
 */

TemplateElement FreeMarkerText#MixedContent(false) :
{
     MixedContent nodes = new MixedContent();
     TemplateElement elem = null, begin = null;
     List<TextBlock> text = null;
}
    (
      (
        text=PCData {for (TextBlock tb : text) nodes.add(tb);}
        |
        elem=Interpolation {nodes.add(elem);}
      )
    )+
    {
       return nodes;
    }
;

TemplateHeaderElement# :
  [<WHITESPACE>]
  (
    <TRIVIAL_FTL_HEADER>
    |
    (
        <FTL_HEADER>
        (
            <ID>
            <EQUALS>
            Expression
        )*
        LooseDirectiveEnd
    )
  )
;  

INJECT TemplateHeaderElement :
    import java.util.*;
    import freemarker.template.*;
    import static freemarker.template.utility.StringUtil.*;
    import static freemarker.ext.beans.ObjectWrapper.*;
{

    private Map<String,Expression> params = new LinkedHashMap<>();

    public void close() {
        List<Node> ids = childrenOfType(ID);
        for (Node n : ids) {
            String key = n.toString();
            Expression exp = (Expression) n.nextSibling().nextSibling();
            params.put(key, exp);
        }
    }

    public boolean hasParameter(String name) {
        return params.containsKey(name);
    }

    public Map<String,Expression> getParams() {
        return params;
    }

    public Object getParameter(String name) {
        if (!hasParameter(name)) {
            return null;
        }
        Expression exp = params.get(name);
        return exp.evaluate(null);
    }

	public String getStringParameter(String name) {
		Object tm = getParameter(name);
        if (tm == null) return null;
		try {
			return asString(tm);
		} catch (ClassCastException cce) {
		    throw new IllegalArgumentException("Parameter " + name + " is not a string.");
		}
	}

	public boolean getBooleanParameter(String name) {
		Object tm = getParameter(name);
		if (tm == null) {
			throw new IllegalArgumentException("No parameter " + name);
		}
		if (isBoolean(tm)) {
			return asBoolean(tm);
		}
		if (isString(tm)) {
			try {
				return getYesNo(asString(tm));
			} catch (Exception e) {
				throw new IllegalArgumentException(e);
			}
		}
		throw new IllegalArgumentException("Parameter " + name + " is not a boolean type.");
	}
}

Map<String,Expression> ParamList#void :
{
   Identifier id;
   Expression exp;
   Map<String,Expression> result = new HashMap<String,Expression>();
}
   (
      id=Identifier
      <EQUALS>
      exp=Expression {result.put(id.toString(), exp);}
      [<COMMA>]
   )+
   {
       return result;
   }
;

Expression IdentifierOrStringLiteral#void :
{
   Expression exp;
}
   (
      exp=Identifier
      |
      exp=StringLiteral
   )
   {
      return exp;
   }   
;

/**
 * Root production to be used when parsing
 * an entire file.
 */
TemplateElement Root#void :
{
   TemplateHeaderElement header;
   TemplateElement doc;
}
   [
      SCAN [<WHITESPACE>](<TRIVIAL_FTL_HEADER>|<FTL_HEADER>) =>
       header=TemplateHeaderElement
       {
       	   template.setHeaderElement(header);
       	   String templateEncoding = template.getEncoding();
       	   if (templateEncoding != null && header.hasParameter("encoding")) {
       	   	  String encoding = null;
       	   	  try {
       	   	     encoding = header.getStringParameter("encoding");
       	   	  } catch (Exception e) {}
       	   	  if (encoding != null && !encoding.equals(templateEncoding)) {
       	   	  	throw new Template.WrongEncodingException(encoding);
       	   	  }
       	   }
       	   if (header.hasParameter("strip_text")) {
       	   	  try {
       	   	  	 this.stripText = header.getBooleanParameter("strip_text");
       	   	  } catch (Exception e) {
       	   	  	throw new ParseException(e.getMessage());
       	   	  }
       	   }
       	   	
       }
   ]
   doc=Content
   <EOF>
   {
       return doc;
   }
   ;