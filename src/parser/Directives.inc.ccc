// This file defines the various 
// template elements. It is INCLUDEd
// from the main template.

/**
 * A production representing the ${...}
 * that outputs a variable.
 */
Interpolation# :
   <OUTPUT_ESCAPE> 
   Expression
   <CLOSE_BRACE>
;

INJECT Interpolation :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    private Expression escapedExpression; // This will be the same as the expression if we are not within an escape block.

    public void setEscapedExpression(Expression escapedExpression) {
    	this.escapedExpression = escapedExpression;
    }
    
    public Expression getEscapedExpression() {
      if (escapedExpression==null) return getExpression();
    	return this.escapedExpression;
    }
    
    public Expression getExpression() {
    	return firstChildOfType(Expression.class);
    }

    /**
     * Outputs the string value of the enclosed expression.
     */
    public void execute(Environment env) throws TemplateException, IOException {
        env.getOut().write(getEscapedExpression().getStringValue(env));
    }

    public String getDescription() {
        return this.getSource()  +
        (escapedExpression == null 
            ? "" 
            : " escaped ${" + escapedExpression.getDescription() + "}");
    }
}

IfBlock# :
  (
    <IF>
    Expression
    <DIRECTIVE_END>
    Content
  )#ConditionalBlock
  (
    (
        <ELSE_IF>
        Expression
        <DIRECTIVE_END>
        Content
    )#ConditionalBlock
  )*
  [
    (
        <ELSE>
        Content
    )#ConditionalBlock
  ]
  CloseDirectiveBlock("if")
;

INJECT IfBlock :
    import java.util.*;
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        for (ConditionalBlock cblock : childrenOfType(ConditionalBlock.class)) {
            Expression condition = cblock.getCondition();
            if (condition == null || condition.isTrue(env)) {
                if (cblock.firstChildOfType(TemplateElement.class) != null) {
                    env.render(cblock);
                }
                return;
            }
        }
    }

    public String getDescription() {
        return "if-else ";
    }
}

INJECT ConditionalBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public Expression getCondition() {
    	return firstChildOfType(Expression.class);
    }
    
    public void execute(Environment env) throws IOException {
        env.render(firstChildOfType(TemplateElement.class));
    }

    public String getDescription() {
        return get(0).toString() + " block";
    }
}

AttemptBlock# :
   <_ATTEMPT>
   Content
   RecoveryBlock
   CloseDirectiveBlock("attempt, recover")
;

INJECT AttemptBlock :
    import java.io.IOException;
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    public TemplateElement getAttemptBlock() {
        return childrenOfType(TemplateElement.class).get(0);
    }
    
    public TemplateElement getRecoverBlock() {
        return childrenOfType(TemplateElement.class).get(1);
    }

    public void execute(Environment env) throws IOException 
    {
        env.render(getAttemptBlock(), getRecoverBlock());
    }

    public String getDescription() {
        return "attempt block";
    }
}

RecoveryBlock# : 
   <_RECOVER>
   Content
;

INJECT RecoveryBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    public void execute(Environment env) throws TemplateException, IOException 
    {
    	if (firstChildOfType(TemplateElement.class) != null) {
    		env.render(firstChildOfType(TemplateElement.class));
    	}
    }

    public String getDescription() {
        return "recover block";
    }
}

ListBlock#IteratorBlock :
   <LIST> 
   Expression
   <AS>
   <ID>
   <DIRECTIVE_END>
   Content
   CloseDirectiveBlock("list")
;

ForEachBlock#IteratorBlock :
   <FOREACH> 
   <ID>
   <IN>
   Expression
   <DIRECTIVE_END>
   Content
   CloseDirectiveBlock("foreach")
;

INJECT IteratorBlock :
    import java.io.IOException;
    import freemarker.template.*;
    import freemarker.core.*;
    extends TemplateElement
{
    public boolean isForeach() {
        return get(0).getType() == FOREACH;
    }

    public String getIndexName() {
        return isForeach() ? get(1).toString() : get(3).toString();
    }
    
    public Expression getListExpression() {
        return isForeach() ? (Expression) get(3) : (Expression) get(1);
    }

    public void execute(Environment env) throws TemplateException, IOException 
    {
        Object baseModel = getListExpression().evaluate(env);
        assertNonNull(baseModel, getListExpression(), env);
        env.process(new LoopContext(this, env.getCurrentScope(), baseModel)); // REVISIT
    }

    public String getDescription() {
        return isForeach() ?
            "foreach " + getIndexName() + " in " + getListExpression() 
            :
            "list " + getListExpression() + " as " + getIndexName();
    }
}

VisitNode Visit :
{
   Token start, end;
   Expression targetNode, namespaces=null;
}
   start=<VISIT>
   targetNode=Expression
   [
       <USING>
       namespaces=Expression
   ]
   end=LooseDirectiveEnd
   {
       VisitNode result = new VisitNode(targetNode, namespaces);
       result.setLocation(template, token_source, start, end);
       return result;
   }
;

RecurseNode Recurse :
{
   Token start, end = null;
   Expression node=null, namespaces=null;
}
   (
      start=<SIMPLE_RECURSE>
      |
      (
         start=<RECURSE>
         [
            node=Expression
         ]
         [
            <USING>
            namespaces=Expression
         ]
         end=LooseDirectiveEnd
      )
   )
   {
       if (end == null) end = start;
       RecurseNode result = new RecurseNode(node, namespaces);
       result.setLocation(template, token_source, start, end);
       return result;
   }
;

FallbackInstruction# :
   <FALLBACK>
;

INJECT FallbackInstruction :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement;
{
    public void execute(Environment env) throws IOException {
        env.fallback();
    }

    public String getDescription() {
        return "fallback instruction";
    }
}

/**
 * Production used to break out of a loop or a switch block.
 */
BreakInstruction# :
    <BREAK>
;

INJECT BreakInstruction :
    import freemarker.core.Environment;
    import freemarker.core.BreakException;
    extends TemplateElement
{
    public void execute(Environment env) {
        throw BreakException.INSTANCE;
    }

    public String getDescription() {
        return "break" + " [" + getStartLocation() + "]";
    }
}

/**
 * Production used to jump out of a macro.
 */
ReturnInstruction# :
   <SIMPLE_RETURN>
   | 
   <RETURN> Expression LooseDirectiveEnd
;

INJECT ReturnInstruction :
    import freemarker.core.Environment;
    import freemarker.core.ReturnException;
    import freemarker.core.ast.Macro;
    extends TemplateElement
{
    public Object getReturnValue(Environment env) {
        if (size()==1) return null;
        return ((Expression)get(1)).evaluate(env);
    }
    
    public void execute(Environment env) {
        env.setLastReturnValue(getReturnValue(env));
        if (nextSibling() != null) {
            // We need to jump out using an exception.
            throw ReturnException.INSTANCE;
        }
        if (!(getParent() instanceof Macro || getParent().getParent() instanceof Macro)) {
            // Here also, we need to jump out using an exception.
            throw ReturnException.INSTANCE;
        }
    }

    public String getDescription() {
        return "return" + " [" + getStartLocation() + "]";
    }
}

StopInstruction# :
   <HALT>
   |
   <STOP> Expression LooseDirectiveEnd
;

INJECT StopInstruction :
   import freemarker.core.Environment;
   import freemarker.core.StopException;
   extends TemplateElement
{
   public String getMessage(Environment env) {
      if (size()==1) return "";
      return ((Expression)get(1)).getStringValue(env);
   }

    public void execute(Environment env) {
        throw new StopException(env, getMessage(env));
    }

    public String getDescription() {
        return "stop" + " [" + getStartLocation() + "]";
    }
}

NestedInstruction# :
    <SIMPLE_NESTED>
    |
    (
        <NESTED>
        PositionalArgsList
        LooseDirectiveEnd
    )
;

INJECT NestedInstruction :
    import java.io.IOException;
    import freemarker.core.*;
    import freemarker.template.*;
    extends TemplateElement
{
    public ArgsList getArgs() {
    	return firstChildOfType(ArgsList.class);
    }
    
    /**
     * There is actually a subtle but essential point in the code below.
     * A macro operates in the context in which it is defined. However, 
     * a nested block within a macro instruction is defined in the 
     * context in which the macro was invoked. So, we actually need to
     * temporarily switch the namespace and macro context back to
     * what it was before macro invocation to implement this properly.
     * I (JR) realized this thanks to some incisive comments from Daniel Dekany.
     */
    public void execute(Environment env) throws IOException {
        MacroInvocationBodyContext bodyContext = new MacroInvocationBodyContext(env, (PositionalArgsList) getArgs());
        env.render(bodyContext);
    }

    public String getDescription() {
        return "nested macro content";
    }
}

FlushInstruction# :
   <FLUSH>
;

INJECT FlushInstruction :
   import java.io.IOException;
   import freemarker.core.Environment;
   extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        env.getOut().flush();
    }

    public String getDescription() {
        return "flush instruction";
    }
}

TrimInstruction# : <TRIM>|<LTRIM>|<RTRIM>;

INJECT TrimInstruction :
   import freemarker.core.Environment;
   extends TemplateElement
{
    public boolean isLeft() {
    	return get(0).getType() != RTRIM;
    }
    
    public boolean isRight() {
    	return get(0).getType() != LTRIM;
    }

    public void execute(Environment env) {
        // This instruction does nothing at render-time, only parse-time.
    }

    public String getDescription() {
        String type = "";
        if (!isRight()) type = "left ";
        if (!isLeft()) type = "right ";
        return type + "trim instruction";
    }

    public boolean isIgnorable() {
        return true;
    }
}

TemplateElement Assign :
{
   Token start, end;
   int type;
   Token id=null;
   Expression nameExp, exp, nsExp=null;
   String varName;
   TemplateElement block;
   Map<String, Expression> assignments = new LinkedHashMap<>();
   String assignmentType;
   AssignmentInstruction result;
}
    (
      start=<ASSIGN> {type = AssignmentInstruction.NAMESPACE; assignmentType="assign";}
      |
      start=<GLOBALASSIGN>{type = AssignmentInstruction.GLOBAL; assignmentType = "global";}
      |
      start=<LOCALASSIGN> {type = AssignmentInstruction.LOCAL; assignmentType = "local";}
      |
      start=<SET> {type = AssignmentInstruction.SET; assignmentType = "set";}
    )
    {result = new AssignmentInstruction(type);}
    nameExp=IdentifierOrStringLiteral
    {
       varName = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
    }
    ((
       <EQUALS>
       exp=Expression {assignments.put(varName, exp);}
       (
   //      SCAN [<COMMA>](<ID>|<STRING_LITERAL>)<EQUALS> =>
            [<COMMA>]
            nameExp=IdentifierOrStringLiteral
            {
               varName = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
            }
            <EQUALS> =>||
            exp=Expression
            {
            	assignments.put(varName, exp);
            } 
       )*
       [
          id=<IN>
          nsExp=Expression {if (type != AssignmentInstruction.SET && type != AssignmentInstruction.NAMESPACE) {
          	   ParsingProblem problem = new ParsingProblem("Can only assign to namespace with #set or #assign.", result);
          	   template.addParsingProblem(problem);
            } 
          }
       ]
       end=LooseDirectiveEnd
       {
           result.setNamespaceExp(nsExp);
		   for (Map.Entry<String,Expression> entry : assignments.entrySet()) {
           	    result.addAssignment(entry.getKey(), entry.getValue());
           }
           result.setLocation(template, token_source, start, end);
           return result;
       }
    )
    |
    (
       [
          id=<IN>
          nsExp=Expression {if (type != AssignmentInstruction.NAMESPACE && type != AssignmentInstruction.SET) throw new ParseException(getErrorStart(id) + "\nCannot assign to namespace here.", id.getBeginLine(), id.getBeginColumn());}
       ]
       <DIRECTIVE_END>
       block=Content
       end=CloseDirectiveBlock(assignmentType)
       {
       	  String name = end.toString().substring(3, end.toString().length() -1);
       	  switch (type) {
       	   	   case AssignmentInstruction.LOCAL : if (name.length() >0 && !name.equals("local")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	   	   case AssignmentInstruction.NAMESPACE : if (name.length() >0 && !name.equals("assign")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	   	   case AssignmentInstruction.GLOBAL : if (name.length() >0 && !name.equals("global")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	   	   case AssignmentInstruction.SET : if (name.length() >0 && !name.equals("set")) throw new ParseException(getErrorStart(end) + "\nMismatched assignment tags.", end.getBeginLine(), end.getBeginColumn()); break;
       	  }
          BlockAssignment ba = new BlockAssignment(block, varName, type, nsExp);
          ba.setLocation(template, token_source, start, end);
          return ba;
       }
    ))
;

#Include :
{
   Token att, start, end;
   Expression nameExp, exp, parseExp = null, encodingExp = null;
   boolean freshNamespace;
}
    (
        start=<_INCLUDE> {freshNamespace = false;}
        |
        start=<EMBED> {freshNamespace=true;}
    )
    nameExp=Expression
    [<SEMICOLON>]
    (
	  att=<ID>
	  <EQUALS>
	  exp=Expression
	  {
	     String attString = att.toString();
	     if (attString.equalsIgnoreCase("parse")) {
	        if (parseExp != null) {
	           String msg = getErrorStart(att)
	                 + "\nparse may not be specified more than once.";
	           throw new ParseException(msg, att.getBeginLine(), att.getBeginColumn());
	        }
	        parseExp = exp;
	     }
	     else if (attString.equalsIgnoreCase("encoding")) {
	        if (encodingExp != null) {
	           String msg = getErrorStart(att)
	                 + "\nencoding may not be specified more than once.";
	           throw new ParseException(msg, att.getBeginLine(), att.getBeginColumn());
	        }
	        encodingExp = exp;
	     }
	     else {
	         String msg = getErrorStart(att)
	               + "\nexpecting parse= or encoding= to be specified.";
	         throw new ParseException(msg, att.getBeginLine(), att.getBeginColumn());
	     }
	  }
	)*
    end=LooseDirectiveEnd
    {
       Include result = new Include(template, nameExp, freshNamespace, encodingExp, parseExp);
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

ImportDeclaration# :
   <IMPORT>
   Expression
   <AS>
   <ID>
   LooseDirectiveEnd
   {
       CURRENT_NODE.setTemplate(template);
       //if (template != null) template.addImport(CURRENT_NODE);
   }
;

INJECT ImportDeclaration :
    import java.io.IOException;
    import freemarker.template.Template;
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.log.Logger;
    extends TemplateElement
{
    private String templatePath="";
    @Property Template template;

    public String getNamespace() {
    	return get(3).toString();
    }
    
    public Expression getTemplateNameExpression() {
    	return (Expression) get(1);
    }

    public void execute(Environment env) throws IOException {
        String templateNameString = getTemplateNameExpression().getStringValue(env);
        if( templateNameString == null ) {
            String msg = "Error " + getStartLocation()
                        + "The expression " + getTemplateNameExpression() + " is undefined.";
            throw new InvalidReferenceException(msg, env);
        }
        Template importedTemplate;
        try {
            if (templateNameString.indexOf("://") >0) {
                ;
            }
            else if(templateNameString.length() > 0 && templateNameString.charAt(0) == '/')  {
                int protIndex = templatePath.indexOf("://");
                if (protIndex >0) {
                    templateNameString = templatePath.substring(0, protIndex + 2) + templateNameString;
                } else {
                    templateNameString = templateNameString.substring(1);
                }
            }
            else {
                templateNameString = templatePath + templateNameString;
            }
            importedTemplate = env.getTemplateForImporting(templateNameString);
        }
        catch (ParseException pe) {
            String msg = "Error parsing imported template "
                        + templateNameString;
            Logger.getLogger("freemarker.runtime").error(msg, pe);
            throw new TemplateException(msg, pe, env);
        }
        catch (IOException ioe) {
            String msg = "Error reading imported file "
                        + templateNameString;
            throw new TemplateException(msg, ioe, env);
        }
        env.importLib(importedTemplate, getNamespace(), false);
    }

    public String getDescription() {
        return "import " + getTemplateNameExpression() + " as " + getNamespace();
    }

    public String getTemplateName() {
        return getTemplateNameExpression().toString();
    }    

    public void close() {
        if (template != null) {
        	String templatePath1 = template.getName();
        	int lastSlash = templatePath1.lastIndexOf('/');
        	templatePath = lastSlash == -1 ? "" : templatePath1.substring(0, lastSlash + 1);
            template.addImport(this);
        }
    }
}

#ParameterList# :
{
	Token arg=null, firstArg=null, ellipsis = null;
	Expression defValue = null;
	String catchAll = null;
	boolean isCatchAll = false, hasDefaults = false;
	Set<String> paramNames = new HashSet<String>();
}
    (
          arg=<ID> 
          {
          	if (firstArg == null) firstArg = arg;
          	defValue = null;
          	if (paramNames.contains(arg.toString())) {
          		throw new ParseException(getErrorStart(arg) + "\nThe parameter " + arg.toString() + " cannot be repeated.");
          	}
          	paramNames.add(arg.toString());
          }
          [
             ellipsis=<ELLIPSIS> { isCatchAll = true; }
          ]
          [
            <EQUALS>
          	defValue=Expression
            {
		      hasDefaults = true;
            }
          ]
          [<COMMA>]
	  {
          if (catchAll != null) {
              throw new ParseException(getErrorStart(arg)
                + "\nThere may only be one \"catch-all\" parameter in a macro declaration, "
                + "and it must be the last parameter.", arg.getBeginLine(), arg.getEndLine());
          }
          if (isCatchAll) {
              if (defValue != null) {
                  throw new ParseException(getErrorStart(arg)
                    + "\n\"Catch-all\" macro parameter may not have a default value.",
                    arg.getBeginLine(), arg.getEndLine());
              }
              CURRENT_NODE.setCatchAll(arg.toString());
          } 
          else if (defValue == null) {
             if (hasDefaults) {
                  throw new ParseException(getErrorStart(arg)
                    + "\nIn a macro declaration, parameters without a default value "
                    + "must all occur before the parameters with default values.",
                    arg.getBeginLine(), arg.getEndLine());
             }
          	 CURRENT_NODE.addParam(arg.toString());
          }
          else {
              CURRENT_NODE.addParam(arg.toString(), defValue);
          	  hasDefaults = true;
          }
	  }
    )*
	{
		return CURRENT_NODE;
	}
;

INJECT ParameterList :
   import java.io.IOException;
   import java.util.*;
   import freemarker.core.Environment;
   import freemarker.core.InvalidReferenceException;
   import freemarker.core.Scope;
   import freemarker.core.TemplateRunnable;
   import freemarker.core.helpers.NamedParameterListScope;
   import freemarker.core.helpers.NamedParameterMapScope;
   import freemarker.ext.beans.SimpleMapModel;
   import freemarker.template.TemplateException;
   import freemarker.template.TemplateModelException;
{
    private List<String> params = new ArrayList<String>();
    private Map<String, Expression> defaults;
    private String catchall;

    public void addParam(String paramName) {
        params.add(paramName);
    }

    public List<String> getParams() {
      return params;
    }

    public List<String> getParamNames() {
        List<String> result = new ArrayList<String>(params);
        if (catchall != null) result.add(catchall);
        return result;
    }


    boolean containsParam(String name) {
        return params.contains(name);
    }

    public void addParam(String paramName, Expression defaultExp) {
        if (defaults == null) defaults = new HashMap<String, Expression>();
        defaults.put(paramName, defaultExp);
        addParam(paramName);
    }

    public void setCatchAll(String varname) {
        this.catchall = varname;
    }

    public String getCatchAll() {
        return catchall;
    }

    private boolean hasDefaultExpressions() {
        return defaults != null && !defaults.isEmpty();
    }
    
    public Expression getDefaultExpression(String paramName) {
        return defaults == null ? null : defaults.get(paramName);
    }

    public Expression getDefaultExpression(int paramIndex) {
        if(params == null || paramIndex >= params.size()) {
            return null;
        }
        return getDefaultExpression(params.get(paramIndex));
    }

    private void fillInDefaults(final Environment env, final Scope scope, final Collection<String> paramNames) 
    {
        try {
            env.runInScope(scope, new TemplateRunnable<Object>() {
                public Object run() throws IOException {
                    fillInDefaultsInternal(env, scope, paramNames);
                    return null;
                }
            });
        }
        catch(IOException e) {
            throw new TemplateException(e, env);
        }
    }
    private void fillInDefaultsInternal(Environment env, Scope scope, Collection<String> paramNames) {
        
        boolean resolvedAnArg, hasUnresolvedArg;
        Expression firstUnresolvedExpression;
        InvalidReferenceException firstReferenceException;
        do {
            firstUnresolvedExpression = null;
            firstReferenceException = null;
            resolvedAnArg = hasUnresolvedArg = false;
            for (String paramName : paramNames) {
                Object arg = scope.get(paramName);
                if (arg == null) {
                    Expression defaultExp = getDefaultExpression(paramName);
                    if (defaultExp != null) {
                        try {
                            Object value = defaultExp.evaluate(env);
                            if(value == null) {
                                if(!hasUnresolvedArg) {
                                    firstUnresolvedExpression = defaultExp;
                                    hasUnresolvedArg = true;
                                }
                            }
                            else {
                                scope.put(paramName, value);
                                resolvedAnArg = true;
                            }
                        }
                        catch(InvalidReferenceException e) {
                            if(!hasUnresolvedArg) {
                                hasUnresolvedArg = true;
                                firstReferenceException = e;
                            }
                        }
                    }
                    else if (arg == null) {
                        throw new TemplateModelException("Missing required parameter " + paramName);
                    }
                }
            }
        }
        while(resolvedAnArg && hasUnresolvedArg);
        if(hasUnresolvedArg) {
            if(firstReferenceException != null) {
                throw firstReferenceException;
            }
            else {
                assert firstUnresolvedExpression != null;
                assertNonNull(null, firstUnresolvedExpression, scope.getEnvironment());
            }
        }
    }

    /**
     * Given a positional list of argument expressions, create a positional 
     * list of template models. Used to pass positional arguments to a template
     * method model.
     */
    public List<Object> getParameterSequence(final PositionalArgsList args, 
            final Environment env) 
    {
        final List<Object> result = new ArrayList<>(params.size());
        int argsSize = args.size();
        int paramsSize = params.size();
        int commonSize = Math.min(argsSize, paramsSize);
        // Set formal args that have matching actual args
        for(int i = 0; i < commonSize; ++i) {
            result.add(args.getValueAt(i, env));
        }
        if(commonSize < argsSize) {
            // More actual args than formal args -- use catchall if present
            if (catchall == null) {
                throw new TemplateException("Extraneous parameters provided; expected " + 
                        paramsSize + ", got " + argsSize, env);
            }
            for (int i = commonSize; i < argsSize; i++) {
                result.add(args.getValueAt(i, env));
            }
        }
        else if(commonSize < paramsSize) {
            // More formal args than actual args -- fill in defaults

            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterListScope(env.getCurrentScope(), 
                    params, result, false);
                fillInDefaults(env, scope, params.subList(args.size(), params.size()));
        }
        return result;
    }
    
    /**
     * Given a named list of argument expressions, create a positional 
     * list of template models. Used to pass named arguments to a template
     * method model.
     */
    public List<Object> getParameterSequence(final NamedArgsList args, 
            final Environment env) 
    {
        int argsSize = args.size();
        int paramsSize = params.size();
        if(argsSize > paramsSize) {
            Collection<String> l = new LinkedHashSet<String>(args.getArgs().keySet());
            l.removeAll(params);
            throw new TemplateException("Extraneous parameters " + l, env);
        }
        final List<Object> result = new ArrayList<>();
        List<String> unresolvedParamNames = null;
        Map<String, Expression> argsMap = args.getCopyOfMap();
        for (String paramName : params) {
            Expression argExp = argsMap.remove(paramName);
            if (argExp != null) {
                Object argModel = argExp.evaluate(env);
                assertIsDefined(argModel, argExp, env);
                result.add(argModel);
            } else {
                if(unresolvedParamNames == null) {
                    unresolvedParamNames = new LinkedList<String>();
                }
                unresolvedParamNames.add(paramName);
            }
        }
        if(unresolvedParamNames != null) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            final Scope scope = new NamedParameterListScope(
                    env.getCurrentScope(), params, result, false);
            fillInDefaults(env, scope, unresolvedParamNames);
        }
        return result;
    }

    /**
     * Given a positional args list, creates a map of key-value pairs based
     * on the named parameter info encapsulated in this object. 
     */
    public Map<String, Object> getParameterMap(final PositionalArgsList args, 
            final Environment env, boolean ignoreExtraParams) 
    {
        final int argsSize = args.childrenOfType(Expression.class).size();
        final int paramsSize = params.size();
        final Map<String, Object> result = new HashMap<>();
        if (catchall == null && argsSize > paramsSize && !ignoreExtraParams) {
            throw new TemplateException("Expecting exactly " + paramsSize + 
                    " arguments, received " + argsSize + ".", env);
        }
        int min = Math.min(paramsSize, argsSize);
        for (int i=0; i < min; i++) {
            result.put(params.get(i), args.getValueAt(i, env));
        }
        if(hasDefaultExpressions() && argsSize < paramsSize) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterMapScope(env.getCurrentScope(), 
                    result);
            fillInDefaults(env, scope, params.subList(argsSize, paramsSize));
        }
        if(catchall != null) {
            List<Object> catchAllVars = new ArrayList<>();
            result.put(catchall, catchAllVars);
            for (int i = paramsSize; i < argsSize; i++) {
                catchAllVars.add(args.getValueAt(i, env));
            }
        }
        return result;
    }
    
    public Map<String, Object> getParameterMap(NamedArgsList args, Environment env) 
    {
        Map<String, Object> result = new HashMap<>();
        Collection<String> unresolvedParamNames = null;
        Map<String, Expression> argsMap = args.getCopyOfMap();
        for (String paramName : params) {
            Expression argExp = argsMap.remove(paramName);
            if (argExp != null) {
                Object value = argExp.evaluate(env);
                TemplateNode.assertIsDefined(value, argExp, env);
                result.put(paramName, value);
            }
            else if(defaults != null && defaults.containsKey(paramName)) {
                if(unresolvedParamNames == null) {
                    unresolvedParamNames = new LinkedList<String>();
                }
                unresolvedParamNames.add(paramName);
            }
            else {
                throw new TemplateException("Missing required parameter " + paramName, env);
            }
        }
        if(unresolvedParamNames != null) {
            // Create a scope that provides live access to the parameter list
            // so we can reference already defined parameters
            Scope scope = new NamedParameterMapScope(env.getCurrentScope(), result);
            fillInDefaults(env, scope, unresolvedParamNames);
        }
        SimpleMapModel catchAllMap = null;
        if (catchall != null) {
            catchAllMap = new SimpleMapModel();
            result.put(catchall, catchAllMap);
        }
        if (!argsMap.isEmpty()) {
            if(catchall != null) {
                for (Map.Entry<String, Expression> entry : argsMap.entrySet()) {
                    Expression exp = entry.getValue();
                    Object val = exp.evaluate(env);
                    assertIsDefined(val, exp, env);
                    catchAllMap.put(entry.getKey(), val);
                }
            } else {
                throw new TemplateException("Extraneous parameters " + 
                        argsMap.keySet() + " provided.", env);
            }
        }
        return result;
    }

    public Map<String, Object> getParameterMap(ArgsList args, Environment env) {
        if (args instanceof NamedArgsList) {
            return getParameterMap((NamedArgsList) args, env);
        } 
        if(args instanceof PositionalArgsList) {
            return getParameterMap((PositionalArgsList) args, env, false);
        }
        throw new AssertionError();
    }
}

#Macro :
{
   Macro result = new Macro();
   Token arg, start, end;
   Expression nameExp;
   String name;
   TemplateElement block;
   ParameterList params;
   String functionOrMacro;
}
    (
        start=<MACRO> {functionOrMacro = "macro";}
        |
        start=<FUNCTION> {result.setFunction(true); functionOrMacro = "function";}
    )
    nameExp=IdentifierOrStringLiteral
    {
       name = (nameExp instanceof StringLiteral) ? ((StringLiteral) nameExp).getAsString() : nameExp.toString();
       result.setName(name);
    }
    [<OPEN_PAREN>]
    params=ParameterList {result.setParams(params);}
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    block=Content
    end=CloseDirectiveBlock(functionOrMacro)
    {
	   result.setName(name);
	   result.add(block);
      result.setLocation(template, token_source, start, end);
      return result;
    }
;


TemplateElement UnifiedMacroTransform :
{
   Token start=null, end, t;
   Map<String, Expression> namedArgs = null;
   ArrayList<Expression> positionalArgs = null;
   String directiveName = null;
   TemplateElement nestedBlock = null;
   Expression exp;
   UnifiedCall result = new UnifiedCall();
   ArgsList args = null;
   ParameterList bodyParameters = null;
}
    start=<UNIFIED_CALL>
    exp=Expression
    {
        if (exp instanceof Identifier || (exp instanceof DotVariable && ((DotVariable) exp).onlyHasIdentifiers())) {
           //directiveName = exp.getCanonicalForm();
           directiveName = exp.toString(); // REVISIT. Deal with whitespace diffs in dot-separated names
	    }
	    result.setNameExp(exp);
    }
    [<TERMINATING_WHITESPACE>]
    [ArgsList {args = (ArgsList)peekNode();}]
    {
        if(args == null)
        {
            args = new PositionalArgsList();
        }
        result.setArgs(args);
    }
    [
       <SEMICOLON>[<TERMINATING_WHITESPACE>]
       bodyParameters=ParameterList
       {
           result.setBodyParameters(bodyParameters);
       }
    ]
    (
      end=<EMPTY_DIRECTIVE_END>
      |
      (
        <DIRECTIVE_END>
		nestedBlock=Content
		end=<UNIFIED_CALL_END>
		{
           String s=end.toString().substring(2);;
           if (s.charAt(0) == '@') {
              s = s.substring(1);
           }
	       s = s.substring(0, s.length() -1).trim();
           if (s.length() >0 && !s.equals(directiveName)) {
           String msg = getErrorStart(end);
           if (directiveName == null) {
                throw new ParseException(msg + "\nExpecting </@>", end.getBeginLine(), end.getBeginColumn());
	       }
	       else {
	           throw new ParseException(msg + "\nExpecting </@> or </@" + directiveName + ">", end.getBeginLine(), end.getBeginColumn());
	       }
	    }
	    result.add(nestedBlock);
	  }
      )
    )
    {
       result.setLocation(template, token_source, start, end);
       return result;
    }
;

TemplateElement Call :
{
   Token start, end;
   Identifier id;
   String macroName= null;
   UnifiedCall result = new UnifiedCall();
}
    start=<CALL>
    id=Identifier {result.setNameExp(id);}
    [
	    <OPEN_PAREN>
	]
    ArgsList {result.setArgs((ArgsList) peekNode());}
    [<CLOSE_PAREN>]
    end=LooseDirectiveEnd
    {
       result.setLocation(template, token_source, start, end);
       //args.setLocationInfoIfAbsent(result);
       return result;
    }
;

Map<String, Expression> NamedArgs :
{
    Map<String, Expression> result = new LinkedHashMap<String, Expression>();
    Token t;
    Expression exp;
}
  (
     t=<ID>
     <EQUALS>
     exp=Expression
     {
        if (result.containsKey(t.toString())) {
           throw new ParseException(getErrorStart(t)
              + "\nValue of named parameter '" + t.toString()
              + "' may only be specified once.", t.getBeginLine(), t.getEndLine());
        }
        result.put(t.toString(), exp);
     }
  )+
  {
     return result;
  }
;

TerseComment#Comment :
	<TERSE_COMMENT>
	(
	   <PRINTABLE_CHARS> 
	)*
	<TERSE_COMMENT_END>
;

INJECT Comment :
    import freemarker.core.Environment;
    extends TemplateElement
{
    public String getText() {
      StringBuffer buf = new StringBuffer();
      for (Node n: childrenOfType(PRINTABLE_CHARS)) {
         buf.append(n.toString());
      }
    	return buf.toString();
    }

    public void execute(Environment env) {
    // do nothing, skip the body
    }

    public String getDescription() {
        String s = getText().trim();
        if (s.length() > 20) {
            s = s.substring(0, 20) + "...";
        }
        return "comment (" + s + ")";
    }   
}

NoParseBlock# :
    <NOPARSE>
    (
       <PRINTABLE_CHARS> 
    )*
    <NOPARSE_END>
;

INJECT NoParseBlock : extends freemarker.core.parser.ast.MixedContent

SwitchBlock# :
   <SWITCH>
   Expression
   <DIRECTIVE_END>
   (<WHITESPACE>)*   
   (
     (
      <CASE>
      Expression
      <DIRECTIVE_END>
      Content
     )#CaseBlock
   )*
   [
     (
      <DEFAUL>
      Content
     )#CaseBlock
   ]
   CloseDirectiveBlock("switch")
;

INJECT SwitchBlock : 
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.core.BreakException;
    import freemarker.template.TemplateException;
    import static freemarker.ext.beans.ObjectWrapper.*;
    extends TemplateElement  
{
    public void execute(Environment env) throws IOException {
        boolean foundMatch = false;
        Object testValue = firstChildOfType(Expression.class).evaluate(env);
        try {
            for (CaseBlock cb : childrenOfType(CaseBlock.class)) {
                if (foundMatch) {
                    cb.execute(env);
                }
                else {
                    Expression testExp = cb.getExpression();
                    foundMatch = testExp == null || equals(env, testValue, cb.getExpression().evaluate(env));
                    if (foundMatch) cb.execute(env);
                }
            }
        } catch (BreakException be) {}
    }

    private boolean equals(Environment env, Object first, Object second) {
        if (isNumber(first) && isNumber(second)) {
            return asNumber(first).equals(asNumber(second));
        }
        if (isString(first) && isString(second)) {
            return asString(first).equals(asString(second));
        }
        throw new TemplateException("Can only compare numbers and strings", env);
    }
}

INJECT CaseBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement  
{
    public Expression getExpression() {
        return firstChildOfType(Expression.class);
    }

    public void execute(Environment env) throws IOException {
        env.render(firstChildOfType(TemplateElement.class));
    }

    public String getDescription() {
        return get(0).toString() + " block";
    }
}

EscapeBlock# :
    <ESCAPE>
    <ID>
    <AS>
    Expression
    <DIRECTIVE_END>
    Content
    CloseDirectiveBlock("escape")
;

INJECT EscapeBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    private Expression escapedExpression;

    public Expression getExpression() {
    	return (Expression) get(3);
    }
    
    public String getVariable() {
    	return get(1).toString();
    }
    
    public Expression getEscapedExpression() {
    	return escapedExpression == null ? getExpression() : escapedExpression;
    }
    
    /**
     * This is only used internally.
     */
    public void setEscapedExpression(Expression escapedExpression) {
    	this.escapedExpression = escapedExpression;
    }

    public void setContent(TemplateElement nestedBlock) {
        this.add(nestedBlock);
    }

    public void execute(Environment env) throws TemplateException, IOException {
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class));
        }
    }

    public Expression doEscape(Expression subst) {
        return getEscapedExpression().deepClone(getVariable(), subst);
    }

    public String getDescription() {
        return "escape " + getVariable() + " as " + getEscapedExpression().toString();
    }
}

NoEscapeBlock# :
    <NOESCAPE>
    Content
    CloseDirectiveBlock("noescape")
;

INJECT NoEscapeBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class));
        }
    }

    public String getDescription() {
        return "noescape block";
    }
}


Token CloseDirectiveBlock(String expectedTags) :
{
	Token t;
}
    t=<CLOSE_DIRECTIVE_BLOCK>
	{
		String name = t.toString();
		name = name.substring(3, name.length() -1);
		if (name.length()>0) {
			StringTokenizer st = new StringTokenizer(expectedTags, ", ");
			boolean found = false;
			while (st.hasMoreTokens()) {
				if (st.nextToken().equals(name.trim())) found = true;
			}
			if (!found) {
				throw new ParseException(getErrorStart(t) + " Expecting " + t.toString().substring(0,3) + expectedTags + t.toString().charAt(t.toString().length() -1));
			}
		}
		return t;
	}
;


/**
 * Production to terminate potentially empty elements. Either a ">" or "/>"
 */

Token LooseDirectiveEnd :
{
    Token t;
}
   (
      t=<DIRECTIVE_END>
      |
      t=<EMPTY_DIRECTIVE_END>
   )
   {
      return t;
   }
;

PropertySetting# :
   <SETTING>
   <ID>
   <EQUALS>
   Expression
   LooseDirectiveEnd
;

INJECT PropertySetting :
    import freemarker.core.Environment;
    import static freemarker.ext.beans.ObjectWrapper.*;
    extends TemplateElement
{
    public String getKey() {
    	return firstChildOfType(ID).toString();
    }
    
    public Expression getValue() {
    	return firstChildOfType(Expression.class);
    }

    public void execute(Environment env) {
        Object mval = getValue().evaluate(env);
        String strval;
        if (isString(mval)) {
            strval = asString(mval);
        } else if (isBoolean(mval)) {
            strval = asBoolean(mval) ? "true" : "false";
        } else if (isNumber(mval)) {
            strval = asNumber(mval).toString();
        } else {
            strval = getValue().getStringValue(env);
        }
        env.setSetting(getKey(), strval);
    }

    public String getDescription() {
        return "setting " + getKey() + " set to " + "\"" + getValue() + "\" "
	    + "[" + getStartLocation() + "]";
    }    
}

VarDirective# :
{
    Expression var, valueExp = null;
}
   <VAR>
   (
     var=IdentifierOrStringLiteral
     [
       <EQUALS>
       valueExp=Expression
     ]
   )
   {
      CURRENT_NODE.addVar(var, valueExp);
      valueExp = null;
   }
   (
      (
        [<COMMA>]
        var=IdentifierOrStringLiteral
        [
           <EQUALS>
           valueExp=Expression
        ]
      )
      {
         CURRENT_NODE.addVar(var, valueExp);
         valueExp = null;
      }
   )*
   LooseDirectiveEnd
;

INJECT VarDirective :
   import java.util.*;
   import freemarker.template.*;
   import freemarker.core.*;
   extends TemplateElement
{
    private Map<String, Expression> vars = new LinkedHashMap<String, Expression>();

    public void execute(Environment env) {
        for (Map.Entry<String, Expression> entry : vars.entrySet()) {
            String varname = entry.getKey();
            Expression exp = entry.getValue();
            Scope scope = env.getCurrentScope();
            if (exp == null) {
                if (scope.get(varname) == null) {
                    scope.put(varname, Constants.JAVA_NULL);
                }
            } 
            else {
                Object tm = exp.evaluate(env);
                assertIsDefined(tm, exp, env);
                scope.put(varname, tm);
            }
        }
    }

    public Map<String, Expression> getVariables() {
        return Collections.unmodifiableMap(vars);
    }

    public void addVar(Expression name, Expression value) {
        String varname = name.toString();
        if (name instanceof StringLiteral) {
            varname = ((StringLiteral) name).getAsString();
        }
        vars.put(varname, value);
    }
    
    public void addVar(String name) {
        vars.put(name, null);
    }

    public String getDescription() {
        return "variable declaration";
    }
}

/**
 * A production for FreeMarker directives.
 */
#TemplateElement#abstract :
{
   TemplateElement tp;
}
   (
     tp=IfBlock
     |
     tp=ListBlock
     |
     tp=ForEachBlock
     |
     tp=Assign
     |
     tp=Include
     |
     tp=ImportDeclaration
     |
     tp=Macro
     |
     tp=UnifiedMacroTransform
     |
     tp=Call
     |
     tp=TerseComment
     |
     tp=NoParseBlock
     |
     tp=SwitchBlock
     |
     tp=PropertySetting
     |
     tp=VarDirective
     |
     tp=BreakInstruction
     |
     tp=ReturnInstruction
     |
     tp=StopInstruction
     |
     tp=FlushInstruction
     |
     tp=TrimInstruction
     |
     SCAN 1 \...\Macro =>
     tp=NestedInstruction
     |
     SCAN 1 \...\Macro =>
     tp=FallbackInstruction
     |
     tp=EscapeBlock
     |
     SCAN 1 \...\EscapeBlock =>
     tp=NoEscapeBlock
     |
     tp=Visit
     |
     tp=Recurse
     |
     tp=AttemptBlock
   )
   {
      return tp;
   }
;

INJECT TemplateElement :
   import java.util.*;
   import java.io.IOException;
   import freemarker.core.Environment;
{
    /**
     * Processes the contents of this <tt>TemplateElement</tt> and
     * outputs the resulting text
     *
     * @param env The runtime environment
     */
    abstract public void execute(Environment env) throws IOException;

    // The scoped variables defined in this element.
    private HashSet<String> declaredVariables;

    public Set<String> declaredVariables() {
        return declaredVariables;
    }

    public boolean declaresVariable(String name) {
    	return declaredVariables != null && declaredVariables.contains(name);
    }
    
    public void declareVariable(String varName) {
    	if (declaredVariables == null) declaredVariables = new HashSet<String>();
    	declaredVariables.add(varName);
    }
    
    public boolean isIgnorable() {
        return false;
    }

    public final boolean createsScope() {
    	return declaredVariables != null && !declaredVariables.isEmpty();
    }
}

/**
 * Production for a block of raw text
 * i.e. text that contains no
 * FreeMarker directives.
 */
List<TextBlock> PCData :
{
    StringBuilder buf = new StringBuilder();
    Token start=null;
    List<TextBlock> result = new ArrayList<TextBlock>();
}
    (
      (
         <PRINTABLE_CHARS> 
         |
         <WHITESPACE> 
      )
      {
         popNode();
         buf.append(lastConsumedToken.toString());
         if (start == null) start = lastConsumedToken;
      }
    )+
    {
        return TextBlock.breakIntoBlocks(buf.toString(), template, start.getBeginColumn(), start.getBeginLine());
    }
;

TemplateElement Content#MixedContent(false) :
{
    MixedContent nodes = new MixedContent();
    TemplateElement elem=null;
    List<TextBlock> text;
}
    (
      (
         text=PCData 
         {
            for (TextBlock tb : text) nodes.add(tb);
            for (TextBlock tb : text) pushNode(tb);
         }
         |
         elem=Interpolation {nodes.add(elem);}
         |
         elem=TemplateElement {nodes.add(elem);}
      )
    )*
    {
        clearNodeScope();
        pushNode(nodes);
	    return nodes;
    }
;

INJECT MixedContent :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException 
    {
        for (TemplateElement element : childrenOfType(TemplateElement.class)) {
            env.render(element);
        }
    }

    public String getDescription() {
        if (getParent() == null) {
            return "root element";
        }
        return "content"; // MixedContent is uninteresting in a stack trace.
    }
}


/**
 * A production freemarker text that may contain
 * ${...} but no directives.
 */

TemplateElement FreeMarkerText#MixedContent(false) :
{
     MixedContent nodes = new MixedContent();
     TemplateElement elem = null, begin = null;
     List<TextBlock> text = null;
}
    (
      (
        text=PCData {for (TextBlock tb : text) nodes.add(tb);}
        |
        elem=Interpolation {nodes.add(elem);}
      )
    )+
    {
       return nodes;
    }
;

TemplateHeaderElement HeaderElement : 
{
	Token key, start, end;
	Expression exp;
	Map<String,Expression> params = new LinkedHashMap<String,Expression>();
}
   [<WHITESPACE>]
   (
     start=<TRIVIAL_FTL_HEADER> {end=start;}
     |
     (
       start=<FTL_HEADER>
       (
          key=<ID>
          <EQUALS>
          exp=Expression {params.put(key.toString().toLowerCase(), exp);}
       )*
       end=LooseDirectiveEnd
     )
   )
   {
   	   TemplateHeaderElement header = new TemplateHeaderElement(params);
   	   header.setLocation(template, token_source, start, end);
   	   return header;
   }
;

Map<String,Expression> ParamList :
{
   Identifier id;
   Expression exp;
   Map<String,Expression> result = new HashMap<String,Expression>();
}
   (
      id=Identifier
      <EQUALS>
      exp=Expression {result.put(id.toString(), exp);}
      [<COMMA>]
   )+
   {
       return result;
   }
;


/**
 * Root production to be used when parsing
 * an entire file.
 */
TemplateElement Root :
{
   TemplateHeaderElement header;
   TemplateElement doc;
}
   [
      SCAN [<WHITESPACE>](<TRIVIAL_FTL_HEADER>|<FTL_HEADER>) =>
       header=HeaderElement
       {
       	   template.setHeaderElement(header);
       	   String templateEncoding = template.getEncoding();
       	   if (templateEncoding != null && header.hasParameter("encoding")) {
       	   	  String encoding = null;
       	   	  try {
       	   	     encoding = header.getStringParameter("encoding");
       	   	  } catch (Exception e) {}
       	   	  if (encoding != null && !encoding.equals(templateEncoding)) {
       	   	  	throw new Template.WrongEncodingException(encoding);
       	   	  }
       	   }
       	   if (header.hasParameter("strip_text")) {
       	   	  try {
       	   	  	 this.stripText = header.getBooleanParameter("strip_text");
       	   	  } catch (Exception e) {
       	   	  	throw new ParseException(e.getMessage());
       	   	  }
       	   }
       	   	
       }
   ]
   doc=Content
   <EOF>
   {
       return doc;
   }
   ;