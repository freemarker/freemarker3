// This file defines the various 
// template elements. It is INCLUDEd
// from the main template.

/**
 * A production representing the ${...}
 * that outputs a variable.
 */
Interpolation :
   <OUTPUT_ESCAPE> 
   Expression
   <CLOSE_BRACE>
;

INJECT Interpolation :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    private Expression escapedExpression; // This will be the same as the expression if we are not within an escape block.

    public void setEscapedExpression(Expression escapedExpression) {
    	this.escapedExpression = escapedExpression;
    }
    
    public Expression getEscapedExpression() {
      if (escapedExpression==null) return getExpression();
    	return this.escapedExpression;
    }
    
    public Expression getExpression() {
    	return firstChildOfType(Expression.class);
    }

    /**
     * Outputs the string value of the enclosed expression.
     */
    public void execute(Environment env) throws TemplateException, IOException {
        env.getOut().write(getEscapedExpression().getStringValue(env));
    }

    public String getDescription() {
        return this.getSource()  +
        (escapedExpression == null 
            ? "" 
            : " escaped ${" + escapedExpression.getDescription() + "}");
    }
}

IfBlock :
{Token start;}
  (
    start=<IF>
    Expression
    <DIRECTIVE_END>
    Block
  )#ConditionalBlock
  (
    (
        <ELSE_IF>
        {
            if (start.charAt(0) == '#' && start.charAt(0) == '#' && start.getBeginColumn()!=lastConsumedToken.getBeginColumn()) {
                String message = "Mismatched indentation. The #elseif "
                                 + " should match the indentation of the #if tag on line "
                                 + start.getBeginLine();
                throw new ParseException(message, lastConsumedToken, parsingStack);
            }
        }
        Expression
        <DIRECTIVE_END>
        Block
    )#ConditionalBlock
  )*
  [
    (
        <ELSE>
        {
            if (start.charAt(0) == '#' && start.charAt(0) == '#' && start.getBeginColumn()!=lastConsumedToken.getBeginColumn()) {
                String message = "Mismatched indentation. The #else"
                                 + " should match the indentation of the #if tag on line "
                                 + start.getBeginLine();
                throw new ParseException(message, lastConsumedToken, parsingStack);
            }
        }
        Block
    )#ConditionalBlock
  ]
  CloseDirectiveBlock(start)
;

INJECT IfBlock :
    import java.util.*;
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        for (ConditionalBlock cblock : childrenOfType(ConditionalBlock.class)) {
            Expression condition = cblock.getCondition();
            if (condition == null || condition.isTrue(env)) {
                if (cblock.firstChildOfType(TemplateElement.class) != null) {
                    env.render(cblock);
                }
                return;
            }
        }
    }

    public String getDescription() {
        return "if-else ";
    }
}

INJECT ConditionalBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public Expression getCondition() {
    	return firstChildOfType(Expression.class);
    }
    
    public void execute(Environment env) throws IOException {
        env.render(firstChildOfType(TemplateElement.class));
    }

    public String getDescription() {
        return get(0).toString() + " block";
    }
}

AttemptBlock :
{Token start;}
   start=<_ATTEMPT>
   Block
   <_RECOVER>
   {
        if (start.charAt(0) == '#' && start.charAt(0) == '#' && start.getBeginColumn()!=lastConsumedToken.getBeginColumn()) {
            String message = "Mismatched indentation. The #recover "
                                + " should match the indentation of the #attempt tag on line "
                                + start.getBeginLine();
            throw new ParseException(message, lastConsumedToken, parsingStack);
        }
   }
   Block #RecoveryBlock(2)
   CloseDirectiveBlock(start)
;

INJECT AttemptBlock :
    import java.io.IOException;
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    extends TemplateElement
{
    public TemplateElement getAttemptBlock() {
        return childrenOfType(TemplateElement.class).get(0);
    }
    
    public TemplateElement getRecoverBlock() {
        return childrenOfType(TemplateElement.class).get(1);
    }

    public void execute(Environment env) throws IOException 
    {
        env.render(getAttemptBlock(), getRecoverBlock());
    }

    public String getDescription() {
        return "attempt block";
    }
}

INJECT RecoveryBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.core.variables.*;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException 
    {
    	if (firstChildOfType(TemplateElement.class) != null) {
    		env.render(firstChildOfType(TemplateElement.class));
    	}
    }

    public String getDescription() {
        return "recover block";
    }
}

ListBlock#IteratorBlock :
{Token start;}
   start=<LIST> 
   Expression
   <AS>
   <ID>
   <DIRECTIVE_END>
   Block
   CloseDirectiveBlock(start)
;

ForEachBlock#IteratorBlock :
{Token start;}
   start=<FOREACH> 
   <ID>
   <IN>
   Expression
   <DIRECTIVE_END>
   Block
   CloseDirectiveBlock(start)
;

INJECT IteratorBlock :
    import java.io.IOException;
    import freemarker.core.*;
    import freemarker.core.variables.*;
    extends TemplateElement
{
    public boolean isForeach() {
        return get(0).getType() == FOREACH;
    }

    public String getIndexName() {
        return isForeach() ? get(1).toString() : get(3).toString();
    }
    
    public Expression getListExpression() {
        return isForeach() ? (Expression) get(3) : (Expression) get(1);
    }

    public void execute(Environment env) throws IOException {
        Object baseModel = getListExpression().evaluate(env);
        getListExpression().assertNonNull(baseModel, env);
        env.process(new LoopContext(this, env.getCurrentScope(), baseModel)); // REVISIT
    }

    public String getDescription() {
        return isForeach() ?
            "foreach " + getIndexName() + " in " + getListExpression() 
            :
            "list " + getListExpression() + " as " + getIndexName();
    }
}

VisitNode :
   <VISIT>
   Expression
   [
      <USING>
      Expression
   ]
   LooseDirectiveEnd
;

INJECT VisitNode :
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.Scope;
    import freemarker.core.TemplateNamespace;
    import freemarker.core.variables.*;
    import static freemarker.core.variables.ObjectWrapper.*;
    extends TemplateElement
{
    public Expression getTargetNode() {
    	return (Expression) get(1);
    }
    
    public Expression getNamespaces() {
        if (firstChildOfType(USING) == null) return null;
        return (Expression) get(3);
    }

    public void execute(Environment env) throws IOException {
        Expression targetNode = getTargetNode();
        Expression namespaces = getNamespaces();
        Object node = targetNode.evaluate(env);
        targetNode.assertNonNull(node, env);
        if (!(node instanceof WrappedNode)) {
            throw new TemplateException("Expecting an XML node here", env);
        }
        Object nss = namespaces == null ? null : namespaces.evaluate(env);
        if (namespaces instanceof StringLiteral) {
            nss = env.importLib(asString(nss), null);
        }
        else if (namespaces instanceof ListLiteral) {
            nss = ((ListLiteral) namespaces).evaluateStringsToNamespaces(env);
        }
        if (nss != null) {
            if (nss instanceof TemplateNamespace) {
                List<Scope> ss = new ArrayList<>();
                ss.add((Scope)nss);
                nss = ss;
            }
            else if (!isList(nss)) {
                throw new TemplateException("Expecting a sequence of namespaces after 'using'", env);
            }
        }
        env.render((WrappedNode) node, (List<Scope>)nss);
    }

    public String getDescription() {
        return "visit instruction";
    }
}

RecurseNode# :
    <RECURSE>
    [Expression]
    [
        <USING>
        Expression
    ]
    LooseDirectiveEnd
;

INJECT RecurseNode : 
    import java.io.IOException;
    import java.util.ArrayList;
    import java.util.List;
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.Scope;
    import freemarker.core.variables.*;
    import static freemarker.core.variables.ObjectWrapper.isList;
    import static freemarker.core.variables.ObjectWrapper.asString;
    extends TemplateElement
{
    public Expression getTargetNode() {
        if (get(1) instanceof Expression) {
            return (Expression) get(1);
        }
        return null;
    }
    
    public Expression getNamespaces() {
        Node using = firstChildOfType(USING);
        return using == null ? null : (Expression) using.nextSibling();
    }

    public void execute(Environment env) throws IOException {
        Expression targetNode = getTargetNode();
        Expression namespaces = getNamespaces();
        Object node = targetNode == null ? null : targetNode.evaluate(env);
        Object nss = namespaces == null ? null : namespaces.evaluate(env);
        if (namespaces instanceof StringLiteral) {
                nss = env.importLib(asString(nss), null);
        }
        else if (namespaces instanceof ListLiteral) {
            nss = ((ListLiteral) namespaces).evaluateStringsToNamespaces(env);
        }
        if (node != null && !(node instanceof WrappedNode)) {
            throw new TemplateException("Expecting an XML node here, for expression: " + targetNode + ", found a: " + node.getClass().getName(), env);
        }
        if (nss != null) {
            if (nss instanceof Scope) {
                List<Scope> ss = new ArrayList<>();
                ss.add((Scope)nss);
                nss = ss;
            }
            else if (!isList(nss)) {
                throw new TemplateException("Expecting a sequence of namespaces after 'using'", env);
            }
        }
        env.process((WrappedNode) node, (List<Scope>)nss);
    }

    public String getDescription() {
        return "recurse instruction";
    }
}

FallbackInstruction# :
   <FALLBACK>
;

INJECT FallbackInstruction :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement;
{
    public void execute(Environment env) throws IOException {
        env.fallback();
    }

    public String getDescription() {
        return "fallback instruction";
    }
}

/**
 * Production used to break out of a loop or a switch block.
 */
BreakInstruction# :
    <BREAK>
;

INJECT BreakInstruction :
    import freemarker.core.Environment;
    import freemarker.core.BreakException;
    extends TemplateElement
{
    public void execute(Environment env) {
        throw BreakException.INSTANCE;
    }

    public String getDescription() {
        return "break" + " [" + getLocation() + "]";
    }
}

/**
 * Production used to jump out of a macro.
 */
ReturnInstruction# :
   <RETURN> [Expression] LooseDirectiveEnd
;

INJECT ReturnInstruction :
    import freemarker.core.Environment;
    import freemarker.core.ReturnException;
    extends TemplateElement
{
    public Object getReturnValue(Environment env) {
        if (!(get(1) instanceof Expression)) return null;
        return ((Expression)get(1)).evaluate(env);
    }
    
    public void execute(Environment env) {
        env.setLastReturnValue(getReturnValue(env));
        if (nextSibling() != null) {
            // We need to jump out using an exception.
            throw ReturnException.INSTANCE;
        }
        if (!(getParent() instanceof Macro || getParent().getParent() instanceof Macro)) {
            // Here also, we need to jump out using an exception.
            throw ReturnException.INSTANCE;
        }
    }

    public String getDescription() {
        return "return" + " [" + getLocation() + "]";
    }
}

StopInstruction# :
   <STOP> [Expression] LooseDirectiveEnd
;

INJECT StopInstruction :
   import freemarker.core.Environment;
   import freemarker.core.StopException;
   extends TemplateElement
{
   public String getMessage(Environment env) {
      return get(1) instanceof Expression ? 
             ((Expression)get(1)).getStringValue(env) 
             : "";
   }

    public void execute(Environment env) {
        throw new StopException(env, getMessage(env));
    }

    public String getDescription() {
        return "stop" + " [" + getLocation() + "]";
    }
}

NestedInstruction# :
    <NESTED>
    [PositionalArgsList]
    LooseDirectiveEnd
;

INJECT NestedInstruction :
    import java.io.IOException;
    import freemarker.core.*;
    import freemarker.core.variables.*;
    extends TemplateElement
{
    public ArgsList getArgs() {
    	return firstChildOfType(ArgsList.class);
    }
    
    /**
     * There is actually a subtle but essential point in the code below.
     * A macro operates in the context in which it is defined. However, 
     * a nested block within a macro instruction is defined in the 
     * context in which the macro was invoked. So, we actually need to
     * temporarily switch the namespace and macro context back to
     * what it was before macro invocation to implement this properly.
     * I (JR) realized this thanks to some incisive comments from Daniel Dekany.
     */
    public void execute(Environment env) throws IOException {
        MacroInvocationBodyContext bodyContext = new MacroInvocationBodyContext(env, (PositionalArgsList) getArgs());
        env.render(bodyContext);
    }

    public String getDescription() {
        return "nested macro content";
    }
}

FlushInstruction# :
   <FLUSH>
;

INJECT FlushInstruction :
   import java.io.IOException;
   import freemarker.core.Environment;
   extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        env.getOut().flush();
    }

    public String getDescription() {
        return "flush instruction";
    }
}

TrimInstruction# : <TRIM>|<LTRIM>|<RTRIM>;

INJECT TrimInstruction :
   import freemarker.core.Environment;
   extends TemplateElement
{
    public boolean isLeft() {
    	return get(0).getType() != RTRIM;
    }
    
    public boolean isRight() {
    	return get(0).getType() != LTRIM;
    }

    public void execute(Environment env) {
        // This instruction does nothing at render-time, only parse-time.
    }

    public String getDescription() {
        String type = "";
        if (!isRight()) type = "left ";
        if (!isLeft()) type = "right ";
        return type + "trim instruction";
    }

    public boolean isIgnorable() {
        return true;
    }
}

BlockAssignment :
{
   String assignmentType = "set";
   Token start;
}
   (
    <ASSIGN>{assignmentType = "assign";}
    |
    <GLOBALASSIGN>{assignmentType="global";}
    |
    <LOCALASSIGN>{assignmentType="local";}
    |
    <SET>
   )
   {start = lastConsumedToken;}
   IdentifierOrStringLiteral
   [ 
      <IN>
      Expression
   ]
   <DIRECTIVE_END> =>||
   Block
   CloseDirectiveBlock(start)   
;

INJECT BlockAssignment :
    import java.io.IOException;
    import java.io.StringWriter;
    import java.io.Writer;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.core.Scope;
    import freemarker.core.variables.UserDirectiveBody;
    import freemarker.core.variables.UserDirective;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    public String getVarName() {
        if (get(1) instanceof StringLiteral) {
            return ((StringLiteral)get(1)).getAsString();
        }
        return get(1).toString();
    }

    public Expression getNamespaceExp() {
        Node inToken = firstChildOfType(IN);
        if (inToken != null) {
            return (Expression) inToken.nextSibling();
        }
        return null;
    }

    public void execute(Environment env) throws IOException {
    	Scope scope = null;
        Expression namespaceExp = getNamespaceExp();
    	if (namespaceExp != null) {
    		try {
    			scope = (Scope) namespaceExp.evaluate(env); 
    		} catch (ClassCastException cce) {
                throw new InvalidReferenceException(getLocation() + "\nInvalid reference to namespace: " + namespaceExp, env);
    		}
    	}
    	else {
    		if (get(0).getType() == ASSIGN) {
    			scope = env.getCurrentNamespace();
    		} else if (get(0).getType() == LOCALASSIGN) {
    			scope = env.getCurrentMacroContext();
    		} else if (get(0).getType() == GLOBALASSIGN) {
    			scope = env.getGlobalNamespace();
    		} 
    	}
    	CaptureOutput filter = new CaptureOutput();
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class), filter, null, null);
        }
        String text = filter.capturedText;
    	if (scope != null) {
    		scope.put(getVarName(), text);
    	} else {
    		env.unqualifiedSet(getVarName(), text);
    	}
    }
    
    private static class CaptureOutput implements UserDirective {
        String capturedText = ""; 

        public void execute(Environment env, Map<String, Object> args, Object[] bodyVars, UserDirectiveBody body) throws IOException {
        	body.render(getWriter(env.getOut(), args));
        }

        public Writer getWriter(Writer out, Map<String, Object> args) {
            return new StringWriter() {
                public void flush() {
                	capturedText = this.toString();
                }
            };
        }
    }
    
    public String getDescription() {
        return "block assignment to variable: " + getVarName();
    }
}

AssignmentInstruction :
   (<ASSIGN>|<GLOBALASSIGN>|<LOCALASSIGN>|<SET>)
   IdentifierOrStringLiteral
   <EQUALS> =>||
   Expression
   (
     [<COMMA>]
     IdentifierOrStringLiteral
     <EQUALS>
     Expression
   )*
   [
      <IN>
      Expression     
   ]
   LooseDirectiveEnd
;

INJECT AssignmentInstruction :
    import java.io.IOException;
    import java.util.*;
    import freemarker.template.TemplateException;
    import freemarker.core.*;
    extends TemplateElement
{
    public List<String> getVarNames() {
        List<String> result = new ArrayList<>();
        List<Node> equalsToks = childrenOfType(EQUALS);
        for (Node tok : equalsToks) {
            Node varExp = tok.previousSibling();
            if (varExp instanceof StringLiteral) {
                result.add(((StringLiteral)varExp).getAsString());
            }
            else {
                result.add(varExp.toString());
            }
        }
        return result;
    }

    public List<Expression> getValues() {
        List<Expression> result = new ArrayList<>();
        List<Node> equalsToks = childrenOfType(EQUALS);
        for (Node tok : equalsToks) {
            result.add((Expression)tok.nextSibling());
        }
        return result;
    }
    
    public Expression getNamespaceExp() {
        Node inToken = firstChildOfType(IN);
        if (inToken != null) {
            return (Expression) inToken.nextSibling();
        }
        return null;
    }

    public void execute(Environment env) throws TemplateException, IOException {
    	Scope scope = null;
        Expression namespaceExp = getNamespaceExp();
    	if (namespaceExp != null) {
    		try {
    			scope = (Scope) namespaceExp.evaluate(env); 
    		} catch (ClassCastException cce) {
                throw new InvalidReferenceException(getLocation() + "\nInvalid reference to namespace: " + namespaceExp, env);
    		}
    	}
    	else {
    		if (get(0).getType() == ASSIGN) {
    			scope = env.getCurrentNamespace();
    		} else if (get(0).getType() == LOCALASSIGN) {
    			scope = env.getCurrentMacroContext();
    		} else if (get(0).getType() == GLOBALASSIGN) {
    			scope = env.getGlobalNamespace();
    		}
    	}
        List<String> varNames = getVarNames();
        List<Expression> values = getValues();
    	for (int i=0; i< varNames.size(); i++) {
    		String varname = varNames.get(i);
    		Expression valueExp = values.get(i);
    		Object value = valueExp.evaluate(env);
    		valueExp.assertIsDefined(value, env);
    		if (scope != null) {
    			scope.put(varname, value);
    		} else {
    			env.unqualifiedSet(varname, value);
    		}
    	}
    }
    
    public String getDescription() {
    	return "assignment instruction";
    }
}

IncludeInstruction :
{
    CURRENT_NODE.setTemplate(template);
}
   (<_INCLUDE>|<EMBED>)
   Expression
   (
    <ID><EQUALS>Expression
   )*
   LooseDirectiveEnd
;

INJECT IncludeInstruction :
    import java.io.IOException;
    import java.io.IOException;
    import freemarker.cache.TemplateCache;
    import freemarker.template.*;
    import freemarker.template.utility.StringUtil;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.core.parser.ParseException;
    import static freemarker.core.variables.ObjectWrapper.*;
    extends TemplateElement
{
    @Property Template template;

    public boolean useFreshNamespace() {
        return get(0).getType() == EMBED;
    }

    public Expression getParamByName(String name) {
        for (Node n : this) {
            if (n instanceof Identifier && n.toString().equalsIgnoreCase(name)) {
                return (Expression) n.nextSibling().nextSibling();
            }
        }
        return null;
    }

    public void execute(Environment env) throws IOException {
        String templateNameString = ((Expression) get(1)).getStringValue(env);
        if( templateNameString == null ) {
            String msg = "Error " + getLocation()
                        + "The expression " + get(1)  + " is undefined.";
            throw new InvalidReferenceException(msg, env);
        }
        String encoding = null;
        Expression encodingExp = getParamByName("encoding");
        if (encodingExp!=null) {
            encoding = encodingExp.getStringValue(env);
        }
        boolean parse = true;
        Expression parseExp = getParamByName("parse");
        if (parseExp != null) {
            Object tm = parseExp.evaluate(env);
            parseExp.assertNonNull(tm, env);
            if (isString(tm)) {
                parse = StringUtil.getYesNo(asString(tm));
            }
            else {
                parse = parseExp.isTrue(env);
            }
        }
        Template includedTemplate;
        String templatePath = "";
    	if (template != null) {
    		String templatePath1 = template.getName();
    		int lastSlash = templatePath1.lastIndexOf('/');
    		templatePath = lastSlash == -1 ? "" : templatePath1.substring(0, lastSlash + 1);
    	}
        try {
            //REVISIT
            templateNameString = TemplateCache.getFullTemplatePath(env, templatePath, templateNameString);
            includedTemplate = env.getTemplateForInclusion(templateNameString, encoding, parse);
        }
        catch (ParseException pe) {
            String msg = "Error parsing included template "
                        + templateNameString + "\n" + pe.getMessage();
            throw new TemplateException(msg, pe, env);
        }
        catch (IOException ioe) {
            String msg = "Error reading included file "
                        + templateNameString;
            throw new TemplateException(msg, ioe, env);
        }
        env.include(includedTemplate, useFreshNamespace());
    }
}

ImportDeclaration :
   <IMPORT>
   Expression
   <AS>
   <ID>
   LooseDirectiveEnd
   {
       CURRENT_NODE.setTemplate(template);
   }
;

INJECT ImportDeclaration :
    import java.io.IOException;
    import freemarker.template.Template;
    import freemarker.template.TemplateException;
    import freemarker.core.Environment;
    import freemarker.core.InvalidReferenceException;
    import freemarker.log.Logger;
    extends TemplateElement
{
    private String templatePath="";
    @Property Template template;

    public String getNamespace() {
    	return get(3).toString();
    }
    
    public Expression getTemplateNameExpression() {
    	return (Expression) get(1);
    }

    public void execute(Environment env) throws IOException {
        String templateNameString = getTemplateNameExpression().getStringValue(env);
        if( templateNameString == null ) {
            String msg = "Error " + getLocation()
                        + "The expression " + getTemplateNameExpression() + " is undefined.";
            throw new InvalidReferenceException(msg, env);
        }
        Template importedTemplate;
        try {
            if (templateNameString.indexOf("://") >0) {
                ;
            }
            else if(templateNameString.length() > 0 && templateNameString.charAt(0) == '/')  {
                int protIndex = templatePath.indexOf("://");
                if (protIndex >0) {
                    templateNameString = templatePath.substring(0, protIndex + 2) + templateNameString;
                } else {
                    templateNameString = templateNameString.substring(1);
                }
            }
            else {
                templateNameString = templatePath + templateNameString;
            }
            importedTemplate = env.getTemplateForImporting(templateNameString);
        }
        catch (ParseException pe) {
            String msg = "Error parsing imported template "
                        + templateNameString;
            Logger.getLogger("freemarker.runtime").error(msg, pe);
            throw new TemplateException(msg, pe, env);
        }
        catch (IOException ioe) {
            String msg = "Error reading imported file "
                        + templateNameString;
            throw new TemplateException(msg, ioe, env);
        }
        env.importLib(importedTemplate, getNamespace(), false);
    }

    public String getDescription() {
        return "import " + getTemplateNameExpression() + " as " + getNamespace();
    }

    public String getTemplateName() {
        return getTemplateNameExpression().toString();
    }    

    public void close() {
        if (template != null) {
        	String templatePath1 = template.getName();
        	int lastSlash = templatePath1.lastIndexOf('/');
        	templatePath = lastSlash == -1 ? "" : templatePath1.substring(0, lastSlash + 1);
            template.addImport(this);
        }
    }
}

#ParameterList#freemarker.core.nodes.ParameterList(true) :
{
	Token arg=null, firstArg=null, ellipsis = null;
	Expression defValue = null;
	String catchAll = null;
	boolean isCatchAll = false, hasDefaults = false;
	Set<String> paramNames = new HashSet<String>();
}
    (
          arg=<ID> 
          {
          	if (firstArg == null) firstArg = arg;
          	defValue = null;
          	if (paramNames.contains(arg.toString())) {
          		throw new ParseException(getErrorStart(arg) + "\nThe parameter " + arg.toString() + " cannot be repeated.");
          	}
          	paramNames.add(arg.toString());
          }
          [
             ellipsis=<ELLIPSIS> { isCatchAll = true; }
          ]
          [
            <EQUALS>
          	defValue=Expression
            {
		      hasDefaults = true;
            }
          ]
          [<COMMA>]
	  {
          if (catchAll != null) {
              throw new ParseException(getErrorStart(arg)
                + "\nThere may only be one \"catch-all\" parameter in a macro declaration, "
                + "and it must be the last parameter.", arg.getBeginLine(), arg.getEndLine());
          }
          if (isCatchAll) {
              if (defValue != null) {
                  throw new ParseException(getErrorStart(arg)
                    + "\n\"Catch-all\" macro parameter may not have a default value.",
                    arg.getBeginLine(), arg.getEndLine());
              }
              CURRENT_NODE.setCatchAll(arg.toString());
          } 
          else if (defValue == null) {
             if (hasDefaults) {
                  throw new ParseException(getErrorStart(arg)
                    + "\nIn a macro declaration, parameters without a default value "
                    + "must all occur before the parameters with default values.",
                    arg.getBeginLine(), arg.getEndLine());
             }
          	 CURRENT_NODE.addParam(arg.toString());
          }
          else {
              CURRENT_NODE.addParam(arg.toString(), defValue);
          	  hasDefaults = true;
          }
	  }
    )*
	{
		return CURRENT_NODE;
	}
;


Macro :
 { Token start; }
    start=<_MACRO>
    IdentifierOrStringLiteral
    [<OPEN_PAREN>]
    ParameterList
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    Block
    CloseDirectiveBlock(start)
;

Function#Macro :
{ Token start; }
    start=<FUNCTION>
    IdentifierOrStringLiteral
    [<OPEN_PAREN>]
    ParameterList
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    Block
    CloseDirectiveBlock(start)
;

INJECT Macro :
    import freemarker.template.*;
    import freemarker.core.Environment;
    import freemarker.core.nodes.ParameterList;
    import freemarker.core.variables.WrappedVariable;
    extends TemplateElement implements WrappedVariable
{
    static public final Macro DO_NOTHING_MACRO = new Macro();
    static {
    	DO_NOTHING_MACRO.add(new Block());
    }

    public boolean isFunction() {
    	return get(0).getType() == FUNCTION;
    }

    public String getName() {
        if (this == DO_NOTHING_MACRO) {
            return ".pass";
        }
        if (get(1) instanceof Identifier) {
            return get(1).toString();
        }
        return ((StringLiteral) get(1)).getAsString();
    }

    public ParameterList getParams() {
        return firstChildOfType(ParameterList.class);
    }

    public void close() {
    	ParameterList params = getParams();
    	for (String paramName : params.getParams()) {
    		declareVariable(paramName);
    	}
    	String catchallVar = params.getCatchAll();
    	if (catchallVar != null) {
    		declareVariable(catchallVar);
    	}
    }

    public void execute(Environment env) {
        env.visitMacroDef(this);
    }

    public String getDescription() {
        return (isFunction() ? "function " : "macro ") + getName();
    }
}

UnifiedCall :
   <UNIFIED_CALL>
   PrimaryExpression(true)
   [ArgsList]
   [
       <SEMICOLON>
       ParameterList
   ] 
   (
      <EMPTY_DIRECTIVE_END>
      |
      <DIRECTIVE_END>
      Block
      <UNIFIED_CALL_END>      
   )  
;

INJECT UnifiedCall :
    import java.io.IOException;
    import java.util.*;
    import freemarker.core.Environment;
    import freemarker.core.nodes.ParameterList;
    import freemarker.core.variables.UserDirective;
    import freemarker.template.TemplateException;
    extends TemplateElement
{
    public Expression getNameExp() {
        return (Expression) get(1);
    }

    public ArgsList getArgs() {
        ArgsList result = firstChildOfType(ArgsList.class);
        if (result == null) result = new PositionalArgsList();
        return result;
    }

    public ParameterList getBodyParameters() {
        return firstChildOfType(ParameterList.class);
    }

    public void close() {
    	ParameterList bodyParameters = getBodyParameters();
    	if (bodyParameters != null) {
    		for (String paramName : bodyParameters.getParams()) {
    			declareVariable(paramName);
    		}
    		String catchallParam = bodyParameters.getCatchAll();
    		if (catchallParam != null) {
    			declareVariable(catchallParam);
    		}
    	}
    }

    public void execute(Environment env) throws IOException {
        Expression nameExp = getNameExp();
        Object tm = nameExp.evaluate(env);
        ArgsList args = getArgs();
        ParameterList bodyParameters = getBodyParameters();
        if (tm == Macro.DO_NOTHING_MACRO) return; // shortcut here.
        if (tm instanceof Macro) {
            Macro macro = (Macro) tm;
            if (macro.isFunction()) {
                throw new TemplateException("Routine " + macro.getName() 
                        + " is a function. A function can only be called " +
                        "within the evaluation of an expression.", env);
            }    
            env.render(macro, args, bodyParameters, firstChildOfType(TemplateElement.class));
        }
        else if (tm instanceof UserDirective) {
            Map<String, Object> argMap
                    = args != null
                            ? args.getParameterMap(tm, env)
                            : new HashMap<String, Object>();
            List<String> paramNames;
            if(bodyParameters == null) {
                paramNames = Collections.emptyList();
            }
            else {
                paramNames = bodyParameters.getParamNames();
            }
            env.render(firstChildOfType(TemplateElement.class), (UserDirective) tm, argMap, paramNames);
        }
        else {
            nameExp.assertNonNull(tm, env);
            throw new TemplateException(getLocation() + ": " + getNameExp() + 
                    " is not a user-defined directive.", env);
        }
    }
    
    public String getDescription() {
        return "user-directive " + getNameExp();
    }
}

Map<String, Expression> NamedArgs#void :
{
    Map<String, Expression> result = new LinkedHashMap<String, Expression>();
    Token t;
    Expression exp;
}
  (
     t=<ID>
     <EQUALS>
     exp=Expression
     {
        if (result.containsKey(t.toString())) {
           throw new ParseException(getErrorStart(t)
              + "\nValue of named parameter '" + t.toString()
              + "' may only be specified once.", t.getBeginLine(), t.getEndLine());
        }
        result.put(t.toString(), exp);
     }
  )+
  {
     return result;
  }
;

NoParseBlock# :
    <NOPARSE>
;

INJECT NoParseBlock : 
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        String source = getSource();
        for (int i = 0; i < source.length(); i++) {
            if (source.charAt(i) == '>' || source.charAt(i) == ']') {
                source = source.substring(i + 1);
                break;
            }
        }
        for (int i = source.length()-1; i>=0; i--) {
            if (source.charAt(i) == '<' || source.charAt(i) == '[') {
                source = source.substring(0, i);
                break;
            }
        }
        env.getOut().write(source);
    }
}    

SwitchBlock :
{ Token start, caseTok=null; }
   start=<SWITCH>
   Expression
   <DIRECTIVE_END>
   [IgnorableWhitespace]
   (
     (
      <CASE>
      {
         if (lastConsumedToken.charAt(0) == '#' && start.charAt(0) == '#') {
            if (lastConsumedToken.getBeginColumn() <= start.getBeginColumn()) {
                String message = "Indentation issue. The #case on line " 
                + lastConsumedToken.getBeginLine() + " should be offset from the #switch "
                + "on line " + start.getBeginLine() + ".";
                throw new ParseException(message, lastConsumedToken, parsingStack);
            }
            if (caseTok != null && caseTok.getBeginColumn() != lastConsumedToken.getBeginColumn()) {
                String message = "Indentation issue. The #case on line " 
                + lastConsumedToken.getBeginLine() + " should be indented the same as the #case "
                + "on line " + caseTok.getBeginLine() + ".";
                throw new ParseException(message, lastConsumedToken, parsingStack);
            }
            caseTok = lastConsumedToken;
         }
      }
      Expression
      <DIRECTIVE_END>
      Block
     )#CaseBlock
   )*
   [
     (
      <DEFAUL>
      {
         if (lastConsumedToken.charAt(0) == '#' && start.charAt(0) == '#') {
            if (lastConsumedToken.getBeginColumn() <= start.getBeginColumn()) {
                String message = "Indentation issue. The #default on line " 
                + lastConsumedToken.getBeginLine() + " should be offset from the #switch "
                + "on line " + start.getBeginLine() + ".";
                throw new ParseException(message, lastConsumedToken, parsingStack);
            }
            if (caseTok != null && caseTok.getBeginColumn() != lastConsumedToken.getBeginColumn()) {
                String message = "Indentation issue. The #default on line " 
                + lastConsumedToken.getBeginLine() + " should be indented the same as the #case "
                + "on line " + caseTok.getBeginLine() + ".";
                throw new ParseException(message, lastConsumedToken, parsingStack);
            }
            caseTok = lastConsumedToken;
         }
      }
      Block
     )#CaseBlock
   ]
   CloseDirectiveBlock(start)
;

INJECT SwitchBlock : 
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.core.BreakException;
    import freemarker.template.TemplateException;
    import static freemarker.core.variables.ObjectWrapper.*;
    extends TemplateElement  
{
    public void execute(Environment env) throws IOException {
        boolean foundMatch = false;
        Object testValue = firstChildOfType(Expression.class).evaluate(env);
        try {
            for (CaseBlock cb : childrenOfType(CaseBlock.class)) {
                if (foundMatch) {
                    cb.execute(env);
                }
                else {
                    Expression testExp = cb.getExpression();
                    foundMatch = testExp == null || equals(env, testValue, cb.getExpression().evaluate(env));
                    if (foundMatch) cb.execute(env);
                }
            }
        } catch (BreakException be) {}
    }

    private boolean equals(Environment env, Object first, Object second) {
        if (isNumber(first) && isNumber(second)) {
            return asNumber(first).equals(asNumber(second));
        }
        if (isString(first) && isString(second)) {
            return asString(first).equals(asString(second));
        }
        throw new TemplateException("Can only compare numbers and strings", env);
    }
}

INJECT CaseBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement  
{
    public Expression getExpression() {
        return firstChildOfType(Expression.class);
    }

    public void execute(Environment env) throws IOException {
        env.render(firstChildOfType(TemplateElement.class));
    }

    public String getDescription() {
        return get(0).toString() + " block";
    }
}

EscapeBlock :
{ Token start; }
    start=<ESCAPE>
    <ID>
    <AS>
    Expression
    <DIRECTIVE_END>
    Block
    CloseDirectiveBlock(start)
;

INJECT EscapeBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    import freemarker.template.*;
    extends TemplateElement
{
    private Expression escapedExpression;

    public Expression getExpression() {
    	return (Expression) get(3);
    }
    
    public String getVariable() {
    	return get(1).toString();
    }
    
    public Expression getEscapedExpression() {
    	return escapedExpression == null ? getExpression() : escapedExpression;
    }
    
    /**
     * This is only used internally.
     */
    public void setEscapedExpression(Expression escapedExpression) {
    	this.escapedExpression = escapedExpression;
    }

    public void setContent(TemplateElement nestedBlock) {
        this.add(nestedBlock);
    }

    public void execute(Environment env) throws TemplateException, IOException {
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class));
        }
    }

    public Expression doEscape(Expression subst) {
        return getEscapedExpression().deepClone(getVariable(), subst);
    }

    public String getDescription() {
        return "escape " + getVariable() + " as " + getEscapedExpression();
    }
}

NoEscapeBlock :
{ Token start; }
    start=<NOESCAPE>
    Block
    CloseDirectiveBlock(start)
;

INJECT NoEscapeBlock :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException {
        if (firstChildOfType(TemplateElement.class) != null) {
            env.render(firstChildOfType(TemplateElement.class));
        }
    }

    public String getDescription() {
        return "noescape block";
    }
}


CloseDirectiveBlock(Token startToken)#void :
    <CLOSE_DIRECTIVE_BLOCK>
	{
        String nameAtEnd = stripNonLetter(lastConsumedToken.toString());
        String nameAtStart = stripNonLetter(startToken.toString());
        if (nameAtEnd.length() > 0) {
            if (!nameAtStart.equals(nameAtEnd)) {
                if (!(nameAtStart.equals("attempt") && nameAtEnd.equals("recover"))) {
                    String message = "Was expecting the closing tag /#" 
                                     + nameAtStart 
                                     + " to close the block starting on line " 
                                     + startToken.getBeginLine()
                                     + " but found /#" + nameAtEnd;
                    throw new ParseException(message, lastConsumedToken, parsingStack);
                }
            }
        }
        if (startToken.charAt(0) == '#' 
             && lastConsumedToken.charAt(0) == '/' 
             && startToken.getBeginColumn() != lastConsumedToken.getBeginColumn()) 
        {
            String message = "Mismatched indentation. The closing tag /#" + nameAtEnd
                             + " should match the indentation of the starting tag on line "
                             + startToken.getBeginLine();
            throw new ParseException(message, lastConsumedToken, parsingStack);
        }
	}
    |
    FAIL "Expecting closing tag for "+startToken + " block beginning at " + startToken.getLocation()
;

INJECT PARSER_CLASS :
{
    static String stripNonLetter(String s) {
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (Character.isLetter(s.charAt(i))) {
                buf.append(s.charAt(i));
            }
        }
        return buf.toString();
    }
}


/**
 * Production to terminate potentially empty elements. Either a ">" or "/>"
 */

Token LooseDirectiveEnd#void :
{
    Token t;
}
   (
      t=<DIRECTIVE_END>
      |
      t=<EMPTY_DIRECTIVE_END>
   )
   {
      return t;
   }
;

PropertySetting :
   <SETTING>
   <ID>
   <EQUALS>
   Expression
   LooseDirectiveEnd
;

INJECT PropertySetting :
    import freemarker.core.Environment;
    import static freemarker.core.variables.ObjectWrapper.*;
    extends TemplateElement
{
    public String getKey() {
    	return firstChildOfType(ID).toString();
    }
    
    public Expression getValue() {
    	return (Expression) get(3);
    }

    public void execute(Environment env) {
        Object mval = getValue().evaluate(env);
        String strval;
        if (isString(mval)) {
            strval = asString(mval);
        } else if (isBoolean(mval)) {
            strval = asBoolean(mval) ? "true" : "false";
        } else if (isNumber(mval)) {
            strval = asNumber(mval).toString();
        } else {
            strval = getValue().getStringValue(env);
        }
        env.setSetting(getKey(), strval);
    }

    public String getDescription() {
        return "setting " + getKey() + " set to " + "\"" + getValue() + "\" "
	    + "[" + getLocation() + "]";
    }    
}

VarDirective :
{
    Expression var, valueExp = null;
}
   <VAR>
   (
     var=IdentifierOrStringLiteral
     [
       <EQUALS>
       valueExp=Expression
     ]
   )
   {
      CURRENT_NODE.addVar(var, valueExp);
      valueExp = null;
   }
   (
      (
        [<COMMA>]
        var=IdentifierOrStringLiteral
        [
           <EQUALS>
           valueExp=Expression
        ]
      )
      {
         CURRENT_NODE.addVar(var, valueExp);
         valueExp = null;
      }
   )*
   LooseDirectiveEnd
;

INJECT VarDirective :
   import java.util.*;
   import freemarker.template.*;
   import freemarker.core.*;
   import static freemarker.core.variables.Constants.JAVA_NULL;
   extends TemplateElement
{
    private Map<String, Expression> vars = new LinkedHashMap<String, Expression>();

    public void execute(Environment env) {
        for (Map.Entry<String, Expression> entry : vars.entrySet()) {
            String varname = entry.getKey();
            Expression exp = entry.getValue();
            Scope scope = env.getCurrentScope();
            if (exp == null) {
                if (scope.get(varname) == null) {
                    scope.put(varname, JAVA_NULL);
                }
            } 
            else {
                Object tm = exp.evaluate(env);
                exp.assertIsDefined(tm, env);
                scope.put(varname, tm);
            }
        }
    }

    public Map<String, Expression> getVariables() {
        return Collections.unmodifiableMap(vars);
    }

    public void addVar(Expression name, Expression value) {
        String varname = name.toString();
        if (name instanceof StringLiteral) {
            varname = ((StringLiteral) name).getAsString();
        }
        vars.put(varname, value);
    }
    
    public void addVar(String name) {
        vars.put(name, null);
    }

    public String getDescription() {
        return "variable declaration";
    }
}

/**
 * A production for FreeMarker directives.
 */
TemplateElement#abstract :
   IfBlock
   |
   ListBlock
   |
   ForEachBlock
   |
   AssignmentInstruction
   |
   BlockAssignment
   |
   IncludeInstruction
   |
   ImportDeclaration
   |
   Macro
   |
   Function
   |
   UnifiedCall
   |
   NoParseBlock
   |
   SwitchBlock
   |
   PropertySetting
   |
   VarDirective
   |
   BreakInstruction
   |
   ReturnInstruction
   |
   StopInstruction
   |
   FlushInstruction
   |
   TrimInstruction
   |
   VisitNode
   |
   RecurseNode
   |
   AttemptBlock
   |
   EscapeBlock
   |
   SCAN 1 \...\EscapeBlock =>
   NoEscapeBlock
   |
   SCAN 1 \...\Macro =>
   NestedInstruction
   |
   SCAN 1 \...\Macro =>
   FallbackInstruction
;

INJECT TemplateElement :
   import java.util.*;
   import java.io.IOException;
   import freemarker.core.Environment;
{
    /**
     * Processes the contents of this <tt>TemplateElement</tt> and
     * outputs the resulting text
     *
     * @param env The runtime environment
     */
    abstract public void execute(Environment env) throws IOException;

    // The scoped variables defined in this element.
    private HashSet<String> declaredVariables;

    public boolean declaresVariable(String name) {
    	return declaredVariables != null && declaredVariables.contains(name);
    }
    
    public void declareVariable(String varName) {
    	if (declaredVariables == null) declaredVariables = new HashSet<String>();
    	declaredVariables.add(varName);
    }
    
    public boolean isIgnorable() {
        return false;
    }

    public final boolean createsScope() {
    	return declaredVariables != null && !declaredVariables.isEmpty();
    }
}

TextElement# :
{Token start=null;}
   (
      <TRAILING_WHITESPACE>
      |
      <NON_TRAILING_WHITESPACE>
      |
      <PROBLEMATIC_CHAR>
      |
      <POSSIBLE_DIRECTIVE>
      |
      <POSSIBLE_END_DIRECTIVE>
      |
      <REGULAR_PRINTABLE>
   )+
;

INJECT TextElement :
   import java.io.IOException;
   import freemarker.core.Environment;
   import freemarker.core.nodes.Whitespace;
   extends TemplateElement
{
    private String outputText;

    private String getOutputText() {
        if (outputText != null) {
            return outputText;
        }
        if (firstChildOfType(Printable.class) == null 
            && ignoresSandwichedWhitespace(previousSibling()) 
            && ignoresSandwichedWhitespace(nextSibling())) 
        {
            return outputText = "";
        }
        StringBuilder buf = new StringBuilder();
        for (Node n : this) {
            if (!(n instanceof Whitespace) || !((Whitespace) n).isIgnored()) {
                buf.append(n.toString());
            }
        }
        return outputText = buf.toString();
    }

    public void execute(Environment env) throws IOException {
        env.getOut().write(getOutputText());
 	}

	private boolean ignoresSandwichedWhitespace(Node elem) {
		return    (elem instanceof Macro) 
		       || (elem instanceof AssignmentInstruction) 
		       || (elem instanceof BlockAssignment) 
		       || (elem instanceof VarDirective)
		       || (elem instanceof ImportDeclaration)
		       || (elem instanceof PropertySetting);
 	}
}

Block#(true) :
    (
       TextElement
       |
       Interpolation
       |
       TemplateElement
    )*
;

INJECT Block :
    import java.io.IOException;
    import freemarker.core.Environment;
    extends TemplateElement
{
    public void execute(Environment env) throws IOException 
    {
        for (TemplateElement element : childrenOfType(TemplateElement.class)) {
            env.render(element);
        }
    }

    public String getDescription() {
        if (getParent() == null) {
            return "root element";
        }
        return "content"; // Block is uninteresting in a stack trace.
    }
}


/**
 * A production freemarker text that may contain
 * ${...} but no directives.
 */

TemplateElement FreeMarkerText#Block :
    (
        TextElement
        |
        Interpolation
    )+
    {
       return CURRENT_NODE;
    }
;

TemplateHeaderElement# :
  [IgnorableWhitespace] 
  <FTL_HEADER> =>||
  (
    <ID>
    <EQUALS>
    Expression
  )*
  LooseDirectiveEnd
; 

IgnorableWhitespace#void :
   (
    <TRAILING_WHITESPACE> {popNode();}
    |
    <NON_TRAILING_WHITESPACE> {popNode();}
   )+
;

INJECT TemplateHeaderElement :
    import java.util.*;
    import freemarker.template.*;
    import static freemarker.template.utility.StringUtil.*;
    import static freemarker.core.variables.ObjectWrapper.*;
{

    private Map<String,Expression> params = new LinkedHashMap<>();

    public void close() {
        List<Node> ids = childrenOfType(ID);
        for (Node n : ids) {
            String key = n.toString();
            Expression exp = (Expression) n.nextSibling().nextSibling();
            params.put(key, exp);
        }
    }

    public boolean hasParameter(String name) {
        return params.containsKey(name);
    }

    public Map<String,Expression> getParams() {
        return params;
    }

    public Object getParameter(String name) {
        if (!hasParameter(name)) {
            return null;
        }
        Expression exp = params.get(name);
        return exp.evaluate(null);
    }

	public String getStringParameter(String name) {
		Object tm = getParameter(name);
        if (tm == null) return null;
		try {
			return asString(tm);
		} catch (ClassCastException cce) {
		    throw new IllegalArgumentException("Parameter " + name + " is not a string.");
		}
	}

	public boolean getBooleanParameter(String name) {
		Object tm = getParameter(name);
		if (tm == null) {
			throw new IllegalArgumentException("No parameter " + name);
		}
		if (isBoolean(tm)) {
			return asBoolean(tm);
		}
		if (isString(tm)) {
			try {
				return getYesNo(asString(tm));
			} catch (Exception e) {
				throw new IllegalArgumentException(e);
			}
		}
		throw new IllegalArgumentException("Parameter " + name + " is not a boolean type.");
	}
}

Map<String,Expression> ParamList#void :
{
   Token id;
   Expression exp;
   Map<String,Expression> result = new HashMap<String,Expression>();
}
   (
      id=<ID>
      <EQUALS>
      exp=Expression {result.put(id.toString(), exp);}
      [<COMMA>]
   )+
   {
       return result;
   }
;

Expression IdentifierOrStringLiteral#void :
   (
      <ID>
      |
      <STRING_LITERAL>
   )
   {
      return (Expression) peekNode();
   }   
;

/**
 * Root production to be used when parsing
 * an entire file.
 */
TemplateElement Root#void :
{
   TemplateHeaderElement header;
   TemplateElement doc;
}
   [
       header=TemplateHeaderElement
       {
       	   template.setHeaderElement(header);
       	   String templateEncoding = template.getEncoding();
       	   if (templateEncoding != null && header.hasParameter("encoding")) {
       	   	  String encoding = null;
       	   	  try {
       	   	     encoding = header.getStringParameter("encoding");
       	   	  } catch (Exception e) {}
       	   	  if (encoding != null && !encoding.equals(templateEncoding)) {
       	   	  	throw new Template.WrongEncodingException(encoding);
       	   	  }
       	   }
       }
   ]
   doc=Block
   <EOF>
   {
       return doc;
   }
   ;