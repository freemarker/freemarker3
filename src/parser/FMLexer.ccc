PARSER_PACKAGE="freemarker.core.parser";
TREE_BUILDING_ENABLED=false;
EXTRA_TOKENS=DIRECTIVE_END;

/**
 * The lexer portion defines 3 lexical states:
 * DEFAULT, EXPRESSION, DIRECTIVE_NAME
 * The lexer is in the DEFAULT state when it is 
 * just consuming regular text, but is scanning for
 * FreeMarker constructs. 
 * DIRECTIVE_NAME is a trivial state you are in just
 * after a <# or [# and we expect a directive name.
 * EXPRESSION is the state you are in
 * when the parser wants a FreeMarker expression.
 * So, for example, you enter the EXPRESSION state
 * right after a ${ and leave it after the matching }.
 * Or, you enter the EXPRESSION state right after
 * an "<#if" and then, when you hit the matching ">"
 * that ends the if directive, you go back to DEFAULT lexical state.
 */

INJECT LEXER_CLASS : 
   import static freemarker.template.utility.StringUtil.isFTLIdentifier;
{
    /**
    Keeps track of how deeply nested
    we have the hash literals.
    This is necessary since we need to be
    able to distinguish the } used to close
    a hash literal and the one used to
    close a ${
    */
    private int hashLiteralNesting;
    private int parenthesisNesting;
    private int bracketNesting;
    boolean onlyTextOutput;//, justAfterDot;
    private boolean inPointySyntax;
    String templateName;

    public void setOnlyTextOutput(boolean b) {
        this.onlyTextOutput = b;
    }

    private EnumSet<TokenType> directiveNames = EnumSet.of(
        _ATTEMPT, _RECOVER, IF, ELSE_IF, LIST, FOREACH, SWITCH,
        CASE, ASSIGN, GLOBALASSIGN, LOCALASSIGN, SET, _INCLUDE,
        IMPORT, FUNCTION, _MACRO, VISIT, STOP, RETURN,
        SETTING, EMBED, VAR, ELSE,
        BREAK, SIMPLE_RETURN, HALT, FLUSH, TRIM, LTRIM, RTRIM,
        DEFAUL, SIMPLE_NESTED, NESTED, SIMPLE_RECURSE, RECURSE,
        FALLBACK, ESCAPE, NOESCAPE, FTL_HEADER, TRIVIAL_FTL_HEADER,
        UNKNOWN_DIRECTIVE
    );

    private EnumSet<TokenType> emptyDirectives = EnumSet.of(
        _ATTEMPT, _RECOVER, VISIT,  
        ELSE, BREAK, SIMPLE_RETURN, HALT, FLUSH, TRIM, LTRIM, 
        RTRIM, DEFAUL, SIMPLE_NESTED, SIMPLE_RECURSE, FALLBACK, 
        NOESCAPE, TRIVIAL_FTL_HEADER 
    );

    private BASE_TOKEN_CLASS TOKEN_HOOK(BASE_TOKEN_CLASS token) {
        if (directiveNames.contains(token.getType())) {
            inPointySyntax = token.charAt(0) == '<';
            if (emptyDirectives.contains(token.getType())) {
                switchTo(LexicalState.DEFAULT);
            }
            else {
                switchTo (LexicalState.EXPRESSION);
            }
        }
        switch(token.getType()) {
            case GREATER_THAN_EQUALS : 
            case GREATER_THAN : 
                if (parenthesisNesting == 0 && inPointySyntax) {
                    if (token.getType() == GREATER_THAN_EQUALS) {
                        token.truncate(1);
                    }
                    token.setType(DIRECTIVE_END);
                    switchTo(LexicalState.DEFAULT);
                }
                break;
            case OPEN_PAREN : 
                parenthesisNesting++;
                switchTo(LexicalState.EXPRESSION);
                break;
            case CLOSE_PAREN :
                parenthesisNesting--;
                break;
            case OPEN_BRACKET : 
                bracketNesting++;
                break;
            case CLOSE_BRACKET : 
                if (bracketNesting > 0) {
                    --bracketNesting;
                } else {
                    token.setType(DIRECTIVE_END);
                    switchTo(LexicalState.DEFAULT);
                }
                break;
            case OPEN_BRACE : 
                ++hashLiteralNesting;
                break;
            case CLOSE_BRACE : 
                if (hashLiteralNesting > 0) {
                    --hashLiteralNesting;
                } else {
                    switchTo(LexicalState.DEFAULT);
                }
                break;
            case UNIFIED_CALL : 
                switchTo(LexicalState.EXPRESSION);
                break;
        }
        return token;
    }
}

UNPARSED :
    <?COMMENT : ("<#--" | "[#--") (~[])* ("--]" | "-->")>
;

MORE :
    <START_TAG : "<#" | "[#"> : DIRECTIVE_NAME
;    

TOKEN :
    <CLOSE_DIRECTIVE_BLOCK : ("[/#" (~["]"])* "]") | ("</#" (~[">"])* ">")> 
    |
    <UNIFIED_CALL : "<@" | "[@" > 
    |
    <UNIFIED_CALL_END : ("<" | "[") "/@" (~[" ", "\t", "\n", "\r", ">", "]"])* (">" | "]")> 
    |
    <OUTPUT_ESCAPE : "${" > : EXPRESSION
    |
    <?NOPARSE : <NOPARSE_BEGIN> (~[])* <NOPARSE_END> > #LegacyNoParse
    |
    <#NOPARSE_BEGIN :   ("<#noparse" (<BLANK>)* ">") | ("/#noparse" (<BLANK>)* "]")>
    |
    <#NOPARSE_END :  ("</#noparse" (<BLANK>)* ">") | ("[/#noparse" (<BLANK>)* "]")>
;

TOKEN#Text :
    <TRAILING_WHITESPACE : (["\t"," "])* "\n"> #Whitespace
    |
    <NON_TRAILING_WHITESPACE : (["\t"," "])+> #Whitespace
    |
    <PROBLEMATIC_CHAR : "$" | "<" | "["> #Printable
    |
    <REGULAR_PRINTABLE : (~["$", "<", "[" ,"\t", " ", "\n"])+> #Printable
;

INJECT Whitespace :
{
    public boolean isIgnored() {
        return isNonOutputtingLine() 
            || getType() == TRAILING_WHITESPACE && checkForExplicitRightTrim() 
            || getType() == NON_TRAILING_WHITESPACE && getBeginColumn() == 1 && checkForExplicitLeftTrim(); 
    }

    private boolean checkForExplicitLeftTrim() {
        Token tok = nextCachedToken();
        while (tok != null && tok.getBeginLine() == this.getBeginLine()) {
            if (tok.getType() == TRIM || tok.getType() == LTRIM) {
                return true;
            }
            tok = tok.nextCachedToken();
        }
        return false;
    }

    private boolean checkForExplicitRightTrim() {
        Token tok = previousCachedToken();
        while (tok != null && tok.getBeginLine() == this.getBeginLine()) {
            if (tok.getType() == TRIM || tok.getType() == RTRIM) {
                return true;
            }
            tok = tok.previousCachedToken();
        }
        return false;
    }
    
    private boolean isNonOutputtingLine() {
        if (spansLine()) return false;
        Token tok = previousCachedToken();
        while (tok != null && tok.getEndLine() == getBeginLine()) {
            if (tok.firstAncestorOfType(Macro.class) != this.firstAncestorOfType(Macro.class)) {
                tok = tok.previousCachedToken();
                continue;
            }
            if (tok.getType() == CLOSE_BRACE && tok.getParent() instanceof Interpolation) {
                return false;
            }
            if (tok.getType() == REGULAR_PRINTABLE || tok.getType() == PROBLEMATIC_CHAR || tok.getType() == NOPARSE) {
                return false;
            } 
            tok = tok.previousCachedToken();
        }
        tok = nextCachedToken();
        while (tok != null && tok.getBeginLine() == getBeginLine()) {
            if (tok.firstAncestorOfType(Macro.class) != this.firstAncestorOfType(Macro.class)) {
                tok = tok.nextCachedToken();
                continue;
            }
            if (tok.getType() == OUTPUT_ESCAPE) {
                return false;
            }
            if (tok.getType() == REGULAR_PRINTABLE || tok.getType() == PROBLEMATIC_CHAR || tok.getType() == NOPARSE) {
                return false;
            } 
            tok = tok.nextCachedToken();
        }
        return true;
    }

    private boolean spansLine() {
        return getBeginColumn() == 1 && charAt(length()-1) == '\n';
    }
}

<DIRECTIVE_NAME> TOKEN :
    <#BLANK : [" ", "\t", "\n", "\r"]>
    |
    <#CLOSE_TAG1 : (<BLANK>)* (">" | "]")>
    |
    <#CLOSE_TAG2 : (<BLANK>)* ("/")? (">" | "]")>
    |
    <_ATTEMPT : "attempt" <CLOSE_TAG1>> 
    |
    <_RECOVER : "recover" <CLOSE_TAG1>>
    |
    <IF : "if" <BLANK>> 
    |
    <ELSE_IF : "elseif" <BLANK>>
    |
    <LIST : "list" <BLANK>> 
    |
    <FOREACH : "foreach" <BLANK>> 
    |
    <SWITCH : "switch" <BLANK>>
    |
    <CASE : "case" <BLANK>> 
    |
    <ASSIGN : "assign" <BLANK>>
    |
    <GLOBALASSIGN : "global" <BLANK>> 
    |
    <LOCALASSIGN : "local" <BLANK>> 
    |
    <SET : "set" <BLANK>>
    |
    <_INCLUDE : "include" <BLANK>> 
    |
    <IMPORT : "import" <BLANK>> 
    |
    <FUNCTION : "function" <BLANK>> 
    |
    <_MACRO : "macro" <BLANK>>
    |
    <VISIT : "visit" <BLANK>> 
    |
    <STOP : "stop" <BLANK>> 
    |
    <RETURN : "return" <BLANK>> 
    |
    <SETTING : "setting" <BLANK>> 
    |
    <EMBED : "embed" <BLANK>> 
    |
    <VAR : "var"  <BLANK>>
    |
    <ELSE : "else" <CLOSE_TAG2>> 
    |
    <BREAK : "break" <CLOSE_TAG2>> 
    |
    <SIMPLE_RETURN : "return" <CLOSE_TAG2>>
    |
    <HALT : "stop" <CLOSE_TAG2>> 
    |
    <FLUSH : "flush" <CLOSE_TAG2>> 
    |
    <TRIM : "t" <CLOSE_TAG2>> 
    |
    <LTRIM : "lt" <CLOSE_TAG2>> 
    |
    <RTRIM : "rt" <CLOSE_TAG2>> 
    |
    <DEFAUL : "default" <CLOSE_TAG1>> 
    |
    <SIMPLE_NESTED : "nested" <CLOSE_TAG2>> 
    |
    <NESTED : "nested" <BLANK>> 
    |
    <SIMPLE_RECURSE : "recurse" <CLOSE_TAG2>>
    |
    <RECURSE : "recurse" <BLANK>>
    |
    <FALLBACK : "fallback" <CLOSE_TAG2>> 
    |
    <ESCAPE : "escape" <BLANK>> 
    |
    <NOESCAPE : "noescape" <CLOSE_TAG1>> 
    |
    <FTL_HEADER : "ftl" <BLANK>>
    |
    <TRIVIAL_FTL_HEADER : "ftl" <CLOSE_TAG2>> 
    |
    <UNKNOWN_DIRECTIVE : (["a"-"z","A"-"Z", "_"])+>
;


<EXPRESSION> SKIP :
    < ( " " | "\t" | "\n" | "\r" )+ >
    |
    <?EXPRESSION_COMMENT1 : "<#--" (~[])* "-->">
    |
    <?EXPRESSION_COMMENT2 : "[#--" (~[])* "--]">
;

<EXPRESSION> TOKEN :
  <STRING_LITERAL :
      ("\"" 
          ((~["\\", "\""]) | ("\\" ~[]))*      
      "\"")
      |
      ("'"
          ((~["\\", "'"]) | ("\\" ~[]))*            
      "'")
  > 
  |
  <RAW_STRING : "r" (("\"" (~["\""])* "\"") | ("'" (~["'"])* "'"))>
  |
  <FALSE : "false">
  |
  <TRUE : "true">
  |
  <NULL : "null">
  |
  <INTEGER : (["0"-"9"])+>
  |
  <DECIMAL : <INTEGER> "." <INTEGER>>
  |
  <DOT : ".">
  |
  <DOT_DOT : "..">
  |
  <BUILT_IN : "?">
  |
  <EXISTS : "??">
  |
  <EQUALS : "=">
  |
  <DOUBLE_EQUALS : "==">
  |
  <NOT_EQUALS : "!=">
  |
  <GREATER_THAN : ">">
  |
  <GREATER_THAN_EQUALS: ">=">
  |
  <EMPTY_DIRECTIVE_END : "/>" | "/]"> : DEFAULT
  |
  <LESS_THAN : "lt" | "<" | "&lt;">
  |
  <LESS_THAN_EQUALS : "lte" | "<=" | "&lt;=">
  |
  <ESCAPED_GT: "gt" | "\\gt" |  "&gt;">
  |
  <ESCAPED_GTE : "gte" | "\\gte" | "&gt;=">
  |
  <PLUS : "+">
  |
  <MINUS : "-">
  |
  <TIMES : "*">
  |
  <DOUBLE_STAR : "**">
  |
  <ELLIPSIS : "...">
  |
  <DIVIDE : "/">
  |
  <PERCENT : "%">
  |
  <AND : "&" | "&&" >
  |
  <OR : "|" | "||">
  |
  <EXCLAM : "!">
  |
  <COMMA : ",">
  |
  <SEMICOLON : ";">
  |
  <COLON : ":">
  |
  <OPEN_BRACKET : "[">
  |
  <CLOSE_BRACKET : "]"> 
  |
  <OPEN_PAREN : "("> 
  |
  <CLOSE_PAREN : ")"> 
  |
  <OPEN_BRACE : "{" > 
  |
  <CLOSE_BRACE : "}" >
  |
  <IN : "in">
  |
  <AS : "as">
  |
  <USING : "using">
;

INCLUDE JAVA_IDENTIFIER_DEF

<EXPRESSION> TOKEN:
   <ID: ("@"|<JAVA_IDENTIFIER_START>)("@"|<JAVA_IDENTIFIER_PART>)*>
;
